#!/usr/bin/perl
#
# userbase.cgi
#
######################################################################
#
# DO NOT EDIT THIS FILE unless absolutely necessary; in most cases you
# should be editing userbase_prefs.cgi instead.  If you do edit this
# file, be sure to make a backup copy first.
# 
######################################################################
#
# This program is the copyrighted work of Encodable Industries.
# Redistribution is prohibited, and copies are permitted only for
# backup purposes.  You are free to modify the program for your
# own use, but you may not distribute any modified copies of it.
#
# Use of this program requires a one-time license fee.  You can
# obtain a license here:
#
#	http://encodable.com/userbase/
#
# This software comes with no warranty.  It is our hope that you
# find it useful, but it comes with no guarantees.  Under no
# circumstances shall Encodable Industries be held liable in any
# situation arising from your use of this program.
#
# For more information about this program, as well as for help
# and support, please visit the following pages:
#
# Homepage: http://encodable.com/userbase/
# Contact:  http://encodable.com/contact/


my $version = "3.18-t02";
use CGI::Carp 'fatalsToBrowser';
$ENV{PATH} = '/bin:/usr/bin:/usr/local/bin' unless $^O =~ /MSWin32/;
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
($ENV{DOCUMENT_ROOT}) = ($ENV{DOCUMENT_ROOT} =~ /(.*)/); # untaint.
#$ENV{DOCUMENT_ROOT} = 'c:\some\dir'; # If autodetection fails, uncomment & set this.
#$ENV{SCRIPT_NAME} = '/cgi-bin/userbase.cgi'; # If autodetection fails, uncomment & set this.
use lib './perlmodules';
use lib '../cgi-bin/perlmodules';
use lib '../../cgi-bin/perlmodules';
use lib "$ENV{DOCUMENT_ROOT}/cgi-bin/perlmodules";
use lib "$ENV{DOCUMENT_ROOT}/../cgi-bin/perlmodules";
my (%PREF,%TEXT,%COOKIE,%QS,%WEBCFG,%MISC) = ();
use Time::HiRes 'gettimeofday'; $PREF{script_start_time_highres} = gettimeofday();

my $debuglog = undef; #open($debuglog, ">>encdata/userbase/debuglog.ubtemp.log") or die_nice("couldn't open debuglog: $!\n"); flock $debuglog, 2; print $debuglog "\n\n";

sub printd;
sub die_nice;
sub enc_warn;
sub encdebug;
sub encdebughi;
sub encdebuglog;
sub exit_with_error;

my $qs = '';

use strict;
use POSIX;
use DBI;
use Time::Local;
use Digest::MD5 'md5_hex';
use File::Copy;
#use Math::Random::Secure qw(rand);  # for higher-quality rand() for increased security.




# This function must do a case-sensitive lookup (i.e., do NOT use LOWER()) because
# FC's userdirs are case-sensitive.  So whatever case is used when a username is
# created is the case that must always be used when logging in with it.
# UPDATE: MySQL's equal operator (=) is case-insensitive, absurdly.  To force it
# to act case-sensitively, you must use the BINARY function, as in:
#	... WHERE BINARY `username` = '$username'
#
sub account_exists($$)
{
	my $user = shift; check_username_for_sql_safeness($user);
	my $pass = shift; check_hashedpw_for_sql_safeness($pass);

	my $BINARY = $PREF{make_usernames_case_insensitive} =~ /yes/i ? '' : 'BINARY';   # not needed for the pw here because it's a pw hash, not the user's actual password.
	my $count = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE $BINARY `username` = '$user' AND `password` = '$pass'");

	if($count == 1)		{ return 1; }
	elsif($count > 1)	{ die_nice("account_exists('$user', '$pass'): error: duplicate records ($count total) for this user!\n"); }
	else			{ return 0; }
}


# Used when creating a new account or changing/resetting a password:
sub create_new_password_hash
{
	my $plaintext_password = shift;
	$plaintext_password = lc($plaintext_password) if $PREF{make_passwords_case_insensitive} =~ /yes/i;
	my $salt = create_random_salt();
	my $hashed_password = do_pw_hash_format3($plaintext_password, $salt, $PREF{password_hash_iterations});
	return ($hashed_password, $salt);
}


# Used when verifying a password (during login, or before a manual password change):
sub hash_this_password
{
	my $optsref = shift; my %opts = %$optsref;
	my $userid = get_user_id($opts{username});
	return generate_nonce() unless $userid;   # return garbage if the specified account DNE.

	my $salt = get_salt_for_account({ username=>$opts{username} });
	# Actually, don't die on missing salt here.  The salt will be missing anytime the entered username
	# is non-existent.  So if we die on missing salt, then we're displaying this cryptic error message
	# instead of the normal (and more friendly) invalid-login message.  Better to just let this sub do
	# its thing with the null salt and return the (wrong) hash so that we can display the normal error.
	#die_nice "no salt...\n" unless $salt;
	return generate_nonce() unless $salt;   # return garbage if the specified account DNE.

	my ($hash_for_this_account, $pwformat_for_this_account, $hash_iterations_for_this_account, $sitesaltA_for_this_account, $sitesaltZ_for_this_account) = get_hashedpw($userid);

	$opts{plaintext_password} = lc($opts{plaintext_password}) if $PREF{make_passwords_case_insensitive} =~ /yes/i;

	my $hashed_password = '';
	if($pwformat_for_this_account == 1)
	{
		my ($salt1,$salt2) = ($salt =~ /^(.{15})(.{25})$/);
		$hashed_password = md5_hex($salt1 . $opts{plaintext_password} . $salt2);
	}
	elsif($pwformat_for_this_account == 2)
	{
		my ($salt1,$salt2) = ($salt =~ /^(.{15})(.{25})$/);
		$hashed_password = sha1_hex($salt1 . $opts{plaintext_password} . $salt2);
	}
	else
	{
		# $pwformat is 3, the new/current one:
		$hashed_password = do_pw_hash_format3($opts{plaintext_password}, $salt, $hash_iterations_for_this_account);
	}
	return $hashed_password;
}


sub get_hashedpw   # call in list context to get the MD5/SHA1/SHA256 hash in a separate var without the v/x/s suffix.
{
	my $userid = shift;
	my $hashedpw_full = get_hashedpw_full($userid);
	my ($hash, $pwformat, $iterations, $sitesaltA, $sitesaltZ) = get_hashedpw_parts($hashedpw_full);
	return wantarray ? ($hash, $pwformat, $iterations, $sitesaltA, $sitesaltZ) : $hashedpw_full;
}


sub get_hashedpw_full   # includes the v/x/s on the end.
{
	my $userid = shift;
	check_uid_for_uniqueness($userid); # checks for sql safeness too.
	return enc_sql_select("SELECT `password` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub get_hashedpw_parts
{
	my $fullhash = shift;
	my ($hash, $pwformat, $iterations, $sitesaltA, $sitesaltZ) = ();
	if($fullhash =~ /(.+)v(\d+)x(\d+)s(.*)/)
	{
		($hash, $pwformat, $iterations, my $sitesalt_abbr) = ($1, $2, $3, $4);
		($sitesaltA, $sitesaltZ) = ($sitesalt_abbr =~ /^([0-9a-zA-Z])([0-9a-zA-Z])$/);
	}
	else
	{
		# old pre-v3 formats, where the hash in the db is JUST the raw hash, either MD5 or SHA1.
		$hash = $fullhash;
		$iterations = 1;
		$pwformat = length($fullhash) == 40 ? 2 : length($fullhash) == 32 ? 1 : 0;
	}
	return ($hash, $pwformat, $iterations, $sitesaltA, $sitesaltZ);
}


sub get_salt_for_account
{
	my $optsref = shift; my %opts = %$optsref;
	if($opts{userid})
	{
		die_unless_numeric($opts{userid}, 'userid');
		return enc_sql_select("SELECT `salt` FROM `$PREF{user_table}` WHERE `id` = $opts{userid};")
	}
	elsif($opts{username})
	{
		check_username_for_sql_safeness($opts{username});
		return enc_sql_select("SELECT `salt` FROM `$PREF{user_table}` WHERE `username` = '$opts{username}';")
	}
	else
	{
		die_nice "Need a userid or a username...";
	}
}


sub get_pw_format_nice($)
{
	my $formatnum = get_pw_format(@_);
	if($formatnum == 1)	{ return 'MD5'; }
	elsif($formatnum == 2)	{ return 'SHA1'; }
	elsif($formatnum == 3)	{ return 'SHA256'; }
}


sub get_pw_format($)
{
	my $optsref = shift; my %opts = %$optsref;

	if($opts{username})
	{
		check_username_for_sql_safeness($opts{username});
		# we don't allow duplicate usernames that differ only in case (see username_is_taken()), so we'll fold them for
		# this check, rather than using BINARY and making this a test of the username itself, which isn't the goal here.
		$opts{hashedpw} = enc_sql_select("SELECT `password` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$opts{username}')");
		$opts{format} = $opts{hashedpw} =~ /.+v(\d+)x(\d+)s/ ? $1 : 0;
	}

	if($opts{format})   # will be zero for old (pre-format-3) accounts.
	{
		return $opts{format};
	}
	elsif(length($opts{hashedpw}) == 40)   # SHA1
	{
		return 2;
	}
	elsif(length($opts{hashedpw}) == 32)   # MD5
	{
		return 1;
	}
	else
	{
		exit_with_error qq`Error: couldn't determine password format.`;   # something went really wrong
	}
}


sub update_stored_password_hash_if_necessary($$$)
{
	my ($userid, $plaintext_pw, $current_pw_hash) = @_;
	if(length($current_pw_hash) < 64)   # old MD5 or SHA1 hash.
	{
		my ($new_pw_hash, $salt) = create_new_password_hash($plaintext_pw);
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `password` = '$new_pw_hash', `salt` = '$salt' WHERE `id` = $userid");
		die_nice("SQL returned '$success' instead of '1' while updating hashedpw and salt for userid='$userid'") unless $success == 1;

		my $oldlength = length($current_pw_hash);
		my $newlength = length($new_pw_hash);
		$current_pw_hash = substr($current_pw_hash, 0, 5) . "...(length=$oldlength)";
		$new_pw_hash = substr($new_pw_hash, 0, 5) . "...(length=$newlength)";
		applog("updated pw hash (and salt) for uid=$userid from $current_pw_hash to $new_pw_hash");
	}
}


sub check_for_multiple_logins($$)
{
	# This is to be called only at login, not at check_if_logged_in().

	my ($userid,$username) = @_;
	die_unless_numeric($userid,'userid');
	check_username_for_sql_safeness($username);
	my $old_login_time = enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid;");
	if($old_login_time =~ /[1-9]/   &&   !login_session_expired($old_login_time))
	{
		if($PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i)
		{
			if($PREF{in_illegal_multilogon_dispute_which_user_gets_kicked} =~ /old/i)
			{
				# Kill all existing sessions for this username, and then return null, so
				# so that the current user's login can proceed and become the sole login
				# under this username.

				log_user_out_of_db($username, 'force');
				return '';
			}
			else
			{
				# Else the pref says the new user should get kicked, so just redirect him
				# to the appropriate error page, so his login never proceeds.

				enc_redirect("$PREF{login_url}?phase=emultlogin");
			}
		}
		else
		{
			my $existing_session_id = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
			return $existing_session_id;
		}
	}
}


sub update_loggedin_count_for_this_user($)
{
	my $userid = shift;
	die_unless_numeric($userid,'userid');
	my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers`=IFNULL(`numusers`,0)+1 WHERE `id` = '$userid';");
	die_nice("SQL returned '$success' instead of '1' while incrementing numusers column. (userid='$userid')") unless $success == 1;
}


sub log_user_into_db
{
	my ($userid, $my_session_id, $logintime, $restrict_ip) = @_;

	die_unless_numeric($userid,'userid');
	die_unless_numeric($logintime,'logintime');

	check_sessionid_for_sql_safeness($my_session_id);

	my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = $logintime, `mrsession` = '$my_session_id' WHERE `id` = '$userid';");
	die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while logging user in.") unless $success == 1;

	if($restrict_ip)
	{
		my $ip = $PREF{ip};
		check_ip_for_sql_safeness($ip);

		unless(enc_sql_select("SELECT `ip` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq $ip)
		{
			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `ip` = '$ip' WHERE `id` = '$userid';");
			die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while setting user IP.") unless $success == 1;
		}
	}
	else
	{
		unless(enc_sql_select("SELECT `ip` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq '')
		{
			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `ip` = '' WHERE `id` = '$userid';");
			die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while clearing user IP.") unless $success == 1;
		}
	}
}


sub update_logins_table($$)
{
	my ($userid, $session_id) = @_;
	my $timestamp = offsettime();

	check_id_for_sql_safeness($userid);
	check_sessionid_for_sql_safeness($session_id);
	die_unless_numeric($timestamp, 'timestamp');

	my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
	sql_untaint($ip, $host, $ua);
	die_unless_sqlsafe($ip, $host, $ua);

	enc_sql_insert("INSERT INTO `$PREF{logins_table}` (`user_id`, `session_id`, `timestamp`, `ip_address`, `hostname`, `browser`) VALUES('$userid', '$session_id', '$timestamp', '$ip', '$host', '$ua')");

	while(enc_sql_select("SELECT COUNT(*) FROM `$PREF{logins_table}` WHERE `user_id` = $userid") > $PREF{num_logins_to_log_per_user})
	{
		my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{logins_table}` WHERE `user_id` = $userid");
		enc_sql_delete("DELETE FROM `$PREF{logins_table}` WHERE `timestamp` = $oldest AND `user_id` = $userid LIMIT 1");
	}
}


sub update_failed_logins_table($$)
{
	my ($input_username, $input_password) = @_;

	# The purpose of this fingerprint is just to see when a user has repeatedly entered the same
	# wrong password (or to verify that he hasn't).  But storing the full hash of a singly-hashed
	# password would be insecure, so we'll just take the first 10 characters.
	#
	my $pw_fingerprint = substr(sha256_hex($input_password), 0, 10);
	check_hashedpw_for_sql_safeness($pw_fingerprint);

	my $timestamp = offsettime();
	die_unless_numeric($timestamp, 'timestamp');

	my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
	sql_untaint($input_username, $ip, $host, $ua);
	die_unless_sqlsafe($input_username, $ip, $host, $ua);

	enc_sql_insert("INSERT INTO `$PREF{failed_logins_table}` (`username`, `password_fingerprint`, `timestamp`, `ip_address`, `hostname`, `browser`) VALUES('$input_username', '$pw_fingerprint', '$timestamp', '$ip', '$host', '$ua')");

	while(enc_sql_select("SELECT COUNT(*) FROM `$PREF{failed_logins_table}` WHERE `username` = '$input_username'") > $PREF{num_failed_logins_to_log_per_user})
	{
		my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{failed_logins_table}` WHERE `username` = '$input_username'");
		enc_sql_delete("DELETE FROM `$PREF{failed_logins_table}` WHERE `timestamp` = $oldest AND `username` = '$input_username' LIMIT 1");
	}
}


sub update_password_activity_table
{
	my ($user_id,$hashed_password,$salt,$id_of_user_performing_update) = @_;

	# $id_of_user_performing_update is zero if the update is during the
	# initial account creation, or if it's due to a password reset.

	die_unless_numeric($user_id, 'user_id');
	die_unless_numeric($id_of_user_performing_update, 'id_of_user_performing_update');
	check_hashedpw_for_sql_safeness($hashed_password);
	check_salt_for_sql_safeness($salt);

	my $timestamp = offsettime();
	die_unless_numeric($timestamp, 'timestamp');

	my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
	sql_untaint($ip, $host, $ua);
	die_unless_sqlsafe($ip, $host, $ua);

	enc_sql_insert("INSERT INTO `$PREF{password_activity_table}` (`user_id`, `password_fingerprint`, `salt`, `timestamp`, `user_who_did_update`, `ip_address`, `hostname`, `browser`) VALUES('$user_id', '$hashed_password', '$salt', '$timestamp', '$id_of_user_performing_update', '$ip', '$host', '$ua')");

	while(enc_sql_select("SELECT COUNT(*) FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id'") > $PREF{num_pw_updates_to_log_per_user})
	{
		my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id'");
		enc_sql_delete("DELETE FROM `$PREF{password_activity_table}` WHERE `timestamp` = $oldest AND `user_id` = '$user_id' LIMIT 1");
	}
}


sub make_sure_new_password_is_not_a_repeat
{
	# TODO: possibly broken by the early-2015 hash change; disabling and removing $PREF{prevent_pw_reuse_for_this_many_pw_changes} from the prefs file for now.
	return;

	my ($user_id,$new_password) = @_;

	my $limit = $PREF{prevent_pw_reuse_for_this_many_pw_changes};
	if($limit =~ /^\d+$/ && $limit > 0)
	{
		die_unless_numeric($user_id, 'user_id');
		my $old_passwords = enc_sql_select_multi("SELECT `password_fingerprint`,`salt` FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id' ORDER BY `timestamp` DESC LIMIT $limit");
		foreach my $i (keys %$old_passwords)
		{
			#exit_with_error($TEXT{password_reuse_error}) if salt_and_crypt_password($new_password,$$old_passwords{$i}{salt}) eq $$old_passwords{$i}{password_fingerprint};
			exit_with_error($TEXT{password_reuse_error}) if hash_this_password($new_password,$$old_passwords{$i}{salt}) eq $$old_passwords{$i}{password_fingerprint};
		}
	}
}


sub determine_default_login_destination
{
	my $ref = shift;
	my $go = ();
	if($qs =~ /(?:^|&)whence=(.+)/)
	{
		# don't URL-decode here because this is getting passed right
		# to the Location: header, which requires URL encoding.

		$go = $1;
		if($qs =~ /(?:^|&)encanchor=([^&]+)(?:&|$)/)
		{
			$go .= '#' . $1;
		}
	}
	elsif($ref)
	{
		$go = $ref;

		if($go =~ m!.*whence=(https?(://|%3a%2f%2f).+)!i)
		{
			$go = $1;
			enc_urldecode($go);
		}

		if($go =~ /(log(ged)?out|smsg=|kmsg=|rslt=|noautoredirect=true)/   ||   $go =~ /(action=signup|action=verify|action=pwreset|phase=\w+)/   ||   $go !~ m!^https?://(www\.)?$ENV{HTTP_HOST}!)
		{
			# If the page we were on before was a logout page, or if it was an external
			# site, or if it was one of various other internal pages that don't make
			# sense to redirect to, then just return to the login frontpage.
			#
			$go = $PREF{login_url};
		}
	}
	else
	{
		$go = $PREF{login_url};
	}
	$go =~ s!_THEQS_!?!g; $go =~ s!_ANAMP_!&!g;
	return $go;
}


sub prompt_for_login()
{
	$PREF{on_page} = 'login';
	printd "prompt_for_login()";

	# don't urldecode here, because it's just going right back onto the URL.
	my $whence = $qs =~ /(?:^|&)whence=(.+)/ ? "&whence=$1" : undef;
	if($qs =~ /(?:^|&)encanchor=([^&]+)(?:&|$)/)
	{
		$whence = "&encanchor=$1" . $whence;
	}

	my $rememberme_checkbox = $PREF{enable_rememberme_checkbox} =~ /yes/i && !$PREF{idle_timeout};
	my $restrictip_checkbox = $PREF{enable_ip_address_restriction} =~ /yes/i && $PREF{force_ip_address_restriction} !~ /yes/;

	my $message = '';
	if($qs =~ /(?:^|&)phasemsg=(.+?)(?:&|$)/) { $message = $TEXT{messages}{$1}; $message = $message ? qq`<div id="formmessage">$message</div>\n` : ''; }

	my $template = $qs =~ /format=mini/ ? $PREF{login_form_template__mini} : $PREF{login_form_template};
	$template =~ s/%%whence%%/$whence/g;
	$template =~ s/%%loginreturn%%/get_qs_var('loginreturn')/eg;
	$template =~ s!%%special_message%%!$message!g;
	$template =~ s!%%%if-rememberme%%%(.+)%%%end-rememberme%%%!$rememberme_checkbox ? $1 : ''!egs;
	$template =~ s!%%%if-restrictip%%%(.+)%%%end-restrictip%%%!$restrictip_checkbox ? $1 : ''!egs;
	$template = interpolate_userbase_variables($template);

	print_http_headers();
	start_html_output("Login") unless $qs =~ /format=mini/;
	print $template unless $qs =~ /null_if_logged_out/;
	finish_html_output() unless $qs =~ /format=mini/;
}


sub user_has_addmember_rights
{
	return user_is_allowed_to($PREF{logged_in_userid}, 'create_user_accounts') || logged_in_user_is_subgroup_manager();
}


sub user_has_addadmin_rights
{
	return user_is_allowed_to($PREF{logged_in_userid}, 'create_admin_accounts');
}


sub export_users_to_CSV_file
{
	exit_with_needprivs() unless user_is_allowed_to('export_accounts');
	my $datetime_format = $PREF{datetime_format_for_account_export} || $PREF{global_datetime_format} || '%Y%m%d-%H:%M:%S';

	if($qs =~ /final=yes/i)
	{
		my $output = '';
		my %options = ();
		my @fields = ();
		while($qs =~ /(?:^|&)(\w+)=on/ig)
		{
			my $field = $1;
			if($field =~ /^(doublequoteallfields|includeadmins|downloadablefile)$/i) { $options{$1} = 1; next; }
			push @fields, $field;
		}
		my $csvcommareplacement = get_qs_var('csvcommareplacement');
		my $csvnewlinereplacement = get_qs_var('csvnewlinereplacement');

		my @output = ();
		foreach my $field (@fields)
		{
			push(@output, $options{doublequoteallfields} ? qq`"$field"` : $field);
		}
		$output .= join(",", @output) . "\n";

		my $fieldlist = join ",", @fields; # note: this is SQL-safe because of the regex in the while() above.
		$fieldlist =~ s!(^|,)groups(,|$)!$1$2!; decommaify($fieldlist);   # remove 'groups' from the $fieldlist var since that's not actually a column in the user db.
		my $data = enc_sql_select_multi("SELECT $fieldlist FROM `$PREF{user_table}`");
		foreach my $j (sort { $a <=> $b } keys %$data)
		{
			next if is_admin_acct($$data{$j}{id}) && !$options{includeadmins};
			@output = ();
			foreach my $field (@fields)
			{
				my $value = $$data{$j}{$field};
				if($field eq 'groups') { $value = get_groups_this_user_belongs_to($$data{$j}{id}); }
				$value =~ s!,!$csvcommareplacement!g if $csvcommareplacement;
				$value =~ s!\n!$csvnewlinereplacement!gs if $csvnewlinereplacement;
				$value = strftime($datetime_format, localtime($value)) if $value && $field =~ /^(lastactive)$/;
				push(@output, $options{doublequoteallfields} ? qq`"$value"` : $value);
			}
			$output .= join(",", @output) . "\n";
		}

		if($options{downloadablefile})
		{
			my $filename = 'Exported_UserBase_accounts_' . strftime("%Y%m%d-%H%M%S",localtime(offsettime())) . '.csv';
			select STDOUT; $| = 1;
			print	  qq`Content-Type: application/octet-stream\n`
				. qq`Content-Disposition: attachment; filename="$filename"\n`
				. qq`Content-Length: ` . length($output) . qq`\n`
				. qq`Content-Description: Downloadable File\n\n`;
		}
		else
		{
			print "Content-type: text/plain\n\n";
		}

		print $output;
	}
	else
	{
		start_html_output();

		print qq`

		<h1 class="pagetitle">Export Users To CSV File</h1>
		<h3>Choose Fields To Export</h3>
		<form name="ub_csv_export" id="ub_csv_export" method="get" action="$ENV{SCRIPT_NAME}">
		<input type="hidden" name="action" value="csvexport" />
		<input type="hidden" name="final" value="yes" />
		<p>Note: for security purposes, UserBase does not store raw passwords; it only stores
		hashed passwords.&nbsp; Therefore raw passwords cannot ever be retrieved nor exported.</p>
		<table><tr>
		`;

		my (@builtin_fields, @custom_fields) = ();
		foreach my $field (split(/,/, get_db_colnames($PREF{user_table})))
		{
			is_builtin_fieldname($field) ? push(@builtin_fields, $field) : push(@custom_fields, $field);
			push(@builtin_fields, 'groups') if $field eq 'email';   # manually insert a 'groups' field after the email field.
		}

		print qq`<th class="left">Built-In Fields:</th>\n<th>Custom Fields:</th>\n</tr>\n<tr>\n`;

		print qq`<td class="left">\n`;
		foreach my $field (@builtin_fields)
		{
			#my $checked = $field =~ /^(password|salt)$/i ? '' : qq`checked="checked"`;
			my $checked = $field =~ /^(id|username|name|email|groups)$/i ? qq`checked="checked"` : '';
			print qq`<input type="checkbox" name="$field" id="ub_export_$field" $checked /><label for="ub_export_$field">$field</label><br />\n`;
		}
		print qq`(none)` unless @builtin_fields;

		print qq`\n</td>\n<td>\n`;
		foreach my $field (@custom_fields)
		{
			print qq`<input type="checkbox" name="$field" id="ub_export_$field" checked="checked" /><label for="ub_export_$field">$field</label><br />\n`;
		}
		print qq`(none)` unless @custom_fields;

		print qq`
		</td></tr></table>

		<table>
		<tr><th>Options:</th></tr>
		<tr><td><input type="checkbox" name="includeadmins" id="includeadmins" /><label for="includeadmins">Include administrator accounts</label></td></tr>
		<tr><td><input type="checkbox" name="doublequoteallfields" id="doublequoteallfields" /><label for="doublequoteallfields">Double-quote all fields</label></td></tr>
		<tr><td><input type="checkbox" name="downloadablefile" id="downloadablefile" /><label for="downloadablefile">Download CSV instead of displaying in browser</label></td></tr>
		<tr><td>Replace commas in data with:<br /><input type="text" name="csvcommareplacement" id="csvcommareplacement" value="THIS_IS_A_REAL_COMMA" /> (null to disable)</td></tr>
		<tr><td>Replace newlines in data with:<br /><input type="text" name="csvnewlinereplacement" id="csvnewlinereplacement" value="THIS_IS_A_REAL_NEWLINE" /> (null to disable)</td></tr>
		</table>

		<br /><input type="submit" name="ub_csv_submit" id="ub_csv_submit" value="Export CSV File" />
		</form>

		`;

		finish_html_output();
	}
}


sub import_users_from_CSV_file
{
	exit_with_needprivs() unless user_is_allowed_to('import_accounts');

	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		my $upload_field_name = "ub_csv_filename";
		my $query = new CGI;
		my $filename = enc_param($upload_field_name, $query);
		$filename = lc($filename) unless $PREF{dont_convert_upload_filenames_to_lowercase} =~ /yes/i;
		$filename =~ s!.*?([^/\\]+)$!$1!;	# remove any path.
		$filename =~ s!\.{2,}!.!g;		# condense any multi-dots.
		$filename =~ s![^\w\.-]!_!g;		# remove any unusual stuff including spaces.

		my ($file_base,$file_ext) = ($filename =~ /(.+)\.(.+)/);
		die_nice qq`File base name must not be null.` unless $file_base;
		die_nice qq`File extension must be "csv" but it's "$file_ext".` unless $file_ext =~ /^csv$/i;
		$file_base .= '.ubcsvimport';

		my $path = $PREF{datadir}; $path .= '/' unless $path =~ m!/$!;

		my $spacer = $file_base =~ / / ? ' ' : '_';
		my $file_base_serialized = $file_base;
		my $i = 0;
		while(-e "$path$file_base_serialized.$file_ext")
		{
			$i++;
			my $j = $i < 10 ? "0$i" : $i;
			$file_base_serialized = $file_base . $spacer . $j;
		}
		$file_base = $file_base_serialized;
		$filename = $file_base . '.' . $file_ext;

		my $uploadfile = "$path$filename";
		my $upload_filehandle = $query->upload($upload_field_name);
		open(UPLOADFILE,">$uploadfile") or die_nice "couldn't create file '$uploadfile': $!\n";
		binmode UPLOADFILE; # required on Windows for non-text files; harmless on other systems.
		while(<$upload_filehandle>)
		{
			print UPLOADFILE;
		}
		close UPLOADFILE or die_nice "couldn't close file '$uploadfile': $!\n";
		chmod $PREF{writable_file_perms}, $uploadfile;

		enc_redirect("$PREF{login_url}?action=csvimport&csvfile=$filename");
	}
	elsif(my $csvfile = get_qs_var('csvfile'))
	{
		$csvfile = enc_untaint($csvfile); my $csvfile_withpath = $PREF{datadir} =~ m!/$! ? "$PREF{datadir}$csvfile" : "$PREF{datadir}/$csvfile";
		exit_with_error qq`The specified CSV file does not exist.` unless -e $csvfile_withpath;

		my %options = ();
		my @option_controls = ();
		foreach my $opt ('strip_leading_spaces', 'strip_trailing_spaces', 'strip_surrounding_quotes')
		{
			$options{$opt} = get_qs_var($opt) =~ /no/i ? 'no' : 'yes';

			my $opt_nice = $opt; $opt_nice =~ s!_! !g; $opt_nice =~ s!^(\w)!\U$1!;
			push (@option_controls, qq`$opt_nice:&nbsp;<select name="$opt">
				<option value="yes"` . ($options{$opt} eq 'yes' ? qq` selected="selected"` : '') . qq`>yes</option>
				<option value="no"`  . ($options{$opt} eq 'no'  ? qq` selected="selected"` : '') . qq`>no</option>
				</select>
			`);
		}

		my (%data, %fieldnames, @fieldnames) = ();
		open(my $infh, $csvfile_withpath) or die_nice qq`Couldn't open CSV file '$csvfile' for reading: $!\n`;
		flock $infh, 1;
		seek $infh, 0, 0;
		my $linenum = 0;
		while(my $line = <$infh>)
		{
			chomp $line;
			next if $line =~ /^(\s*#|\s*)$/;
			$linenum++;

			# First take care of any lines containing quoted fields (quoted because the field data contains a comma),
			# by replacing the commas with placeholders:
			while($line =~ m!((^|,)"([^"]+)"(,|$))!g)
			{
				my ($wholething, $startboundary, $fieldcontent, $endboundary) = ($1, $2, $3, $4);
				$fieldcontent =~ s!,!THIS_IS_A_REAL_COMMA!g;
				$line =~ s!$wholething!$startboundary$fieldcontent$endboundary!;
			}

			my $fieldnum = 0;
			foreach my $value (split(/,/, $line))
			{
				$value = ($value =~ m!^("+)(.*)\1$!)[1] if $options{strip_surrounding_quotes} =~ /yes/i && $value =~ m!^("+)(.*)\1$!;
				$value =~ s!^\s*!! if $options{strip_leading_spaces} =~ /yes/i;
				$value =~ s!\s*$!! if $options{strip_trailing_spaces} =~ /yes/i;
				$value =~ s!THIS_IS_A_REAL_COMMA!,!g;

				if($linenum == 1)
				{
					$value = lc($value);
					$value =~ s!\W+!_!g;
					defooify('_', $value); # clean up fieldnames regardless of what the user specifies.
					push @fieldnames, $value;
					$fieldnames{$value} = 1;
				}
				else
				{
					$data{$linenum}{ $fieldnames[$fieldnum] } = $value;
				}
				$fieldnum++;
			}
		}
		close $infh or die_nice qq`Couldn't close CSV file '$csvfile' after reading: $!\n`;



		my ($unfield,$pwfield,$rnfield,$emfield,$grfield) = ();

		if($PREF{fixed_username_field_for_CSV_import} && $fieldnames{$PREF{fixed_username_field_for_CSV_import}})	{ $unfield = $PREF{fixed_username_field_for_CSV_import}; }
		else														{ $unfield = get_qs_var("unfield"); }

		if($PREF{fixed_password_field_for_CSV_import} && $fieldnames{$PREF{fixed_password_field_for_CSV_import}})	{ $pwfield = $PREF{fixed_password_field_for_CSV_import}; }
		else														{ $pwfield = get_qs_var("pwfield"); }

		if($PREF{fixed_realname_field_for_CSV_import} && $fieldnames{$PREF{fixed_realname_field_for_CSV_import}})	{ $rnfield = $PREF{fixed_realname_field_for_CSV_import}; }
		else														{ $rnfield = get_qs_var("rnfield"); }

		if($PREF{fixed_email_field_for_CSV_import} && $fieldnames{$PREF{fixed_email_field_for_CSV_import}})		{ $emfield = $PREF{fixed_email_field_for_CSV_import}; }
		else														{ $emfield = get_qs_var("emfield"); }

		if($PREF{fixed_groups_field_for_CSV_import} && $fieldnames{$PREF{fixed_groups_field_for_CSV_import}})		{ $grfield = $PREF{fixed_groups_field_for_CSV_import}; }
		else														{ $grfield = get_qs_var("grfield"); }



		# Make sure the list of field names from the CSV file doesn't contain any
		# new (non-existent) nor built-in fields.  But we make an exception for
		# our default fields (username, password, realname, email, groups), because we
		# aren't going to use whatever fieldnames are in the CSV file for those
		# fields -- we're just going to map them to our built-in field names.
		#
		# Note also that get_sqlsafe_custom_field_values(), which takes %data as
		# an argument here, will automatically skip any built-in or non-existent
		# fields in the input (since it just loops over the actual column names
		# from the live custom fields table), so there's no harm in passing %data
		# into it which contains such fields.
		#
		my (@new_fields,@reserved_fields,@errors) = ();
		foreach my $field (@fieldnames)
		{
			next if $field =~ /^($unfield|$pwfield|$rnfield|$emfield|$grfield)$/;
			push (@new_fields, $field) unless db_column_exists($field, $PREF{user_table});
			push (@reserved_fields, $field) if is_builtin_fieldname($field);
		}



		if($qs =~ /final=yes/)
		{
			exit_with_error(qq`Cannot proceed with import because these fields do not exist: <br /><br />` . join ", ", @new_fields) if @new_fields;
			exit_with_error(qq`Cannot proceed with import because these field names are reserved: <br /><br />` . join ", ", @reserved_fields) if @reserved_fields;

			delete_all_nonadmin_accounts() if get_qs_var('delete_all_nonadmins') eq 'yes';

			my (%successful_imports, %failed_imports, %other_errors) = ();
			foreach my $row (sort { $a <=> $b } keys %data)
			{
				my $user		= $data{$row}{$unfield};
				my $pass		= $data{$row}{$pwfield};
				my $realname		= $data{$row}{$rnfield};
				my $email		= $data{$row}{$emfield};
				my $groups		= $data{$row}{$grfield};

				$user = lc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
				$user = uc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

				my ($crypted_pass, $salt) = create_new_password_hash($pass);

				   if(!realname_is_valid($realname) && $realname)					{ $failed_imports{$row} = $TEXT{messages}{einvldr};	}
				elsif(!emailaddr_is_valid($email) && $email)						{ $failed_imports{$row} = $TEXT{messages}{einvlde};	}
				elsif(!emailaddr_is_valid($user) && $PREF{usernames_must_be_email_addresses} =~ /yes/i)	{ $failed_imports{$row} = $TEXT{messages}{einvlde};	}
				elsif(!password_is_valid($pass))							{ $failed_imports{$row} = $TEXT{messages}{einvldp};	}
				elsif(!hashedpw_is_valid($crypted_pass))						{ $failed_imports{$row} = $TEXT{messages}{einvldh};	}
				elsif(!username_is_valid($user))							{ $failed_imports{$row} = $TEXT{messages}{ebadname};	}
				elsif( username_is_taken($user))							{ $failed_imports{$row} = $TEXT{messages}{edupuser};	}
				elsif( $email && email_address_is_taken($email))					{ $failed_imports{$row} = $TEXT{messages}{edupemail};	}
				foreach my $groupname (split(/:/, $groups))
				{
					if(!groupname_is_valid($groupname))
					{
						$failed_imports{$row} = $TEXT{messages}{einvldg};
						$failed_imports{$row} =~ s!%%group%%!$groupname!g;
					}
					else
					{
						# TODO: add a checkbox during the import process to allow the user to choose whether to auto-create groups.
						add_new_group($groupname) unless group_exists($groupname);
					}
				}

				my ($custfields_error, $customfields_sqlsafe) = get_sqlsafe_custom_field_values(undef, \%{$data{$row}});
				$failed_imports{$row} = $custfields_error if $custfields_error;

				next if $failed_imports{$row};

				my ($pending_email_verification, $pending_admin_approval, $pending_payment, $token) = (0,0,0, '');
				my $new_user_id = add_new_user($user, $crypted_pass, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $token);
				$successful_imports{$user} = 1;

				foreach my $groupname (split(/:/, $groups)) { add_user_to_group($user, $groupname); }

				foreach my $customfield (keys %$customfields_sqlsafe)
				{
					unless($new_user_id =~ /^\d+$/)
					{
						$other_errors{$row} = qq`After creating new account, the returned user ID is not numeric; it is "$new_user_id".`;
						last;
					}
					my $value = $$customfields_sqlsafe{$customfield}{value};
					unless($value eq enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = $new_user_id"))
					{
						my $statement = "UPDATE `$PREF{user_table}` SET `$customfield` = '$value' WHERE `id` = $new_user_id";
						my $success = enc_sql_update($statement);
						$other_errors{$row} = "Error: SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]" unless $success == 1;
					}
				}

				create_filechucker_userdir($new_user_id,$user,$realname,$email);

				send_welcome_email($new_user_id,$user,$pass,$email,$realname,0) if $email && $PREF{send_welcome_email_to_accounts_created_via_csv_import} =~ /yes/i;
				send_welcome_email_to_subadmin($new_user_id,$user,$pass,$email,$realname) if $PREF{send_welcome_email_to_subadmins_when_subusers_are_created_via_csv_import} =~ /yes/i && user_is_part_of_a_subgroup($new_user_id);
			}

			start_html_output();

			print qq`
			<h1 class="pagetitle">Import Users From CSV File</h1>
			<h3>Imported ` . (scalar keys %successful_imports) . qq` account(s) successfully:</h3>
			<p>
			`;

			foreach my $user_imported (sort keys %successful_imports) { print "$user_imported<br />\n"; }

			print "</p>\n";

			if(%failed_imports)
			{
				print qq`<h3>Failed to import these accounts (` . (scalar keys %failed_imports) . qq`):</h3>`;
				print qq`<br />\n<div id="ub_csv_failed_imports" class="enc_tbl">\n<table>\n<tr class="headers">\n<th>Error</th>\n`;
				print qq`<th>$_</th>\n` for @fieldnames;
				print qq`</tr>\n`;
				my $oddeveni = 1;
				foreach my $row (sort { $a <=> $b } keys %failed_imports)
				{
					print qq`<tr class="` . oddeven($oddeveni) . qq`">`;
					print qq`<td>$failed_imports{$row}</td>\n`;
					foreach my $field (@fieldnames) { print qq`<td>$data{$row}{$field}</td>\n`; }
					print qq`</tr>\n`;
				}
				print qq`\n</table>\n</div>\n`;
			}

			if(%other_errors)
			{
				print qq`<h3>These accounts were imported, but errors occurred while processing some of their fields (` . (scalar keys %other_errors) . qq`):</h3>`;
				print qq`<br />\n<div id="ub_csv_other_errors" class="enc_tbl">\n<table>\n<tr class="headers">\n<th>Error</th>\n`;
				print qq`<th>$_</th>\n` for @fieldnames;
				print qq`</tr>\n`;
				my $oddeveni = 1;
				foreach my $row (sort { $a <=> $b } keys %other_errors)
				{
					print qq`<tr class="` . oddeven($oddeveni) . qq`">`;
					print qq`<td>$other_errors{$row}</td>\n`;
					foreach my $field (@fieldnames) { print qq`<td>$data{$row}{$field}</td>\n`; }
					print qq`</tr>\n`;
				}
				print qq`\n</table>\n</div>\n`;
			}

			finish_html_output();
		}
		else
		{
			start_html_output();
			print qq`
			<h1 class="pagetitle">Import Users From CSV File</h1>
			<h3>Step 2: Choose CSV Processing Options</h3>
			<form method="get" name="ub_csv_import_step2" id="ub_csv_import_step2" action="$PREF{login_url}">
			<input type="hidden" name="action" value="csvimport" />
			<input type="hidden" name="csvfile" value="$csvfile" />
			<table>
			<tr><td>
			`;

			print join "<br /><br />\n", @option_controls;
			print "</td>\n<td>\n";


			if($PREF{fixed_username_field_for_CSV_import})
			{
				print qq`Username field: $PREF{fixed_username_field_for_CSV_import} <input type="hidden" name="unfield" value="$unfield" />`;
				unless($fieldnames{$PREF{fixed_username_field_for_CSV_import}})
				{
					print qq` (error: not in CSV file)`;
					push @errors, qq`You've set \$PREF{fixed_username_field_for_CSV_import} to '$PREF{fixed_username_field_for_CSV_import}' but there's no such field in the CSV file.`;
				}
			}
			else
			{
				print qq`Username&nbsp;field:&nbsp;<select name="unfield">\n`;
				print qq`<option></option>\n`;
				print qq`<option` . ($_ eq $unfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
				print qq`</select>`;
			}
			print qq`<br /><br />\n`;


			if($PREF{fixed_password_field_for_CSV_import})
			{
				print qq`Password field: $PREF{fixed_password_field_for_CSV_import} <input type="hidden" name="pwfield" value="$pwfield" />`;
				unless($fieldnames{$PREF{fixed_password_field_for_CSV_import}})
				{
					print qq` (error: not in CSV file)`;
					push @errors, qq`You've set \$PREF{fixed_password_field_for_CSV_import} to '$PREF{fixed_password_field_for_CSV_import}' but there's no such field in the CSV file.`;
				}
			}
			else
			{
				print qq`Password&nbsp;field:&nbsp;<select name="pwfield">\n`;
				print qq`<option></option>\n`;
				print qq`<option` . ($_ eq $pwfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
				print qq`</select>`;
			}
			print qq`<br /><br />\n`;


			if($PREF{use_builtin_realname_field} =~ /yes/i)
			{
				if($PREF{fixed_realname_field_for_CSV_import} && $fieldnames{$PREF{fixed_realname_field_for_CSV_import}})
				{
					print qq`Realname field: $PREF{fixed_realname_field_for_CSV_import} <input type="hidden" name="rnfield" value="$rnfield" />`;
				}
				else
				{
					print qq`Realname&nbsp;field:&nbsp;<select name="rnfield">\n`;
					print qq`<option></option>\n`;
					print qq`<option` . ($_ eq $rnfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
					print qq`</select>`;
				}
				print qq`<br /><br />\n`;
			}


			if($PREF{use_builtin_email_field} =~ /yes/i)
			{
				if($PREF{fixed_email_field_for_CSV_import} && $fieldnames{$PREF{fixed_email_field_for_CSV_import}})
				{
					print qq`Email field: $PREF{fixed_email_field_for_CSV_import} <input type="hidden" name="emfield" value="$emfield" />`;
				}
				else
				{
					print qq`Email&nbsp;field:&nbsp;<select name="emfield">\n`;
					print qq`<option></option>\n`;
					print qq`<option` . ($_ eq $emfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
					print qq`</select>`;
				}
				print qq`<br /><br />\n`;
			}


			if($PREF{fixed_groups_field_for_CSV_import} && $fieldnames{$PREF{fixed_groups_field_for_CSV_import}})
			{
				print qq`Groups field: $PREF{fixed_groups_field_for_CSV_import} <input type="hidden" name="grfield" value="$grfield" />`;
			}
			else
			{
				print qq`Groups&nbsp;field:&nbsp;<select name="grfield">\n`;
				print qq`<option></option>\n`;
				print qq`<option` . ($_ eq $grfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
				print qq`</select>`;
			}
			print qq`<br /><br />\n`;


			print qq`</td></tr>\n`;

			print qq`<tr class="single_item_row"><td colspan="2">Delete all existing non-admin accounts before import: <select name="delete_all_nonadmins">`
				. qq`<option` . (get_qs_var('delete_all_nonadmins') eq 'no'  ? qq` selected="selected"` : '') . qq`>no</option>`
				. qq`<option` . (get_qs_var('delete_all_nonadmins') eq 'yes' ? qq` selected="selected"` : '') . qq`>yes</option>`
				. qq`</select>\n<br /><br />\n</td></tr>\n`;

			print qq`<tr class="submit_button_row"><td colspan="2">
			
			Passwords in your CSV file must be literal, plain-text passwords.<br /><br />
			
			Any groups in your CSV file must be separated by colons; imported accounts<br />
			will be added to the specified groups.<br /><br />
			
			If there are accounts in your CSV file whose usernames or email addresses<br />
			match existing accounts on this site, they will be skipped, not imported.<br /><br />
			
			<input type="submit" value="Set Options" />
			</td></tr>
			`;

			print qq`\n</table>\n</form>\n`;



			if($unfield && $pwfield)
			{

				print qq`
				<br /><hr />
				<h3>Step 3: Proceed With Import</h3>
				<p>When you're satisfied with the data below, you can proceed with the import process.</p>
				<form method="get" name="ub_csv_import_step3" id="ub_csv_import_step3" action="$PREF{login_url}">
				<input type="hidden" name="action" value="csvimport" />
				<input type="hidden" name="final" value="yes" />
				<input type="hidden" name="strip_leading_spaces" value="$options{strip_leading_spaces}" />
				<input type="hidden" name="strip_trailing_spaces" value="$options{strip_trailing_spaces}" />
				<input type="hidden" name="strip_surrounding_quotes" value="$options{strip_surrounding_quotes}" />
				<input type="hidden" name="unfield" value="$unfield" />
				<input type="hidden" name="pwfield" value="$pwfield" />
				<input type="hidden" name="rnfield" value="$rnfield" />
				<input type="hidden" name="emfield" value="$emfield" />
				<input type="hidden" name="grfield" value="$grfield" />
				<input type="hidden" name="delete_all_nonadmins" value="` . get_qs_var('delete_all_nonadmins') . qq`" />
				<input type="hidden" name="csvfile" value="$csvfile" />
				`;



				print qq`Username field: ` . ($unfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; `;
				print qq`Password field: ` . ($pwfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; `;
				print qq`Realname field: ` . ($rnfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; ` if $PREF{use_builtin_realname_field} =~ /yes/i;
				print qq`Email field:    ` . ($emfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; ` if $PREF{use_builtin_email_field} =~ /yes/i;
				print qq`Groups field:   ` . ($grfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; `;



				if(@reserved_fields)
				{
					print qq`<p><strong>Error:</strong> The following field names are reserved, so you
						must rename them in your CSV file and then <a href="$PREF{login_url}?action=csvimport">upload it again</a>: <br /><br />`;
					print join ", ", @reserved_fields;
					print qq`</p>\n`;
				}
				if(@new_fields)
				{
					print qq`<p>The following fields don't exist in the user table, so you need to
						<a href="$PREF{login_url}?action=customfields">create them first</a>,
						before the import can proceed: <br /><br />`;
					print join ", ", @new_fields;
					print qq`</p>\n`;
				}
				if(@errors)
				{
					print qq`<p><strong>Error:</strong> The following errors occurred, so the import cannot proceed:<br /><br />\n`;
					print join ", ", @errors;
					print qq`</p>\n`;
				}


				print qq`<p><strong>WARNING: all existing non-admin accounts will be deleted before import!</strong></p>\n` if get_qs_var('delete_all_nonadmins') eq 'yes';


				if(@reserved_fields || @new_fields || @errors)	{ print qq`<input type="submit" value="Cannot Proceed With Import" disabled="disabled" />`;	}
				else						{ print qq`<br /><br /><input type="submit" value="Proceed With Import" />`;				}


				print qq`
				</form>
				`;





				print qq`<br />\n<div id="ub_csv_preview" class="enc_tbl">\n<table>\n<tr class="headers">\n`;
				print qq`<th>$_</th>\n` for @fieldnames;
				print qq`</tr>\n`;
				my $oddeveni = 1;
				foreach my $row (sort { $a <=> $b } keys %data)
				{
					print qq`<tr class="` . oddeven($oddeveni) . qq`">`;
					foreach my $field (@fieldnames)
					{
						my $value = $data{$row}{$field};
						$value =~ s!:!, !g if $field eq $grfield;
						print qq`<td>$value</td>\n`;
					}
					print qq`</tr>\n`;
				}
				print qq`
				</table>
				</div>
				`;
			}

			finish_html_output();
		}
	}
	else
	{
		start_html_output();

		print qq`

		<h1 class="pagetitle">Import Users From CSV File</h1>
		<h3>Step 1: Upload CSV File</h3>
		<form accept-charset="UTF-8" name="ub_csv_import" id="ub_csv_import" method="post" enctype="multipart/form-data" action="$ENV{SCRIPT_NAME}?action=csvimport">
		Select your CSV file here.&nbsp; You can <a href="$PREF{login_url_qsready}action=csvexport">do a test export</a> first, if you<br />
		want to see an example of what the CSV file should contain.<br /><br />
		<input type="file" name="ub_csv_filename" id="ub_csv_filename" /><br /><br />
		(No data will be imported during this step; there are 2 more steps to go.)<br /><br />
		<input type="submit" name="ub_csv_submit" id="ub_csv_submit" value="Upload CSV File" />
		</form>

		`;

		finish_html_output();
	}
}


sub delete_all_nonadmin_accounts()
{
	exit_with_needprivs() unless user_is_allowed_to('delete_user_accounts');
	my $allaccounts = enc_sql_select_multi("SELECT * FROM `$PREF{user_table}`");
	foreach my $j (keys %$allaccounts)
	{
		unless(is_admin_acct($$allaccounts{$j}{id}))
		{
			#print STDERR "delete_all_nonadmin_accounts: deleting user $$allaccounts{$j}{username} (id=$$allaccounts{$j}{id})\n";
			enc_sql_delete("DELETE FROM `$PREF{user_table}` WHERE `id` = $$allaccounts{$j}{id} LIMIT 1");
		}
	}
}


sub print_user_form
{
	my $mode = shift;
	my %vars = ();

	if($mode eq 'added_by_admin')
	{
		$PREF{on_page}			= 'adminadduser';
		$vars{title}			= logged_in_user_is_subgroup_manager() ? $PREF{user_form_title___subadmin_adding_user} : $PREF{user_form_title___admin_adding_user};

		if(!user_has_addmember_rights()) { exit_with_error($TEXT{Access_denied_}); }
	
		$vars{target}			= 'action=commitadduser';
		$vars{forcepwchng}		= 1 if $PREF{enable_forced_password_change} =~ /yes/i;
	}
	elsif($mode eq 'user_signup')
	{
		$PREF{on_page}			= 'usersignup';
		$vars{title}			= $PREF{user_form_title___user_signing_up};

		unless($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i) { exit_with_error($TEXT{This_feature_is_disabled_}); }
		if($PREF{member_is_logged_in}) { exit_with_error($TEXT{Cant_sign_up_already_have_account_}); }

		$vars{target}			= 'action=commitadduser';
		$vars{forcepwchng}		= 0;
	}
	else # edit the user info instead.
	{
		exit_with_needlogin() unless $PREF{member_is_logged_in};

		$PREF{on_page} = 'edituser';
		$vars{title}			= $PREF{user_form_title___editing_account};

		$vars{user_id}			= $qs =~ /(?:^|&)id=(\d+)(?:&|$)/ ? $1 : $PREF{logged_in_userid};
		die_unless_numeric($vars{user_id}, 'userid (from print_user_form())');

		$vars{username}			= get_user_name($vars{user_id});

		if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $vars{username})) { exit_with_error($TEXT{Access_denied_}); }

		$vars{target}			= "action=commitedituser";

		$vars{username_readonly}	= $PREF{usernames_are_immutable_once_created} =~ /no/i && user_is_allowed_to($PREF{logged_in_userid}, 'change_usernames', $vars{username}) ? '' : qq`readonly="readonly"`;

		$vars{realname}			= get_real_name($vars{user_id});
		$vars{email}			= get_email_address($vars{user_id});

		$vars{account_locked}		= enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';");
		$vars{account_disabled}		= enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';");
		$vars{forcepwchng}		= enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';") if $PREF{enable_forced_password_change} =~ /yes/i;
	}

	if($qs =~ /redo=true/)
	{
		while($qs =~ /(?:^|&)redo_(\w+)=([^&]*)/g)
		{
			my ($field,$value) = ($1,$2);
			enc_urldecode($value);
			$vars{$field} = $value if $value;
		}
	}

	start_html_output($vars{title});

	if($qs =~ /(?:^|&)phase=(\w+?)(?:&|$)/) { my $phase = $1; print qq`<div id="formmessage">` . get_message($phase) . qq`</div>\n`; }


	my $show_password_fields = user_is_allowed_to('edit_password_field') || $mode eq 'user_signup';


	my $outer_template = $PREF{user_form_template};
	$outer_template =~ s!%%post_url%%!$ENV{SCRIPT_NAME}?$vars{target}!g;
	$outer_template =~ s!%%hidden_signup_input%%!$mode eq 'user_signup' ? qq`<input type="hidden" name="user_signup" value="yes" />` : ''!eg;
	$outer_template =~ s!%%loggedin_user_details%%!$PREF{admin_is_logged_in} ? 'admin' : logged_in_user_is_subgroup_manager() ? 'subadmin' : $PREF{member_is_logged_in} ? 'member' : 'guest'!eg;
	$outer_template =~ s!%%%if-forcepwchng%%%(.*?)%%%end-forcepwchng%%%!$PREF{member_is_logged_in} && force_pw_change($PREF{logged_in_userid}) ? $1 : ''!egs;
	my @user_form_field_sections = ();
	my $submit_button = '';
	my $custom_js_code = '';

	my $sections = enc_sql_select_multi("SELECT * FROM `$PREF{field_sections_table}` ORDER BY `section_position`");

	# If there are no sections defined, or just one, then we'll display everything in a single section.
	#%$sections = ();
	my $just_one_section = 0;
	my $num_sections_used = 0;
	#
	#if(!%$sections || !$$sections{1}{id} || (enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`") == 1))
	#
	if(!%$sections)
	{
		$just_one_section = 1;
		%$sections = ();
		$$sections{1}{id} = enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}`") || 1; # there's only one id (or none) to return.
	}

	# Create a dummy section at the end for the submit button:
	my $submit_button_code = '';
	unless($just_one_section)
	{
		my ($last_section,$last_position) = ();
		foreach my $j (sort { $a <=> $b } keys %$sections)
		{
			$last_section = $j;
			$last_position = $$sections{$j}{section_position};
		}
		$$sections{$last_section + 1}{this_is_the_final_pass}	= 1;
		$$sections{$last_section + 1}{section_position}		= $last_position + 1;
		$$sections{$last_section + 1}{name}			= $TEXT{userform_submitbutton_section_name} || 'submitbutton';
		$$sections{$last_section + 1}{label}			= $TEXT{userform_submitbutton_section_label} || 'Submit';
	}

	foreach my $j (sort { $$sections{$a}{section_position} <=> $$sections{$b}{section_position} } keys %$sections)
	{
		my $section_id = $$sections{$j}{id};

		my $template			= $PREF{user_form_fields_template};
		my $section_header_template	= $PREF{user_form_section_header_template};

		my $grouplist = '';
		my $grouplist_template = $PREF{user_form___grouplist};
		my ($grouplist_template_inner) = ($grouplist_template =~ m!%%%template:grouplist%%%(.+?)%%%end-template:grouplist%%%!gs);
		my $groups = get_groups_hash($vars{user_id});
		foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
		{
			next unless user_is_allowed_to('see_groups_on_user_form') || ($mode eq 'user_signup');   # In signup mode, we want each group's show_on_signup_page DB setting prevail; we don't want the admin to need to adjust a groups_allowed_to_* setting too.
			next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
			next if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i); # don't show these (not even disabled); it just confuses people.
			next if $group eq $PREF{expired_group_name} && !$PREF{admin_is_logged_in};

			my $checked = $$groups{$group}{is_member} ? qq`checked="checked"` : undef;

			my $user_allowed_to_see_all_groups = user_is_allowed_to('see_full_grouplist_on_user_form');
			my $user_belongs_to_this_group = $$groups{$group}{is_member};
			die_unless_numeric($$groups{$group}{id}, 'group ID ($$groups{$group}{id})');
			my ($this_group_always_shown_on_signup,$custom_group_label,$grouptype,$groupprice,$length_in_hours) = enc_sql_select("SELECT `show_on_signup_page`,`label_for_signup_page`,`type`,`price`,`length_in_hours` FROM `$PREF{group_table}` WHERE `id` = $$groups{$group}{id};");

			# Also get length_in_days, for any old installations that still have and use that old field:
			my $length_in_days = db_column_exists('length_in_days', $PREF{group_table}) ? enc_sql_select("SELECT `length_in_days` FROM `$PREF{group_table}` WHERE `id` = $$groups{$group}{id};") : 0;
			$length_in_hours = $length_in_days * 24 if $length_in_days && !$length_in_hours;

			my $standard_group_label = $groupprice > 0 ? "$group - $PREF{paid_group_currency_symbol}$groupprice" . get_paid_group_price_label($grouptype, $length_in_hours) : $group;

			my $disabled = user_is_allowed_to('change_group_memberships') || ($mode eq 'user_signup' && $this_group_always_shown_on_signup) ? '' : 'disabled="disabled"';

			# By default, admins can see all groups here, but non-admins can only see the groups they belong to.
			if($user_allowed_to_see_all_groups || $user_belongs_to_this_group || $this_group_always_shown_on_signup)
			{
				my $gl_template = $grouplist_template_inner;
				$gl_template =~ s!%%group%%!$group!gs;
				$gl_template =~ s!%%group_label%%!$mode eq 'user_signup' && $this_group_always_shown_on_signup && $custom_group_label ? $custom_group_label : $standard_group_label!egs;
				$gl_template =~ s!%%checked%%!$checked!gs;
				$gl_template =~ s!%%disabled%%!$disabled!gs;
				$gl_template =~ s!%%paidgroupcheckbox%%!$$groups{$group}{is_paidgroup} ? 'ub_paidgroup_checkbox' : ''!egs;
				$grouplist .= $gl_template;
			}
		}
		$grouplist_template =~ s!%%%template:grouplist%%%(.+?)%%%end-template:grouplist%%%!$grouplist!gs;
		$template =~ s!%%grouplist%%!$grouplist ? $grouplist_template : ''!egs;


		my $customfields = '';
		my ($customfields_template) = ($template =~ m!%%%template:customfields%%%(.+?)%%%end-template:customfields%%%!gs);
		if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
		{
			my $fields = enc_sql_select_multi("SELECT * FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
			foreach my $j (sort { $a <=> $b } keys %$fields)
			{
				next unless ($$fields{$j}{enabled} && db_column_exists($$fields{$j}{fieldname}, $PREF{user_table}));
				next unless ($section_id eq $$fields{$j}{section}) || $just_one_section;

				my $this_field_readonly = 0;
				if($mode eq 'user_signup')
				{
					next unless $$fields{$j}{show_on_signup_page};
				}
				else
				{
					next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_view});
					$this_field_readonly = 1 if !logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_edit});
				}

				my $value = '';
				if($mode eq 'edit')
				{
					$value = enc_sql_select("SELECT `$$fields{$j}{fieldname}` FROM `$PREF{user_table}` WHERE `id` = $vars{user_id}") if $vars{user_id};
				}
				else
				{
					$value = $$fields{$j}{defaultvalue};
					do_standard_template_vars_processing('include_undefined', $value);
				}

				my $required = $$fields{$j}{mandatory} ? 'required' : '';
				$required = '' if user_is_allowed_to('leave_mandatory_custom_fields_blank');


				$$fields{$j}{fieldmax} = '' unless $$fields{$j}{datatype} eq 'varchar'; # workaround for SQL bug where '' gets stored as '0'.

				my $cf_template = $customfields_template;
				my @css_ids = ();

				$cf_template =~ s!%%fieldname%%!$$fields{$j}{fieldname}!gs;
				$cf_template =~ s!%%fieldlabel%%!$$fields{$j}{fieldlabel}!gs;
				$cf_template =~ s!%%fieldmax%%!$$fields{$j}{fieldmax}!gs;
				$cf_template =~ s!%%required%%!$required!gs;
				$cf_template =~ s!%%value%%!$value!gs;

				$cf_template =~ s!%%%if-freeformsingle%%%(.*?)%%%end-freeformsingle%%%!$$fields{$j}{fieldtype} eq 'freeformsingle' ? $1 : ''!egs;
				$cf_template =~ s!%%%if-freeformmulti%%%(.*?)%%%end-freeformmulti%%%!$$fields{$j}{fieldtype} eq 'freeformmulti' ? $1 : ''!egs;
				$cf_template =~ s!%%%if-dropdown%%%(.*?)%%%end-dropdown%%%!$$fields{$j}{fieldtype} eq 'dropdown' ? $1 : ''!egs;
				$cf_template =~ s!%%%if-checkbox%%%(.*?)%%%end-checkbox%%%!$$fields{$j}{fieldtype} eq 'checkbox' ? $1 : ''!egs;
				$cf_template =~ s!%%%if-radio%%%(.*?)%%%end-radio%%%!$$fields{$j}{fieldtype} eq 'radio' ? $1 : ''!egs;
				#$cf_template =~ s!%%%ifelse-readonly%%%(.*?)%%%else%%%(.*?)%%%endelse-readonly%%%!$custom_fields_readonly || $this_field_readonly ? $1 : $2!egs;
				 $cf_template =~ s!%%%ifelse-readonly%%%(.*?)%%%else%%%(.*?)%%%endelse-readonly%%%!$this_field_readonly ? $1 : $2!egs;
				$cf_template =~ s!%%%if-mandatory%%%(.*?)%%%end-mandatory%%%!$required ? $1 : ''!egs;




				my $dropdown = '';
				my $radio = '';
				if($$fields{$j}{fieldtype} eq 'freeformsingle')
				{
					my $css_id = "cust_field_" . $$fields{$j}{fieldname};
					push @css_ids, $css_id;
					$cf_template =~ s!%%css_id%%!$css_id!gs;
				}
				elsif($$fields{$j}{fieldtype} eq 'freeformmulti')
				{
					my $css_id = "cust_field_" . $$fields{$j}{fieldname};
					push @css_ids, $css_id;
					$cf_template =~ s!%%css_id%%!$css_id!gs;
				}
				elsif($$fields{$j}{fieldtype} eq 'checkbox')
				{
					my $css_id = "cust_field_" . $$fields{$j}{fieldname};
					push @css_ids, $css_id;
					$cf_template =~ s!%%css_id%%!$css_id!gs;

					$cf_template =~ s!%%checkbox_checked%%!$value ? 'checked="checked"' : ''!egs;
				}
				elsif($$fields{$j}{fieldtype} eq 'dropdown')
				{
					my $css_id = "cust_field_" . $$fields{$j}{fieldname};
					push @css_ids, $css_id;
					$cf_template =~ s!%%css_id%%!$css_id!gs;

					my ($dropdown_template) = ($cf_template =~ m!%%%template:dropdown%%%(.+?)%%%end-template:dropdown%%%!gs);
					foreach my $item (split(/\n/, $$fields{$j}{listitems}))
					{
						my $dd_template = $dropdown_template;
						my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
						my $selected = $submitted_value eq $value ? qq`selected="selected"` : '';
						$dd_template =~ s!%%dropdown_selected%%!$selected!gs;
						$dd_template =~ s!%%submitted_value%%!$submitted_value!gs;
						$dd_template =~ s!%%displayed_value%%!$displayed_value!gs;
						$dropdown .= $dd_template;
					}
				}
				elsif($$fields{$j}{fieldtype} eq 'radio')
				{
					my $radio_i = 0;
					my ($radio_template) = ($cf_template =~ m!%%%template:radio%%%(.+?)%%%end-template:radio%%%!gs);
					foreach my $item (split(/\n/, $$fields{$j}{listitems}))
					{
						$radio_i++;
						my $rad_template = $radio_template;
						my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
						my $checked = $submitted_value eq $value ? qq`checked="checked"` : '';
						my $css_id = 'cust_field_' . $$fields{$j}{fieldname} . '_' . $radio_i;
						push @css_ids, $css_id;
						$rad_template =~ s!%%radio_checked%%!$checked!gs;
						$rad_template =~ s!%%submitted_value%%!$submitted_value!gs;
						$rad_template =~ s!%%displayed_value%%!$displayed_value!gs;
						$rad_template =~ s!%%radio_i%%!$radio_i!gs;
						$rad_template =~ s!%%css_id%%!$css_id!gs;
						$radio .= $rad_template;
					}
				}
				$cf_template =~ s!%%%template:dropdown%%%(.+?)%%%end-template:dropdown%%%!$dropdown!gs;
				$cf_template =~ s!%%%template:radio%%%(.+?)%%%end-template:radio%%%!$radio!gs;


				$custom_js_code .= get_js_code_for_perfield_actions($j, $$fields{$j}{field_actions}, $$fields{$j}{fieldtype}, @css_ids) if $$fields{$j}{field_actions};


				$customfields .= $cf_template;
			}
		}
		$template =~ s!%%%template:customfields%%%(.+?)%%%end-template:customfields%%%!$customfields!gs;


		my $section_header_text		= $$sections{$j}{label} ?	$$sections{$j}{label}
						: $mode eq 'user_signup' ?	$TEXT{user_form_section_header___signup}
						: $mode eq 'added_by_admin' ?	$TEXT{user_form_section_header___adminadd}
						: $mode eq 'edit' ?		$TEXT{user_form_section_header___edit}
						: '';

		my $show_builtin_fields		= $section_id eq $PREF{show_builtin_fields_in_this_section_id};
		my $show_submit_button		= $just_one_section || $$sections{$j}{this_is_the_final_pass};
		my $show_customfields		= $customfields;
		my $no_output_in_this_section	= !($show_builtin_fields || $show_submit_button || $show_customfields);

		if($no_output_in_this_section)
		{
			encdebug qq`no output in this section; skipping...`;
		}
		else
		{
			$template =~ s!%%emailformat%%!$PREF{usernames_must_be_email_addresses} =~ /yes/i ? 'emailformat' : ''!eg;
			if($mode eq 'user_signup')
			{
				$template =~ s!%%email_field_required%%!$PREF{email_field_required_during_signup} =~ /yes/i ? 'required emailformat' : 'emailformat'!eg;
			}
			else
			{
				$template =~ s!%%email_field_required%%!$PREF{email_field_required_for_loggedin_users} =~ /yes/i ? 'required emailformat' : 'emailformat'!eg;
			}
			$template =~ s!%%new_password_required%%!$mode =~ /added_by_admin|user_signup/ ? 'required' : ''!eg;
			$template =~ s!%%account_locked_checked%%!$vars{account_locked} ? 'checked="checked"' : ''!eg;
			$template =~ s!%%account_disabled_checked%%!$vars{account_disabled} ? 'checked="checked"' : ''!eg;
			$template =~ s/%%forcepwchng_checked%%/$vars{forcepwchng} && $PREF{member_is_logged_in} && !force_pw_change($PREF{logged_in_userid}) ? 'checked="checked"' : ''/eg; # if the user is in the middle of being forced to change his password (i.e. force_pw_change() is true), then uncheck it, so he doesn't inadvertently get stuck in a loop.
			$template =~ s!%%loginreturn%%!get_qs_var('loginreturn')!eg;
			$template =~ s!%%section_css_id%%!'section_' . ($$sections{$j}{name} || $j)!eg;

			$template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
			$template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
			$template =~ s!%%%if-currentpass_needed%%%(.*?)%%%end-currentpass_needed%%%!$mode eq 'edit'   &&   logged_in_user_must_enter_current_password_to_change_password_for_user($vars{user_id}) ? $1 : ''!egs;
			$template =~ s!%%%if-show_password_fields%%%(.*?)%%%end-show_password_fields%%%!$show_password_fields ? $1 : ''!egs;
			$template =~ s!%%%if-show_account_locks%%%(.*?)%%%end-show_account_locks%%%!$mode eq 'edit'   &&   user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks') ? $1 : ''!egs;
			$template =~ s!%%%ifelse-lock_expires_automatically%%%(.*?)%%%else%%%(.*?)%%%endelse-lock_expires_automatically%%%!my ($var1,$var2)=($1,$2); $PREF{lock_expires_automatically} =~ /yes/i ? $var1 : $var2!egs;
			$template =~ s!%%%if-lock_expires_automatically%%%(.*?)%%%end-lock_expires_automatically%%%!my $var = $1; $PREF{lock_expires_automatically} =~ /yes/i ? $var : ''!egs;
			$template =~ s!%%%if-show_force_pwchng%%%(.*?)%%%end-show_force_pwchng%%%!my $var = $1; user_is_allowed_to($PREF{logged_in_userid}, 'force_password_changes')   &&   $PREF{enable_forced_password_change} =~ /yes/i ? $var : ''!egs;
			$template =~ s!%%terms_of_service%%!$mode eq 'user_signup' && $PREF{user_must_agree_to_terms_on_signup} =~ /yes/i ? $PREF{user_form___terms_of_service} : ''!egs;
			$template =~ s!%%grouplist%%!$grouplist!gs;
			$template =~ s!%%%if-show_builtin_fields%%%(.*?)%%%end-show_builtin_fields%%%!$show_builtin_fields ? $1 : ''!egs;
			$template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$show_customfields ? $1 : ''!egs;

			$template =~ s!%%user_form_section_header%%!$section_header_template!g;
			$template =~ s!%%user_form_section_header_text%%!$section_header_text!g;
			#$template =~ s!%%%if-show_submit_button%%%(.*?)%%%end-show_submit_button%%%!$show_submit_button ? $1 : ''!egs;
			$template =~ s/%%%if-show_submit_button%%%(.*?)%%%end-show_submit_button%%%/$show_submit_button ? qq`<!-- submit_button_start -->\n$1\n<!-- submit_button_end -->` : '<!-- submit_button_unused_location -->'/egs;

			$template =~ s!%%%if-enable_human_test%%%(.*?)%%%end-enable_human_test%%%!$PREF{enable_human_test} eq 'yes' ? $1 : ''!egs;
			$template =~ s!%%%if-human_test_is_invisible%%%(.*?)%%%end-human_test_is_invisible%%%!$PREF{human_test_is_invisible} eq 'yes' ? $1 : ''!egs;
			$template =~ s!%%%ifelse-human_test_is_invisible%%%(.*?)%%%else%%%(.*?)%%%endelse-human_test_is_invisible%%%!$PREF{human_test_is_invisible} eq 'yes' ? $1 : $2!egs;
			$template =~ s!%%human_test_form%%!get_human_test_form()!eg;
			$template =~ s!%%human_test_hash%%!$PREF{humantest_hash} ? qq`<input type="hidden" name="encht3" id="encht3" value="$PREF{humantest_hash}" />` : undef!eg;
			$template =~ s!%%human_test_code%%!$PREF{humantest_code} ? qq`<input type="hidden" name="encht4" id="encht4" value="$PREF{humantest_code}" />` : undef!eg;

			$template =~ s!%%%if-user_signing_up%%%(.*?)%%%end-user_signing_up%%%!$mode eq 'user_signup' ? $1 : ''!egs;
			$template =~ s!%%%if-admin_adding_user%%%(.*?)%%%end-admin_adding_user%%%!$mode eq 'added_by_admin' ? $1 : ''!egs;
			$template =~ s!%%%ifelse-editing_account%%%(.*?)%%%else%%%(.*?)%%%endelse-editing_account%%%!$mode eq 'edit' ? $1 : $2!egs;
			$template =~ s!%%%if-editing_account%%%(.*?)%%%end-editing_account%%%!$mode eq 'edit' ? $1 : ''!egs;

			$template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

			$template =~ s!%%(\w+)%%!$vars{$1}!g;
			$template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;
			
			if($template =~ s/<!-- submit_button_start -->(.*)<!-- submit_button_end -->/<!-- submit_button_placeholder -->/s)
			{
				$submit_button_code = $1;
			}

			push @user_form_field_sections, $template;
			$num_sections_used++;
			#encdebug qq`num_sections_used=$num_sections_used; template=$template`;
		}
	}

	# All this $submit_button_code nonsense is necessary because of the way we're creating and populating
	# output sections as we go, but in a way that results in a separate final section for just the submit
	# button, even when that second is the 2nd of 2 and contains nothing *but* the submit button, in which
	# case we'd rather just have a single section with the submit button included at the bottom of the
	# fields in that section.
	#
	if($num_sections_used == 2)
	{
		delete $user_form_field_sections[1];
		$user_form_field_sections[0] =~ s/<!-- submit_button_unused_location -->/$submit_button_code/gs;
	}
	else
	{
		s/<!-- submit_button_placeholder -->/$submit_button_code/gs for @user_form_field_sections;
	}

	$outer_template =~ s!%%user_form_field_sections%%!join '', @user_form_field_sections!eg;
	print $outer_template;

	print qq`\n\n\n\n<script type="text/javascript">\n$custom_js_code\n</script>\n\n\n\n` if $custom_js_code;

	finish_html_output();
}


sub get_js_code_for_perfield_actions
{
	my ($field_i, $code, $fieldtype, @css_ids) = @_;
	sql_un_untaint($code);
	my $js_code = '';
	my $action_i = 1;
	foreach my $action (split(/\n\n/, $code))
	{
		if($action =~ m!(onclick|onchange|onfocus|onblur): (show|hide) (\w+) if ([\w-]+) (.+)!)
		{
			my ($trigger, $action, $target_element, $source_element, $test) = ($1, $2, $3, $4, $5);
			@css_ids = ($source_element) if $source_element ne 'self';

			my $source_i = 1;
			foreach $source_element (@css_ids)
			{
				my $extra_onload_test = '';
				if($fieldtype eq 'radio')
				{
					# For radio buttons, when this code runs at onload time, it runs for every
					# radio button in a group, rather than just for the selected one as happens
					# when one is clicked.  This causes incorrect behavior (specifically, it will
					# run any show or hide actions based on the values of *every* radio button, 
					# but it should only test the selected radio button) so we need to restrict
					# that onload execution to only occur on the selected radio button.
					#
					$extra_onload_test = qq` && (gebi("$source_element").checked)`;
				}

				my $regular_test = qq`if(gebi("$source_element").value $test)`;
				my $regular_action = qq`${action}_element("$target_element");`;

				# Also execute the same code once at onload, so that when editing an existing account
				# where fields already have values at onload, the custom rules take effect right away.
				#
				my $onload_test = qq`if(gebi("$source_element").value $test$extra_onload_test)`;
				my $onload_action = qq`${action}_element("$target_element");`;

				if($test =~ /^custcode: (.+)/)
				{
					my $custcode = $1;
					$regular_test = $custcode;
					$onload_test = $custcode . $extra_onload_test;
				}

				$js_code .= qq`

					function fields_custom_code_${field_i}_${action_i}_${source_i}()
					{
						var source_el = gebi("$source_element");
						var target_el = gebi("$target_element");
						if(source_el && target_el)
						{
							schedule_${trigger}_action(source_el, function()
							{
								$regular_test
									$regular_action
							});

							$onload_test
								$onload_action
						}
					}
					schedule_onload_action(fields_custom_code_${field_i}_${action_i}_${source_i});

				`;

				$source_i++;
			}
		}
		$action_i++;
	}
	return $js_code;
}


sub logged_in_user_must_enter_current_password_to_change_password_for_user($)
{
	my $userid_of_target_user = shift;

	#
	#my $username_of_target_user = shift;
	#if(this_user_is_the_logged_in_admin($username_of_target_user))
	#{
	#	# an admin is trying to change his own password, so
	#	# we DO require the current password.
	#	return 1;
	#}
	#
	# Admin or not, if the account being updated is the logged-in user's account,
	# then he must enter the current password to change the password:
	#
	if($userid_of_target_user == $PREF{logged_in_userid})
	{
		# A user is changing his own password, so the current password is required.
		return 1;
	}
	elsif(logged_in_user_is_subgroup_manager()   &&   logged_in_subgroup_manager_owns_this_user($userid_of_target_user))
	{
		# a subgroup manager is trying to change the password of one of his
		# own users; he's effectively an admin for this purpose, so we DON'T
		# require the current password.
		return 0;
	}
	elsif(user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $userid_of_target_user))
	{
		# in general, a user with 'edit_user_info' rights does NOT need
		# the current password to change a password.
		return 0;
	}
	else
	{
		# in general, a user without 'edit_user_info' rights DOES need
		# the current password to change a password.
		return 1;
	}
}


sub process_new_account()
{
	if($PREF{enable_human_test} =~ /yes/i)
	{
		my $passed_test = do_human_test(enc_param("encht1"), enc_param("encht2"));
		die_nice($TEXT{Error__failed_human_test__please_try_again_}) unless $passed_test;
	}

	my $go			= "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
	my $signup		= enc_param('user_signup') =~ /yes/i;
	my $orig_qs		= enc_param('qstr') if $signup; $orig_qs =~ s!action=signup&!!g;   # this is for passing through to the post-signup page, so we don't want to loop back to signup.

	my $user		= my $user_redo		= enc_param('username');	enc_urlencode($user_redo);
	my $realname		= my $realname_redo	= enc_param('realname');	enc_urlencode($realname_redo);
	my $pass		= enc_param('pw1'); # don't redo/refill the password because we don't want to pass that on the URL.
	my $email		= my $email_redo	= enc_param('email');	enc_urlencode($email_redo); $user =~ s/^(.{2}.{2}).*/$1/; $pass =~ s/^(.{2}.{2}).*/$1/;

	$user = lc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
	$user = uc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

	my ($crypted_pass, $salt) = create_new_password_hash($pass);

	$PREF{prev_page} = $signup ? 'signup' : 'adduser';

	my $redo = "$PREF{login_url}?action=$PREF{prev_page}&redo=true";
	$redo .= "&redo_username=$user_redo&redo_realname=$realname_redo&redo_email=$email_redo";
	$redo .= ("&loginreturn=" . enc_param('loginreturn')) if enc_param('loginreturn');
	$redo .= ("&autogroup=" . enc_param('autogroup')) if enc_param('autogroup');

	   if(!user_has_addmember_rights() && !$signup)						{ enc_redirect("$redo&phase=eneedlogin");	}
	elsif($PREF{visitors_can_sign_up_for_their_own_accounts} !~ /yes/i && $signup)		{ enc_redirect("$redo&phase=enosignup");	}
	elsif(!realname_is_valid($realname) && $realname)					{ enc_redirect("$redo&phase=einvldr");		}
	elsif(!emailaddr_is_valid($email) && $email)						{ enc_redirect("$redo&phase=einvlde");		}
	elsif(!emailaddr_is_valid($user) && $PREF{usernames_must_be_email_addresses} =~ /yes/i)	{ enc_redirect("$redo&phase=einvlde");		}
	elsif(!password_is_valid($pass))							{ enc_redirect("$redo&phase=einvldp");		}
	elsif(!hashedpw_is_valid($crypted_pass))						{ enc_redirect("$redo&phase=einvldh");		}
	elsif(!username_is_valid($user))							{ enc_redirect("$redo&phase=ebadname");		}
	elsif( username_is_taken($user))							{ enc_redirect("$redo&phase=edupuser");		}
	elsif( $email && email_address_is_taken($email))					{ enc_redirect("$redo&phase=edupemail");	}
	elsif( enc_param('group-admin') =~ /on/i   &&   !user_has_addadmin_rights())		{ enc_redirect("$redo&phase=einsuff");		}
	elsif( enc_param('pw1') ne enc_param('pw2'))						{ enc_redirect("$redo&phase=epwmismatch");	}
	
	my $query = new CGI;
	my %params = $query->Vars; check_input_data(\%params);

	my $pending_payment = '';
	foreach my $param (sort keys %params)
	{
		if($param =~ /^group-(.+)$/) {   my $groupname = $1; $pending_payment .= get_group_id($groupname).'.' if $signup && is_paid_group($groupname);   }
	}

	# Do any forced-group-memberships for paid groups:
	#
	my $allgroups = enc_sql_select_multi("SELECT * FROM $PREF{group_table} WHERE `active` = TRUE");
	foreach my $k (keys %$allgroups)
	{
		my $gid = $$allgroups{$k}{id};
		my $pp_matches = $pending_payment !~ /(^|\.)$gid(\.|$)/;
		if($$allgroups{$k}{price} > 0 && $pending_payment !~ /(^|\.)$gid(\.|$)/)
		{
			if($signup)
			{
				$pending_payment .= $gid.'.' if $$allgroups{$k}{force_new_signups_to_join};
			}
			if(logged_in_user_is_subgroup_manager())
			{
				$pending_payment .= $gid.'.' if $$allgroups{$k}{force_new_subadmincreated_accounts_to_join};
			}
			if(user_is_allowed_to('create_user_accounts'))
			{
				$pending_payment .= $gid.'.' if $$allgroups{$k}{force_new_admincreated_accounts_to_join};
			}
		}
	}

	my $customfields_sqlsafe = get_sqlsafe_custom_field_values($signup);

	my $pending_email_verification	= $signup && $PREF{require_email_verification_for_new_signups} =~ /yes/i ? 1 : 0;
	my $pending_admin_approval	= $signup && $PREF{require_admin_approval_for_new_signups} =~ /yes/i ? 1 : 0;

	my $token = ($pending_email_verification || $pending_admin_approval) ? generate_nonce($email . $realname . $user . $pass . $salt) : '';
	my $new_user_id = add_new_user($user, $crypted_pass, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $token);

	foreach my $param (sort keys %params)
	{
		if($param =~ /^group-(.+)$/)
		{
			my $group = $1;
			next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
			next if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i); # every account is automatically a member of these groups.
			next if $signup && is_paid_group($group);   # don't actually add them to their requested paid groups at this stage.

			my $group_id = get_group_id($group);
			die_unless_numeric($group_id, '$group_id');
			my $user_belongs_to_this_group = user_is_member_of_group($PREF{logged_in_userid}, $group);
			my $user_has_groupmod_rights = user_is_allowed_to($PREF{logged_in_userid}, 'change_group_memberships');
			my ($this_group_always_shown_on_signup) = enc_sql_select("SELECT `show_on_signup_page` FROM `$PREF{group_table}` WHERE `id` = $group_id;");

			if($user_has_groupmod_rights || $user_belongs_to_this_group || ($signup && $this_group_always_shown_on_signup))
			{
				add_user_to_group($user, $group) if $params{$param} =~ /on/i;
			}
		}
	}

	# Do any forced-group-memberships for non-paid groups:
	#
	foreach my $k (keys %$allgroups)
	{
		if(!($$allgroups{$k}{price} > 0))
		{
			if($signup)
			{
				add_user_to_group($user, $$allgroups{$k}{group}) if $$allgroups{$k}{force_new_signups_to_join};
			}
			if(logged_in_user_is_subgroup_manager())
			{
				add_user_to_group($user, $$allgroups{$k}{group}) if $$allgroups{$k}{force_new_subadmincreated_accounts_to_join};
			}
			if(user_is_allowed_to('create_user_accounts'))
			{
				add_user_to_group($user, $$allgroups{$k}{group}) if $$allgroups{$k}{force_new_admincreated_accounts_to_join};
			}
		}
	}


	# When a subgroup manager creates an account, it's automatically
	# put into a special group based on the manager's username.
	#
	if(logged_in_user_is_subgroup_manager())
	{
		my $groupname = "$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}";
		add_new_group($groupname, "Group managed by $PREF{logged_in_username}") unless group_exists($groupname);
		add_user_to_group($user, $groupname);
		
		if($PREF{subgroup_owned_users_get_group_memberships_from_their_manager} =~ /yes/i)
		{
			my $allgroups = get_groups_hash($PREF{logged_in_userid});
			foreach my $group (sort keys %$allgroups)
			{
				next if is_builtin_group($group);
				if(my $logged_in_subadmin_belongs_to_this_group = $$allgroups{$group}{is_member})
				{
					next if $PREF{groups_that_can_manage_subgroup_users} =~ /(^|,)\s*$group\s*(,|$)/;
					add_user_to_group($user, $group);
				}
			}
		}
	}

	my $payment_url = '';
	if($pending_payment)
	{
		$payment_url = "$PREF{login_url}?action=joinpaidgroup&gid=$pending_payment&uid=$new_user_id";
		if($orig_qs && $PREF{preserve_URL_variables_through_signup_process} =~ /yes/i) { $payment_url .= "&$orig_qs"; }
	}

	my $table = $PREF{user_table};

	foreach my $customfield (keys %$customfields_sqlsafe)
	{
		if($signup)
		{
			next unless $$customfields_sqlsafe{$customfield}{show_on_signup_page};
		}
		else
		{
			next unless logged_in_user_belongs_to_one_of_these_group_ids($$customfields_sqlsafe{$customfield}{groups_allowed_to_edit});
		}

		die_unless_numeric($new_user_id, "userid");
		my $value = $$customfields_sqlsafe{$customfield}{value};
		unless($value eq enc_sql_select("SELECT `$customfield` FROM `$table` WHERE `id` = $new_user_id"))
		{
			my $statement = "UPDATE `$table` SET `$customfield` = '$value' WHERE `id` = $new_user_id";
			my $success = enc_sql_update($statement);
			die_nice("Error: process_new_account(): SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]") unless $success == 1;
		}
	}

	if(enc_param('forcepwchng') =~ /on/i || $PREF{force_pw_chng_after_first_login} =~ /yes/i)
	{
		my $statement = "UPDATE `$table` SET `forcepwchng` = 1 WHERE `id` = $new_user_id;";
		my $success = enc_sql_update($statement);
		die_nice("Error: process_new_account(id='$new_user_id'): SQL returned '$success' instead of '1' while enabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
	}

	if(enc_param('autogroup') =~ /^(\w+)$/)   # note: regex verifies SQL safety.
	{
		my $statement = "UPDATE `$table` SET `autogroup` = '$1' WHERE `id` = $new_user_id;";
		my $success = enc_sql_update($statement);
		die_nice("Error: process_new_account(id='$new_user_id'): SQL returned '$success' instead of '1' while setting autogroup.  SQL was: [[$statement]]") unless $success == 1;
	}

	if($pending_email_verification)
	{
		$PREF{verification_email_template} =~ s/%%link%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=verify&u=$new_user_id&t=$token/g;

		my $user_email = $PREF{usernames_must_be_email_addresses} =~ /yes/i ? $user : $email;

		send_email(	$user_email,
				$PREF{app_email_address},
				$PREF{verification_email_subject},
				$PREF{verification_email_template},
				($PREF{verification_email_format} || $PREF{global_email_format}),
				'die_on_email_error'
		);

		if($payment_url)
		{
			enc_redirect($payment_url);
		}
		else
		{
			$TEXT{messages}{sactvrf} =~ s!%%username%%!$user!g;
			kmsg_redirect($TEXT{messages}{sactvrf}, $orig_qs);
		}
	}
	elsif($pending_admin_approval)
	{
		send_email_requesting_admin_approval_of_new_acct($user,$new_user_id);
		if($payment_url)
		{
			enc_redirect($payment_url);
		}
		else
		{
			$TEXT{messages}{sactapp} =~ s!%%username%%!$user!g;
			kmsg_redirect($TEXT{messages}{sactapp}, $orig_qs);
		}
	}
	else
	{
		create_filechucker_userdir($new_user_id,$user,$realname,$email);
		if($signup) { add_to_auto_groups($user); }
		notify_admin_of_new_signup($new_user_id) if $signup;

		send_welcome_email($new_user_id,$user,$pass,$email,$realname,$signup) if ($signup && $PREF{send_welcome_email_when_user_completes_signup} =~ /yes/i) || (!$signup && $PREF{send_welcome_email_when_admin_creates_an_account} =~ /yes/i);
		#enc_urlencode($user);
		if($payment_url)
		{
			enc_redirect($payment_url);
		}
		else
		{
			my $msg = $signup ? $TEXT{messages}{snewsup} : $TEXT{messages}{snewadd};
			$orig_qs =~ s!(encembed=yes|action=signup)!!g; $orig_qs = '' if $orig_qs =~ /^&+$/;
			$msg =~ s!%%username%%!$user!g;
			$msg =~ s!%%orig_qs%%!$orig_qs ? "?$orig_qs" : ""!eg;
			$msg =~ s!%%loginreturn%%!enc_param('loginreturn')!eg;
			kmsg_redirect($msg, $orig_qs);
		}
	}
}


# 20111003: replaced by per-field permissions in the DB rather than in prefs.
#
#sub user_can_view_this_field($)
#{
#	return (	user_is_allowed_to('view_' . $_[0] . '_field')
#			||
#			!exists $PREF{'groups_allowed_to_view_' . $_[0] . '_field'}		);
#}


# 20111003: replaced by per-field permissions in the DB rather than in prefs.
#
#sub user_can_edit_this_field($)
#{
#	return (	user_is_allowed_to('edit_' . $_[0] . '_field')
#			||
#			!exists $PREF{'groups_allowed_to_edit_' . $_[0] . '_field'}		);
#}


sub get_sqlsafe_custom_field_values
{
	my $signup = shift;		# bool; optional
	my $nonpost_data = shift;	# hashref; optional.

	my %customfields_sqlsafe = ();
	my $custom_field_list_table = $PREF{custom_field_list_table};
	my $table_to_modify = $PREF{user_table};

	my $error = '';
	if(enc_sql_select("SELECT COUNT(*) FROM `$custom_field_list_table`"))
	{
		my $fields = enc_sql_select_multi("SELECT * FROM `$custom_field_list_table` ORDER BY `fieldposition`");
		foreach my $j (sort { $a <=> $b } keys %$fields)
		{
			my $fieldname = $$fields{$j}{fieldname};

			next unless ($$fields{$j}{enabled} && db_column_exists($fieldname, $table_to_modify));

			# 20111003: shouldn't the allowed_to_edit check occur in the caller, instead of here?
			# 20111005: actually, we do need this check here; otherwise any fields set to mandatory,
			# but also set to uneditable by the logged-in user's groups, will result in a failed
			# update and confusing error because the mandatory (but not displayed) field wasn't
			# filled in.  And anyway, having this extra check here couldn't cause any problems,
			# because if the logged-in user (even if it's not the user being edited, e.g. even if
			# it's an admin editing a regular member) is NOT allowed to edit this field, well, then
			# we should still skip it, just as if it were the member editing his own info.
			#
			if($signup)
			{
				next unless $$fields{$j}{show_on_signup_page};
			}
			else
			{
				next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_edit});
			}

			# $fieldname is coming from $custom_field_list_table (it's a column in that table),
			# so it shouldn't be possible for it to be a built-in field, because we check for
			# that when creating new custom fields; but an extra check here doesn't hurt.
			#
			next if is_builtin_fieldname($fieldname);

			my $value = '';
			if($nonpost_data)
			{
				$value = $$nonpost_data{$fieldname};
			}
			else
			{
				next if enc_param("field_${fieldname}_disabled_by_customfield_code") =~ /yes/i;
				$value = enc_param($fieldname);
				$value =~ s/\r\n/\n/g; # fix browser newlines.
			}

			next if !$value && user_is_allowed_to('leave_mandatory_custom_fields_blank');

			#
			# Do custom-field sanity checking:
			#

			if($$fields{$j}{datatype} eq 'int'    &&   $value =~ /[^\d-]/)								{ $TEXT{Entry_not_int}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_int}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_int}; last; }
			if($$fields{$j}{datatype} eq 'uint'   &&   $value =~ /[^\d]/)								{ $TEXT{Entry_not_uint}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_uint}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_uint}; last; }
			if($$fields{$j}{datatype} eq 'float'  &&   $value =~ /[^\d\.-]/)							{ $TEXT{Entry_not_float}	=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_float}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_float}; last; }
			if($$fields{$j}{datatype} eq 'ufloat' &&   $value =~ /[^\d\.]/)								{ $TEXT{Entry_not_ufloat}	=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_ufloat}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_ufloat}; last; }

			if(($$fields{$j}{datatype} eq 'bool' || $$fields{$j}{fieldtype} eq 'checkbox')   &&   ($value =~ /^on$/i)) { $value = 1; } # convert checkbox string value to a bool.
			#if(($$fields{$j}{datatype} eq 'bool' || $$fields{$j}{fieldtype} eq 'checkbox')   &&   !($value =~ /^on$/i || !$value))		{ $TEXT{Entry_not_bool}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_bool}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_bool}; last; }
			 if(($$fields{$j}{datatype} eq 'bool' || $$fields{$j}{fieldtype} eq 'checkbox')   &&   !($value =~ /^[01]$/i || !$value))	{ $TEXT{Entry_not_bool}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_bool}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_bool}; last; }

			if($$fields{$j}{fieldtype} =~ /^(dropdown|radio)$/)
			{
				#my %allowable_values = map { $_ => 1 } split(/\n/, $listitems);
				my %allowable_values = ();
				foreach my $item (split(/\n/, $$fields{$j}{listitems}))
				{
					$item =~ s!(.+?)///(.+)!$1!; # in case they're specified as separate submit/display values.
					$allowable_values{$item} = 1;
				}
				unless($allowable_values{$value})							{ $TEXT{Entry_invalid}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_invalid}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_invalid}; last; }
			}

			if($$fields{$j}{fieldmax} =~ /^\d+$/   &&   $$fields{$j}{fieldmax} > 0   &&   length($value) > $$fields{$j}{fieldmax})
			{
				$TEXT{e_toolong} =~ s/%%item%%/$fieldname/g;
				$TEXT{e_toolong} =~ s/%%limit%%/$$fields{$j}{fieldmax}/g;
				$TEXT{e_toolong} =~ s/%%length%%/length($value)/eg;
				$error = $TEXT{e_toolong}; last;
			}

			if($$fields{$j}{mandatory}   &&   !$value) { $TEXT{e_mandatory} =~ s/%%item%%/$fieldname/g; $error = $TEXT{e_mandatory}; last; }

			if($$fields{$j}{limitallowedchars})
			{
				# Escape any dashes or closing brackets, as per perlre:
				#
				# 	If you want either "-" or "]" itself to be a member of a class,
				#	put it at the start of the list (possibly after a "^"), or escape
				#	it with a backslash.
				#
				my $allowedchars = $$fields{$j}{allowedchars};
				sql_un_untaint($allowedchars);
				$allowedchars =~ s!\]!\\]!g;
				$allowedchars =~ s!([^\\])-!$1\\-!g; # note: preventing double-escaping.

				if($value =~ /[^$allowedchars]/)
				{
					die_unless_numeric($$fields{$j}{id}, "ID");
					my ($fieldname_inner,$msg) = enc_sql_select("SELECT `fieldname`,`allowedcharsmsg` FROM `$custom_field_list_table` WHERE `id` = $$fields{$j}{id}");
					$msg =~ s!%%fieldname%%!$fieldname_inner!g;
					$error = $msg; last;
				}
			}

			#
			# Do SQL sanity checking:
			#

			sql_untaint($value);
			if(not_sqlsafe($value)) { $TEXT{e_sqlsafe} =~ s/%%fieldname%%/$fieldname/g; $error = $TEXT{e_sqlsafe}; }

			#
			# If we got this far, the value is valid.
			#

			$customfields_sqlsafe{$fieldname}{value}			= $value unless $error;
			$customfields_sqlsafe{$fieldname}{show_on_signup_page}		= $$fields{$j}{show_on_signup_page};
			$customfields_sqlsafe{$fieldname}{groups_allowed_to_view}	= $$fields{$j}{groups_allowed_to_view}; $customfields_sqlsafe{$fieldname}{groups_allowed_to_view} =~ s!\|\|\|!,!g; # Replace the db separator "|||" with a comma.
			$customfields_sqlsafe{$fieldname}{groups_allowed_to_edit}	= $$fields{$j}{groups_allowed_to_edit}; $customfields_sqlsafe{$fieldname}{groups_allowed_to_edit} =~ s!\|\|\|!,!g; # Replace the db separator "|||" with a comma.
		}
	}

	if($nonpost_data)
	{
		return ($error, \%customfields_sqlsafe);
	}
	else
	{
		if($error)	{ kmsg_redirect($error); }
		else		{ return \%customfields_sqlsafe; }
	}
}


sub this_user_is_the_logged_in_admin($)
{
	my $username = shift;
	return $PREF{admin_is_logged_in} && lc($PREF{logged_in_username}) eq lc($username);
}


sub do_email_verification($$)
{
	my $uid = shift;
	my $email_verification_token = shift;

	my $username = get_user_name($uid);
	exit_with_error qq`$TEXT{error_account_not_approved}` unless $username;
	my $realname = get_real_name($uid);
	my $email = get_email_address($uid);
	check_username_for_sql_safeness($username);
	die_nice("Invalid token '$email_verification_token'.") unless $email_verification_token =~ /^\w+$/;

	enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_email_verification` = 0, `completed_email_verification` = 1 WHERE `id` = $uid AND `email_verification_token` = '$email_verification_token' AND `pending_email_verification` = 1") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_email_verification to 0.");

	if($PREF{require_admin_approval_for_new_signups} =~ /yes/i)
	{
		start_html_output("Email Address Verified");
		print $PREF{email_verified_pending_template};
		send_email_requesting_admin_approval_of_new_acct($username,$uid);
		finish_html_output();
	}
	else
	{
		create_filechucker_userdir($uid,$username,$realname,$email);
		add_to_auto_groups($username); # The fact that we're doing email verification means that it was a signup.
		notify_admin_of_new_signup($uid);

		start_html_output("Email Address Verified");
		$PREF{email_verified_active_template} =~ s/%%login_url%%/$PREF{login_url}/g;
		print $PREF{email_verified_active_template};
		finish_html_output();
	}
}


sub resend_verification_email()
{
	my $uid = get_qs_var('uid');
	my $username = get_qs_var('user');
	die_unless_numeric($uid, 'user ID');
	exit_with_error qq`Invalid username.` unless username_is_valid($username);

	sleep (int(rand(3)) + 2); # introduce some randomness into the page load time, to thwart bots/attackers.

	my $username_from_id = get_user_name($uid);
	unless($username eq $username_from_id)
	{
		$PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_error $TEXT{verification_email_mismatch_error};
	}
	
	unless(account_is_pending_email_verification($uid))
	{
		$PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_error $TEXT{verification_email_notpending_error};
	}
	
	my $token = enc_sql_select("SELECT `email_verification_token` FROM `$PREF{user_table}` WHERE `id` = $uid");
	unless($token =~ /\w+/)
	{
		$PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_error $TEXT{verification_email_token_error};
	}

	$PREF{verification_email_template} =~ s/%%link%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=verify&u=$uid&t=$token/g;
	my $user_email = get_email_address($uid);

	send_email(	$user_email,
			$PREF{app_email_address},
			$PREF{verification_email_subject},
			$PREF{verification_email_template},
			($PREF{verification_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);

	my $address_obscured = $user_email;
	$address_obscured =~ s!^(.{1,2}).*?(\@.{1,2}).*?$!$1...$2...!;
	$TEXT{verification_email_resent___full} =~ s!%%address_obscured%%!$address_obscured!;
	$TEXT{verification_email_resent___full} =~ s!%%address%%!$user_email!;
	$PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_notice($TEXT{verification_email_resent___full});
}


sub send_email_requesting_admin_approval_of_new_acct($$)
{
	my $username = shift;
	my $uid = shift;

	my $username_urlencoded = $username;
	enc_urlencode($username_urlencoded);

	$PREF{admin_approval_email_subject} =~ s/%%username%%/$username/g;
	$PREF{admin_approval_email_template} =~ s/%%username%%/$username/g;
	$PREF{admin_approval_email_template} =~ s/%%approval_url%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=approve_or_del&uid=$uid/g;

	send_email(	$PREF{admin_approval_email_recipient},
			$PREF{app_email_address},
			$PREF{admin_approval_email_subject},
			$PREF{admin_approval_email_template},
			($PREF{admin_approval_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub approve_or_delete_pending_account($)
{
	exit_with_error($TEXT{Access_denied_}) unless user_has_addmember_rights();

	my $uid = shift;
	my $username = get_user_name($uid);

	check_username_for_sql_safeness($username);

	my ($password,$salt,$name,$email,$cdate) = enc_sql_select("SELECT `password`,`salt`,`name`,`email`,`cdate` FROM `$PREF{user_table}` WHERE `id` = $uid");
	die_nice("Error: no matching account found for that user ID.") unless $password && $salt && $cdate;

	start_html_output("Approve or Delete Pending Account");

	print	  qq``
		. qq`\n<p><b>Username:</b> $username`
		. (   $PREF{usernames_must_be_email_addresses} =~ /yes/i
			? (   qq` (email address ` . (account_has_completed_email_verification($uid) ? 'verified' : 'not verified') . qq`)`   )
			: ''
		   )
		. qq`</p>`
		. ($PREF{use_builtin_realname_field} =~ /yes/i ? qq`\n<p><b>Real Name:</b> $name</p>` : '')
		. ($PREF{use_builtin_email_field} =~ /yes/i ? qq`\n<p><b>Email Address:</b> $email (` . (account_has_completed_email_verification($uid) ? 'verified' : 'not verified') . qq`)</p>` : '')
		. (paid_groups_enabled() ? qq`\n<p><b>Payment Pending:</b> ` . (account_is_pending_payment($uid) ? 'yes' : 'no') . qq`</p>` : '')
		. (paid_groups_enabled() ? qq`\n<p><b>Payment Completed:</b> ` . (account_has_completed_payment($uid) ? 'yes' : 'no') . qq`</p>` : '')
		. qq`\n<p><b>Creation Date:</b> ` . strftime("%Y%m%d-%H:%M",localtime($cdate)) . qq`</p>`
		. qq`\n<p><br /></p>`;


	if(my @custom_field_names = get_custom_userbase_field_names($PREF{user_table}))
	{
		my @custom_field_values = enc_sql_select("SELECT " . (join ',', @custom_field_names) . " FROM `$PREF{user_table}` WHERE `id` = $uid");
		my $i = 0;
		for(@custom_field_names)
		{
			print qq`\n<p><b>$custom_field_names[$i]:</b> $custom_field_values[$i]</p>`;
			$i++;
		}
		print qq`\n<p><br /></p>`;
	}

	print	  qq`\n<p style="font-weight: bold;"><a href="$PREF{login_url}?action=approve_pending_acct&amp;uid=$uid">Approve and activate pending account '$username'</a></p>`
		. qq`\n<p style="font-weight: bold;"><a href="$PREF{login_url}?action=delete_pending_acct&amp;uid=$uid">Delete pending account '$username'</a></p>`
		. qq`\n<p></p>`
		. qq`\n`;

	finish_html_output();
}


sub approve_or_delete_pending_account_stage2($$)
{
	exit_with_error($TEXT{Access_denied_}) unless user_has_addmember_rights();

	my $uid = shift;
	my $decision = shift;
	my $username = get_user_name($uid);
	my $realname = get_real_name($uid);

	if($decision eq 'approve')
	{
		if(account_is_pending_admin_approval_in_db($uid))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_admin_approval` = 0 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_admin_approval to 0.");
		}
		if(1 != enc_sql_select("SELECT `completed_admin_approval` FROM `$PREF{user_table}` WHERE `id` = $uid"))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `completed_admin_approval` = 1 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set completed_admin_approval to 1.");
		}

		# Also disable the other pending flags here (pending_email_verification,
		# pending_payment) so that the admin has the ability to override those
		# if he wants/needs to, to manually approve the account.  Of course, we
		# won't set completed_email_verification in this case, nor will we add
		# the account to any of the paid groups.
		#
		if(account_is_pending_email_verification_in_db($uid))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_email_verification` = 0 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_email_verification to 0.");
		}
		if(account_is_pending_payment($uid))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_payment to 0.");
		}

		my $user_email = $PREF{usernames_must_be_email_addresses} =~ /yes/i ? $username : get_email_address($uid);

		create_filechucker_userdir($uid,$username,$realname,$user_email);
		add_to_auto_groups($username); # The fact that the account is pending means that it was a signup.
		notify_admin_of_new_signup($uid);

		$PREF{account_activated_email_subject} =~ s/%%username%%/$username/g;
		$PREF{account_activated_email_template} =~ s/%%username%%/$username/g;

		send_email(	$user_email,
				$PREF{app_email_address},
				$PREF{account_activated_email_subject},
				$PREF{account_activated_email_template},
				($PREF{account_activated_email_format} || $PREF{global_email_format}),
				'die_on_email_error'
		);

		start_html_output("Pending Account Approved and Activated");
		print qq`<p>The <a href="$PREF{login_url}?action=edituser&amp;id=$uid">'$username' account</a> has been approved and is now active.</p>\n`;
		finish_html_output();
	}
	else
	{
		my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{user_table}` WHERE `id` = $uid");
		$sth->execute == 1 or die_nice("SQL returned something other than 1 while deleting account from users table.");

		start_html_output("Pending Account Deleted");
		print qq`<p>The '$username' account has been deleted.&nbsp; <a href="$PREF{login_url}?action=showusers">Manage users</a> again?</p>\n`;
		finish_html_output();
	}
}


sub notify_admin_of_new_signup($)
{
	my $new_user_id = shift;
	return unless $PREF{notify_admin_of_new_signups} =~ /yes/i;

	die_unless_numeric($new_user_id, 'new_user_id');
	my ($username,$name,$email) = enc_sql_select("SELECT `username`,`name`,`email` FROM `$PREF{user_table}` WHERE `id` = '$new_user_id'");
	sql_un_untaint($name);

	my $username_template = my $name_template = my $email_template = $PREF{admin_notification_email_field_template};

	$username_template	=~ s/%%fieldname%%/$PREF{username_label}/g;
	$name_template		=~ s/%%fieldname%%/$PREF{name_label}/g;
	$email_template		=~ s/%%fieldname%%/$PREF{email_label}/g;

	$username_template	=~ s/%%fieldvalue%%/$username/g;
	$name_template		=~ s/%%fieldvalue%%/$name/g;
	$email_template		=~ s/%%fieldvalue%%/$email/g;

	my $user_info_fields = $username_template;
	$user_info_fields .= $name_template if $PREF{use_builtin_realname_field} =~ /yes/i;
	$user_info_fields .= $email_template if $PREF{use_builtin_email_field} =~ /yes/i;

	if(my @custom_field_names = get_custom_userbase_field_names($PREF{user_table}))
	{
		my @custom_field_values = enc_sql_select("SELECT " . (join ',', @custom_field_names) . " FROM `$PREF{user_table}` WHERE `id` = '$new_user_id'");
		my $i = 0;
		for(@custom_field_names)
		{
			my $template = $PREF{admin_notification_email_field_template};
			$template =~ s/%%fieldname%%/$custom_field_names[$i]/g;
			$template =~ s/%%fieldvalue%%/$custom_field_values[$i]/g;
			$user_info_fields .= $template;
			$i++;
		}
	}

	$PREF{admin_notification_email_subject} =~ s/%%username%%/$username/g;
	$PREF{admin_notification_email_subject} =~ s/%%name%%/$name/g;
	$PREF{admin_notification_email_subject} =~ s/%%email%%/$email/g;
	$PREF{admin_notification_email_template} =~ s/%%user_info_fields%%/$user_info_fields/g;

	foreach my $recipient (split(/\s*,\s*/, $PREF{admin_notification_email_recipients}))
	{
		next unless is_valid_email_address($recipient);
		send_email(	$recipient,
				$PREF{app_email_address},
				$PREF{admin_notification_email_subject},
				$PREF{admin_notification_email_template},
				($PREF{admin_notification_email_format} || $PREF{global_email_format}),
				''
		);
	}
}


sub send_welcome_email($$$$$$)
{
	my ($new_user_id, $username, $password, $email, $name, $signup) = @_;

	my $subj = $PREF{welcome_email_subject};
	my $body = $PREF{welcome_email_template};
	for($subj, $body)
	{
		s/%%username%%/$username/g;
		s/%%password%%/$signup ? '(hidden)' : $password/eg;   # when this same person just signed up, he already knows the PW, so hide it; but we need to show it in welcome emails for admin-created accounts.
		s/%%email%%/$email/g;
		s/%%name%%/$name/g;
	}

	send_email(	$email,
			$PREF{app_email_address},
			$subj,
			$body,
			($PREF{welcome_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub send_welcome_email_to_subadmin($$$$$$)
{
	my ($new_user_id, $username, $password, $email, $name) = @_;

	my $subadmin_username = user_is_part_of_a_subgroup($new_user_id);
	my $subadmin_email = get_email_address(get_user_id($subadmin_username));

	my $subj = $PREF{welcome_email_to_subadmin_for_subuser___subject};
	my $body = $PREF{welcome_email_to_subadmin_for_subuser___template};
	for($subj, $body)
	{
		s/%%username%%/$username/g;
		s/%%password%%/$password/g;
		s/%%email%%/$email/g;
		s/%%name%%/$name/g;
	}

	send_email(	$subadmin_email,
			$PREF{app_email_address},
			$subj,
			$body,
			($PREF{welcome_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub send_login_notification_email($$)
{
	my ($userid, $username) = @_;
	return unless $PREF{send_notification_email_to_admin_when_users_login} =~ /yes/i;

	for($PREF{login_notification_email_subject}, $PREF{login_notification_email_template})
	{
		s/%%username%%/$username/g;
		s/%%userid%%/$userid/g;
		s/%%userinfo_url%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=edituser&id=$userid/g;
		s/%%(real_?)?name%%/get_real_name($userid)/eg;
		s/%%email(_?address)?%%/get_email_address($userid)/eg;
	}

	foreach my $recipient (split(/\s*,\s*/, $PREF{login_notification_email_recipients}))
	{
		die_nice qq`Invalid email address: $recipient` unless is_valid_email_address($recipient);
		send_email(	$recipient,
				$PREF{app_email_address},
				$PREF{login_notification_email_subject},
				$PREF{login_notification_email_template},
				($PREF{login_notification_email_format} || $PREF{global_email_format}),
				'die_on_email_error'
		);
	}
}


sub edit_user_account()
{
	my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";

	my $userid = enc_param('userid');
	check_uid_for_uniqueness($userid); # checks for sql safeness too.
	my $username_in_db = get_user_name($userid);
	my $username = $username_in_db;

	if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $username_in_db)) { enc_redirect("$go?phase=eneedlogin"); }

	if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_admin_info', $username_in_db)   &&   is_admin_acct($userid)) { enc_redirect("$go?phase=eneedlogin"); }

	my (@results, %changes, $sth) = ();

	my $username_from_form = enc_param('username');
	if(user_is_allowed_to('edit_username_field') && $PREF{usernames_are_immutable_once_created} !~ /yes/i)
	{
		if($username_from_form ne $username_in_db)
		{
			if(user_is_allowed_to($PREF{logged_in_userid}, 'change_usernames', $username_in_db))
			{
				if(username_is_valid($username_from_form))
				{
					$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `username` = '$username_from_form' WHERE `id` = $userid");
					$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', username_from_form='$username_from_form']: $DBI::errstr\n");
					$username = $username_from_form;
					push @results, 101;
					$changes{username}{old} = $username_in_db;
					$changes{username}{new} = $username_from_form;
				}
				else
				{
					push @results, 102;
				}
			}
		}
	}

	if(user_is_allowed_to('edit_password_field'))
	{
		if(enc_param('pw1') =~ /\S/)
		{
			# Note: we don't use password_is_valid() on 'oldpw' here because then a user's password-change
			# will fail if, for example, the admin increases the minimum password length, and the old password
			# was too short.  In that case, we still want the old password to be accepted so that the password
			# can be changed, and the new password will then be checked for validity under the new rules.
			#
			if(   password_is_valid(enc_param('pw1'))   &&   password_is_valid(enc_param('pw2'))   &&   (enc_param('oldpw') =~ /\S/ || !logged_in_user_must_enter_current_password_to_change_password_for_user($userid))   )
			{
				if(enc_param('pw1') eq enc_param('pw2'))
				{
					my $user_entered_correct_old_pw = hash_this_password({ plaintext_password=>enc_param('oldpw'), username=>$username }) eq get_hashedpw($userid);

					if($user_entered_correct_old_pw   ||   !logged_in_user_must_enter_current_password_to_change_password_for_user($userid))
					{
						make_sure_new_password_is_not_a_repeat($userid,enc_param('pw1'));

						my ($hashed_password, $salt) = create_new_password_hash(enc_param('pw1'));
						check_hashedpw_for_sql_safeness($hashed_password);

						$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `password` = '$hashed_password', `salt` = '$salt' WHERE `id` = $userid");
						$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', hashed_password='$hashed_password']: $DBI::errstr\n");

						update_password_activity_table($userid,$hashed_password,$salt,$PREF{logged_in_userid});

						if($PREF{enable_forced_password_change} =~ /yes/i   &&   enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = $userid;"))
						{
							my $statement = "UPDATE `$PREF{user_table}` SET `forcepwchng` = 0 WHERE `id` = $userid;";
							my $success = enc_sql_update($statement);
							die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while disabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
						}

						push @results, 113;
						$changes{password} = 1;
					}
					else
					{
						push @results, 114;
					}
				}
				else
				{
					push @results, 104;
				}
			}
			else
			{
				push @results, 116;
			}
		}
	}

	if(user_is_allowed_to('edit_realname_field'))
	{
		if($PREF{use_builtin_realname_field} =~ /yes/i)
		{
			my $realname_from_form = enc_param('realname');
			my $realname_in_db = get_real_name($userid);
			if($realname_from_form ne $realname_in_db)
			{
				if(realname_is_valid($realname_from_form))
				{
					check_realname_for_sql_safeness($realname_from_form);
					$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `name` = '$realname_from_form' WHERE `id` = $userid");
					$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', realname_from_form='$realname_from_form']: $DBI::errstr\n");
					push @results, 105;
					$changes{realname}{old} = $realname_in_db;
					$changes{realname}{new} = $realname_from_form;
				}
				else
				{
					push @results, 106;
				}
			}
		}
	}

	my $emailaddr_from_form = enc_param('email');
	my $emailaddr_in_db = get_email_address($userid);
	if(user_is_allowed_to('edit_email_field'))
	{
		if($PREF{use_builtin_email_field} =~ /yes/i)
		{
			if($emailaddr_from_form ne $emailaddr_in_db)
			{
				if(emailaddr_is_valid($emailaddr_from_form))
				{
					check_emailaddr_for_sql_safeness($emailaddr_from_form);
					$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `email` = '$emailaddr_from_form' WHERE `id` = $userid");
					$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', emailaddr_from_form='$emailaddr_from_form']: $DBI::errstr\n");
					push @results, 107;
					$changes{email}{old} = $emailaddr_in_db;
					$changes{email}{new} = $emailaddr_from_form;
				}
				else
				{
					push @results, 108;
				}
			}
		}
	}

	if(user_is_allowed_to($PREF{logged_in_userid}, 'change_group_memberships'))
	{
		my $groups = get_groups_hash($userid);
		foreach my $group (sort keys %$groups)
		{
			next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
			next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
			next if $group eq $PREF{expired_group_name} && !$PREF{admin_is_logged_in};
			if($$groups{$group}{is_member}   &&   enc_param("group-$group") !~ /on/i)
			{
				my $reason = $userid == $PREF{logged_in_userid} ? 'self-removal' : logged_in_user_is_subgroup_manager() ? 'removed by subgroup manager' : $PREF{admin_is_logged_in} ? 'removed by admin' : 'removed via edit-user page';
				remove_user_from_group($userid, $group, $reason);
				push @results, "109$group";
				$changes{"removed_from_group_$group"} = 1;
			}
			elsif(!$$groups{$group}{is_member}   &&   enc_param("group-$group") =~ /on/i)
			{
				add_user_to_group($username, $group);
				push @results, "111$group";
				$changes{"added_to_group_$group"} = 1;
			}
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks'))
	{
		my $account_locked_old = enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
		my $account_locked_new = enc_param("account_locked") =~ /on/i ? 1 : 0;
		if($account_locked_old != $account_locked_new)
		{
			if($account_locked_new)
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = TRUE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
				push @results, 125;
			}
			else
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = FALSE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;

				unless(enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq '')
				{
					$success = enc_sql_update("UPDATE `$PREF{user_table}` SET `failed_logins` = '' WHERE `id` = '$userid';");
					die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating failed_logins.") unless $success == 1;
				}

				push @results, 127;
			}
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks'))
	{
		my $account_disabled_old = enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
		my $account_disabled_new = enc_param("account_disabled") =~ /on/i ? 1 : 0;
		if($account_disabled_old != $account_disabled_new)
		{
			if($account_disabled_new)
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_disabled` = TRUE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_disabled.") unless $success == 1;
				push @results, 129;
			}
			else
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_disabled` = FALSE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_disabled.") unless $success == 1;
				push @results, 131;
			}
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'force_password_changes'))
	{
		if($PREF{enable_forced_password_change} =~ /yes/i)
		{
			my $forcepwchng_old = enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
			my $forcepwchng_new = enc_param("forcepwchng") =~ /on/i ? 1 : 0;
			if($forcepwchng_old != $forcepwchng_new)
			{
				if($forcepwchng_new)
				{
					my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `forcepwchng` = 1 WHERE `id` = '$userid';");
					die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating forcepwchng.") unless $success == 1;
					push @results, 133;
				}
				else
				{
					my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `forcepwchng` = 0 WHERE `id` = '$userid';");
					die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating forcepwchng.") unless $success == 1;
					push @results, 135;
				}
			}
		}
	}


	my $customfields_sqlsafe = get_sqlsafe_custom_field_values();
	foreach my $customfield (keys %$customfields_sqlsafe)
	{
		if(logged_in_user_belongs_to_one_of_these_group_ids($$customfields_sqlsafe{$customfield}{groups_allowed_to_edit}))
		{
			die_unless_numeric($userid, "userid");
			my $value = $$customfields_sqlsafe{$customfield}{value};
			my $old_value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = $userid");
			unless($value eq $old_value)
			{
				$value = 0 if !$value && datatype_is_numeric($PREF{user_table}, $customfield);
				my $statement = "UPDATE `$PREF{user_table}` SET `$customfield` = '$value' WHERE `id` = $userid";
				my $success = enc_sql_update($statement);
				die_nice("Error: edit_user_account(): SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]") unless $success == 1;
				push @results, "137$customfield";
				$changes{$customfield}{old} = $old_value;
				$changes{$customfield}{new} = $value;
			}
		}
	}

	log_userinfo_updates($userid,\%changes) if $PREF{log_all_userinfo_updates} =~ /yes/i;

	if($PREF{user_info_page_template}   &&
						(
							!$PREF{admin_is_logged_in}
							|| ( $PREF{admin_is_logged_in}   &&   $userid == $PREF{logged_in_userid} )
							|| ( $PREF{show_user_info_page_after_admin_edits_accounts} =~ /yes/i )
						)
	)
	{
		enc_redirect("$PREF{login_url}?action=userinfo&id=$userid");
	}
	else
	{
		enc_redirect("$go?rslt=100&uid=$userid&" . join '&', @results);
	}
}


sub show_user_info($)
{
	my $userid = shift; # caller verifies that this is numeric.
	exit_with_needprivs() unless user_is_allowed_to('view_all_accounts') || $userid == $PREF{logged_in_userid};
	my $template = $PREF{user_info_page_template};
	$template =~ s!%%(\w+)%%!(db_column_exists($1,$PREF{user_table}) && enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $userid")) || ''!eg;
	exit_with_output($template);
}


sub log_userinfo_updates($$)
{
	my $changee_userid = shift;
	my $changes = shift; # hashref.

	my $ip			= my $ip_sql		= $PREF{ip};
	my $host		= my $host_sql		= $PREF{host};
	my $browser		= my $browser_sql	= $ENV{HTTP_USER_AGENT};
	my $timestamp		= offsettime();

	sql_untaint($ip_sql, $host_sql, $browser_sql);
	die_unless_sqlsafe($ip_sql, $host_sql, $browser_sql);

	die_unless_numeric($PREF{logged_in_userid}, 'logged-in user ID');
	die_unless_numeric($changee_userid, 'user ID of changed account');
	die_unless_numeric($timestamp, 'timestamp of userinfo updates');

	my @changes_for_email = ();
	foreach my $field (keys %$changes)
	{
		my $old_value	= ref($$changes{$field}) eq 'HASH' ? $$changes{$field}{old} : 'N/A';
		my $new_value	= ref($$changes{$field}) eq 'HASH' ? $$changes{$field}{new} : 'N/A';

		sql_untaint($old_value,$new_value);
		die_unless_sqlsafe($old_value,$new_value);

		if($field =~ /removed_from_group_(.+)/)
		{
			$field = 'group membership';
			$old_value = 'N/A';
			$new_value = qq`Removed user from the "$1" group`;
			push @changes_for_email, $new_value;
		}
		elsif($field =~ /added_to_group_(.+)/)
		{
			$field = 'group membership';
			$old_value = 'N/A';
			$new_value = qq`Added user to the "$1" group`;
			push @changes_for_email, $new_value;
		}
		elsif($field eq 'password')
		{
			$field = 'password';
			$old_value = 'not logged, for security purposes';
			$new_value = 'not logged, for security purposes';
			push @changes_for_email, "Changed password";
		}
		else
		{
			push @changes_for_email, "Changed '$field' from '$old_value' to '$new_value'";
		}

		if($PREF{log_all_userinfo_updates} =~ /yes/i)
		{
			sql_untaint($field);
			die_unless_sqlsafe($field);

			enc_sql_insert("INSERT INTO `$PREF{userinfo_updates_table}`
				(`timestamp`, `changer_id`, `changee_id`, `item_changed`, `old_value`, `new_value`, `ip_address`, `hostname`, `browser`)
				VALUES($timestamp, $PREF{logged_in_userid}, $changee_userid, '$field', '$old_value', '$new_value', '$ip_sql', '$host_sql', '$browser_sql')
			");
		}
	}

	if($PREF{send_email_notification_upon_userinfo_updates} =~ /yes/i)
	{
		my $msg = $PREF{userinfo_updates_notification___body};
		my $subject = $PREF{userinfo_updates_notification___subject};

		my $newline = $PREF{userinfo_updates_notification___format} =~ /html/i ? "<br />\n" : "\n";

		my ($changee_username, $changee_email, $changee_realname)
		= enc_sql_select("SELECT `username`,`email`,`name` FROM `$PREF{user_table}` WHERE `id` = $changee_userid");

		for($msg, $subject)
		{
			s!%%changer_username%%!$PREF{logged_in_username}!g;
			s!%%changer_userid%%!$PREF{logged_in_userid}!g;
			s!%%changer_email%%!$PREF{logged_in_email}!g;
			s!%%changer_realname%%!$PREF{logged_in_realname}!g;
			s!%%changer_(\w+)%%!db_column_exists($1,$PREF{user_table}) && enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $PREF{logged_in_userid}")!eg;

			s!%%changee_username%%!$changee_username!g;
			s!%%changee_userid%%!$changee_userid!g;
			s!%%changee_email%%!$changee_email!g;
			s!%%changee_realname%%!$changee_realname!g;
			s!%%changee_(\w+)%%!db_column_exists($1,$PREF{user_table}) && enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $changee_userid")!eg;

			s!%%changelist%%!join "$newline$newline-----$newline$newline", @changes_for_email!eg;
		}

		foreach my $recipient (split(/\s*,\s*/, $PREF{userinfo_updates_notification___recipient}))
		{
			my %recipients = ();
			if($recipient eq '%%self%%')
			{
				#print STDERR "it's %%self%%\n";
				$recipients{ $$changes{email}{old} }	= 1 if is_valid_email_address($$changes{email}{old});
				$recipients{ $$changes{email}{new} }	= 1 if is_valid_email_address($$changes{email}{new});
				$recipients{ $PREF{logged_in_email} }	= 1 if is_valid_email_address($PREF{logged_in_email});
				$recipients{ $changee_email }		= 1 if is_valid_email_address($changee_email);
				$recipients{ $changee_username }	= 1 if is_valid_email_address($changee_username);
			}
			else
			{
				#print STDERR "it's not...\n";
				$recipients{ $recipient } = 1;
			}

			foreach my $recip (keys %recipients)
			{
				send_email(
					$recip,
					$PREF{userinfo_updates_notification___sender},
					$subject,
					$msg,
					($PREF{userinfo_updates_notification___format} || $PREF{global_email_format}),
					'die_on_email_error'
				);
			}
		}
	}
}


sub print_admin_toolbar()
{
	my %status = ();
	my $user_type = ();

	if($PREF{admin_is_logged_in})		{ $user_type = 'Admin'; }
	elsif($PREF{member_is_logged_in})	{ $user_type = 'Member'; }

	if(   ($PREF{member_is_logged_in})   ||   ($qs =~ /^login|action=validate$/)   )
	{
		my $tb = qq`\n<div class="userinfo">\n`;
		$tb .= qq`<div class="userinfoleft">` . ($PREF{member_is_logged_in} ? "$user_type $PREF{logged_in_username} logged in." : "[Not logged in.]" ) . qq`</div>`;
		$tb .= qq`\n<div class="userinforight"><a href="$PREF{login_url}">$PREF{myaccount_footer_link_name}</a></div>`;
		$tb .= qq`\n<div class="clear">&nbsp;</div>`;
		$tb .= qq`\n</div>`;
	}
}


sub get_UB_login_status_string
{
	if($PREF{member_is_logged_in})
	{
		my $status = $PREF{login_status_string_template};

		my $numusers = 1;
		if(!$PREF{login_is_via_encauth})
		{
			die_unless_numeric($PREF{logged_in_userid}, 'logged_in_userid');
			$numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';");
		}
		my $usertype = $PREF{admin_is_logged_in} ? 'Admin' : 'Member';
		my $extra_info = $numusers > 1 ? ' (multiple locations)' : '';
		$status =~ s/%%usertype%%/$usertype/g;
		$status =~ s/%%username%%/$PREF{logged_in_username}/g;
		$status =~ s/%%realname%%/$PREF{logged_in_realname}/g;
		$status =~ s/%%extra_info%%/$extra_info/g;

		return $status;
	}
	else { return ''; }
}


sub print_login_logout_link_and_exit()
{
	print_http_headers(); print get_login_logout_link(); exit;
}


sub get_login_logout_link()
{
	return $PREF{member_is_logged_in} ? $PREF{login_logout_link_template___logout} : $PREF{login_logout_link_template___login};
}


sub print_login_status_and_exit()
{
	print_http_headers(); print get_login_status(); exit;
}


sub get_login_status()
{
	return $PREF{member_is_logged_in} ? $PREF{login_status_template___loggedin} : $PREF{login_status_template___loggedout};
}


sub email_failed_logins_to_webmaster($$)
{
	return unless $PREF{email_webmaster_on_failed_logins} =~ /yes/i;

	my ($attempted_username, $attempted_password) = ($_[0], $_[1]);

	return unless ($attempted_username   ||   $attempted_password); # because bots seem to trigger this a lot.

	my $shortdatetime	= strftime("%a%b%d,%Y,%I:%M%p", localtime(time)); # note: "%P" causes crashes/hangs on some Windows servers; use "%p" instead.

my $msg = qq`Sent: $shortdatetime

Someone just attempted to log in at $PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}, but failed.

Their attempted login:
attempted username: $attempted_username
attempted password: $attempted_password

Their information:
IP:   $PREF{ip}
Host: $PREF{host}
User Agent: $ENV{HTTP_USER_AGENT}
Referer: $ENV{HTTP_REFERER}

`;


	send_email(	$PREF{webmaster_email_address},
			$PREF{app_email_address},
			"Failed login",
			$msg,
			($PREF{failed_login_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
		);

}


sub print_main_menu
{
	$PREF{on_page} = 'mainmenu';

	if($qs =~ /format=mini/)
	{
		my $template = $PREF{mainmenu_template__mini};
		$template = interpolate_userbase_variables($template);
		print_http_headers();
		print $template;
	}
	elsif(   $PREF{custom_mainmenu_page}   &&   (-f $PREF{custom_mainmenu_page} || -f "$PREF{DOCROOT}/$PREF{custom_mainmenu_page}")   )
	{
		my $page = $PREF{custom_mainmenu_page};
		$page = "$PREF{DOCROOT}/$page" unless -e $page;
		exit_with_error(qq`Error: the file specified by \$PREF{custom_mainmenu_page} does not exist.  ("$PREF{custom_mainmenu_page}")`) unless -e $page;

		my $pagecontents = '';
		open(my $infh, $page) or die_nice qq`$PREF{internal_appname}: print_main_menu(): couldn't open file "$page" for reading: $!`;
		flock $infh, 1;
		seek $infh, 0, 0;
		$pagecontents .= $_ while(<$infh>);
		close $infh or die_nice qq`$PREF{internal_appname}: print_main_menu(): couldn't close file "$page" after reading: $!`;

		while($pagecontents =~ /(<!--\s*%%%group-(.+?)%%%\s*-->(.*?)<!--\s*%%%end-group-\2%%%\s*-->)/gs)
		{
			my ($block, $group, $contents) = ($1, $2, $3);
			$pagecontents =~ s!\Q$block\E!user_is_member_of_group($PREF{logged_in_userid}, $group) ? $contents : ''!es;
		}

		print_http_headers();
		start_html_output($TEXT{Main_Menu}) unless $PREF{hide_builtin_header_on_custom_mainmenu} =~ /yes/i;
		print $pagecontents;
		finish_html_output() unless $PREF{hide_builtin_footer_on_custom_mainmenu} =~ /yes/i;
	}
	else
	{
		my %group_menu_done = ();
		my $menus = '';

		my $groups = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}` ORDER BY `mainmenu_position`");
		foreach my $j (sort {$a <=> $b} keys %$groups)
		{
			my $group = $$groups{$j}{group};
			next unless user_is_member_of_group($PREF{logged_in_userid}, $group) || ($PREF{admin_is_logged_in} && $PREF{show_all_mainmenus_for_admins} !~ /no/i);
			next if $group eq $PREF{public_group_name};
			next if $group_menu_done{$group};
			next if $$groups{$j}{mainmenu_position} eq '0';
			next if $QS{showgroup} && $QS{showgroup} !~ /(?:^|,)$$groups{$j}{id}(?:,|$)/;   # so you can pass ?showgroup=N (or N,O,P...) on the URL to only show the menu for the specified group(s).

			create_mainmenu_table_for_group($group);

			if(my $menu = get_group_menu($group))
			{
				$menus .= $menu;
				$group_menu_done{$group} = 1;
			}
		}

		my $page = $PREF{mainmenu_page_template};
		$page =~ s/%%menus%%/$menus/g;
		$page = interpolate_userbase_variables($page);

		start_html_output($TEXT{Main_Menu});
		print $page;
		finish_html_output();
	}
}


sub get_group_menu_title($)
{
	my $group_id = shift;
	check_id_for_sql_safeness($group_id);
	return enc_sql_select("SELECT `mainmenu_title` FROM `$PREF{group_table}` WHERE `id` = '$group_id'");
}


sub get_group_menu($)
{
	my $group = shift;
	exit_with_error("Invalid group name.") unless groupname_is_valid($group);
	exit_with_needprivs() unless user_is_member_of_group($PREF{logged_in_userid}, $group) || $PREF{admin_is_logged_in};

	my $group_id = get_group_id($group);
	my $mainmenu_title = get_group_menu_title($group_id);

	my $links = my $menu = '';
	my $i = 0;
	my $multi_link_sep = $PREF{multi_link_separator_for_mainmenu} || ' &bull; ';

	my $group_for_tablename = $group;
	$group_for_tablename =~ s!\W!!g;
	my $mainmenu_table = $PREF{userbase_table_name_prefix} . '_mainmenu_for_' . lc($group_for_tablename);

	my $no_links_in_database = 1;
	my $alllinks = enc_sql_select_multi("SELECT * FROM `$mainmenu_table` ORDER BY `link_position`");
	foreach my $k (sort { $a <=> $b } keys %$alllinks)
	{
		my $addr = $$alllinks{$k}{link_address};
		next unless $$alllinks{$k}{link_text};
		next if $$alllinks{$k}{hide_link};
		if($$alllinks{$k}{autohide})
		{
			next if ($addr eq '%PREF{login_url_qsready}action=viewpayments') && !paid_groups_enabled();
			next if ($addr eq '%PREF{login_url_qsready}action=joinpaidgroup') && !paid_groups_enabled();
			next if ($addr eq '%PREF{login_url_qsready}action=promos') && !paid_groups_enabled();
			next if ($addr eq '%PREF{login_url_qsready}action=payreport') && !paid_groups_enabled();
			next if ($addr eq '%PREF{login_url_qsready}action=joinpaidgroupsubs') && !(paid_groups_enabled() && logged_in_user_is_subgroup_manager());
			next if ($addr eq '%PREF{login_url_qsready}action=ubsentmail') && $PREF{log_all_sent_mail} !~ /yes/i;
		}
		my $first = $k == 1 ? 'first' : '';

		$$alllinks{$k}{link_text} = interpolate_userbase_variables($$alllinks{$k}{link_text});
		$addr = interpolate_userbase_variables($addr);
		sql_un_untaint($$alllinks{$k}{link_extra_attributes});

		if($addr)
		{
			if($group eq $PREF{admin_group_name})   # use some special rules to format the admin menu a bit more nicely since it's so huge.
			{
				my $admin_alert_icon = $PREF{admin_alert_icon} if $addr eq "$PREF{login_url_qsready}action=adminalerts";
				my $prev_addr = $$alllinks{$k - 1}{link_address};
				my $next_addr = $$alllinks{$k + 1}{link_address};

				my $start_of_multi_set	= 1 if ($addr =~ /action=showusers/ && $next_addr =~ /action=groups/)   ||   ($addr =~ /action=customfields/ && $next_addr =~ /action=fieldsections/)   ||   ($addr =~ /action=showlogins/ && $next_addr =~ /action=showfailedlogins/)   ||   ($addr =~ /action=csvimport/ && $next_addr =~ /action=csvexport/)   ||   ($addr =~ /action=do_email_test/ && $next_addr =~ /action=ubsentmail/)   ||   ($addr =~ /action=viewpayments/ && $next_addr =~ /action=payreport/);
				my $end_of_multi_set	= 1 if ($prev_addr =~ /action=showusers/ && $addr =~ /action=groups/)   ||   ($prev_addr =~ /action=customfields/ && $addr =~ /action=fieldsections/)   ||   ($prev_addr =~ /action=showlogins/ && $addr =~ /action=showfailedlogins/)   ||   ($prev_addr =~ /action=csvimport/ && $addr =~ /action=csvexport/)   ||   ($prev_addr =~ /action=do_email_test/ && $addr =~ /action=ubsentmail/)   ||   ($prev_addr =~ /action=viewpayments/ && $addr =~ /action=payreport/);

				$links .= qq`<div class="linkrow ` . oddeven($i) . qq` $first">` unless $end_of_multi_set;
				$links .= qq`<a href="$addr" $$alllinks{$k}{link_extra_attributes}>$$alllinks{$k}{link_text}$admin_alert_icon</a>`;
				$links .= $start_of_multi_set ? $multi_link_sep : qq`</div>\n`;
			}
			else
			{
				$links .= qq`<div class="linkrow ` . oddeven($i) . qq` $first">`;
				$links .= qq`<a href="$addr" $$alllinks{$k}{link_extra_attributes}>$$alllinks{$k}{link_text}</a>`;
				$links .= qq`</div>\n`;
			}
		}
		else
		{
			$links .= qq`<div class="` . oddeven($i) . qq` text $first" $$alllinks{$k}{link_extra_attributes}>$$alllinks{$k}{link_text}</div>\n`;
		}
		$no_links_in_database = 0;
	}

	if($group eq $PREF{member_group_name}   &&   user_is_allowed_to('view_member_directory')   &&   $PREF{show_link_to_member_directory_on_member_mainmenu} !~ /no/i)
	{
		my $first = $links ? '' : 'first';
		$links .= qq`<div class="linkrow ` . oddeven($i) . qq` $first"><a href="$PREF{login_url_qsready}action=memberdirectory">$TEXT{View_Member_Directory}</a></div>\n`;
	}

	if(user_is_allowed_to('edit_all_mainmenus') || user_is_allowed_to("edit_${group}_mainmenu"))
	{
		unless($PREF{dont_show_editmenu_link_within_menu_itself} =~ /yes/i)
		{
			my $first = $links ? '' : 'first';
			$links .= qq`<div class="linkrow ` . oddeven($i) . qq` $first"><a href="$PREF{login_url}?action=editmainmenu&amp;gid=$group_id">$TEXT{Edit_This_Menu}</a></div>\n`;
		}
	}

	#if($links && ($$groups{$j}{mainmenu_title} || !$no_links_in_database)) # or maybe just if($links) is enough here?
	if($links)
	{
		$menu = $PREF{mainmenu_template};
		$menu =~ s/%%links%%/$links/g;
		my $group_for_title = $group;
		$group_for_title =~ s!^(\w)!\u$1!;
		$mainmenu_title =~ s!%%group%%!$group_for_title!g;
		$menu =~ s!%%title%%!$mainmenu_title!g;
	}

	return $menu;
}


sub print_group_menu
{
	my $group = get_qs_var('group');
	print_http_headers();
	start_html_output() unless get_qs_var('bare') eq 'true';
	print get_group_menu($group);
	finish_html_output() unless get_qs_var('bare') eq 'true';
}


sub get_linkbar
{
	my ($nostatus) = (0);
	for(@_)	{ $nostatus = 1 if /^nostatus$/; }
	my @links = ();

	$PREF{pwreset_url} ||= "$PREF{login_url}?action=pwreset1";   # in case the webmaster wants to do something like ?mailto=me@my.com&Subject=Please%20reset%20my%20password...
	$PREF{myaccount_footer_link_name} = $PREF{login_footer_link_name} if !$PREF{member_is_logged_in};

	if($QS{autogroup} && $PREF{signup_link_url} !~ /autogroup=/) { $PREF{signup_link_url} .= $PREF{signup_link_url} =~ /\?/ ? "&autogroup=$QS{autogroup}" : "?autogroup=$QS{autogroup}"; }

	push (@links, qq`<a href="$PREF{home_link_url}">$PREF{home_link_name}</a>`) if $PREF{home_link_name} && ($ENV{REQUEST_URI} ne $PREF{home_link_url});
	push (@links, qq`<a href="$PREF{login_url}">$PREF{myaccount_footer_link_name}</a>$PREF{admin_alert_icon}`) if($PREF{show_myaccount_link_in_footer} =~ /yes/i && $qs);

	push (@links, qq`<a href="$PREF{signup_link_url}">$PREF{signup_link_name}</a>`) if($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i && $PREF{signup_link_name} && !$PREF{member_is_logged_in});
	push (@links, qq`<a href="$PREF{pwreset_url}">$TEXT{Reset_Password}</a>`) if($PREF{enable_password_reset} =~ /yes/i && !$PREF{member_is_logged_in});

	if($PREF{member_is_logged_in}   &&   $PREF{show_logout_link_in_footer} =~ /yes/i)
	{
		if($PREF{login_is_via_encauth})
		{
			push (@links, qq`<a href="$ENV{SCRIPT_NAME}?logout">$TEXT{Log_Out}</a>`);
		}
		else
		{
			push (@links, qq`<a href="$ENV{SCRIPT_NAME}?ublogout">$TEXT{Log_Out}</a>`);
			if(enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';") > 1)
			{
				push (@links, qq`<a href="$ENV{SCRIPT_NAME}?ublogoutall">$TEXT{Log_Out_All_Locations}</a>`);
			}
		}
	}

	push (@links, @{$PREF{extra_footer_links}}) if $PREF{extra_footer_links};

	my $footer = $PREF{custom_footer_links} ? $PREF{custom_footer_links}
		: @links ? qq`<div class="ublinkbar_links">` . (join ' &#8211; ', @links) . qq`</div>\n`
		: '';

	my $loginstatus = get_UB_login_status_string();
	$footer .= qq`<div class="ublinkbar_status">$loginstatus</div>\n` if $PREF{show_login_status_in_footer} =~ /yes/i && $loginstatus && !$nostatus;

	return $footer;
}


sub get_powered_by
{
	return qq`<a href="http://encodable.com/userbase/" target="_blank">Login System by Encodable</a>`;
}


sub get_css()
{
	return get_css_std();
}


sub get_js
{

my $js = get_js_std() . qq`

var submitbutton_text_default = '';
var num_submit_checks_still_pending = 0;

function submit_user_form()
{
	if(check_for_required_userbase_fields('userform')   &&   check_passwords('userform')   &&   check_group_selections('userform')   &&   check_terms())
	{
		if(document.getElementById("enc-humantest"))
			check_humanity(); // control continues at check_humanity__finish().

		submit_user_form_final(); // called unconditionally; all checks within this block must either return false or use num_submit_checks_still_pending if they want to halt the upload.
	}
	else { return false; }
}

function submit_user_form_final()
{
	if(num_submit_checks_still_pending > 0)
		return;

	gebi('userform').submit();
}

function check_terms()
{
	var terms = gebi("agreetoterms");
	if(terms && !terms.checked)
	{
		alert("$PREF{terms_unchecked_error_message}");
		return false;
	}
	else
	{
		return true;
	}
}

function check_passwords(form_id)
{
	var pw1 = gebi('ubpw1');
	var pw2 = gebi('ubpw2');
	var passwords_ok = 0;

	// Note: if one exists, both do; and if one's required, both are.

	if(!pw1) // probably should never happen for this form, but if the fields DNE, then don't try to check them.
	{
		passwords_ok = 1;
	}
	else if(pw1.className.indexOf('required') == -1   &&   pw1.value == ''   &&   pw2.value == '')
	{
		passwords_ok = 1;
	}
	else if(pw1.value != pw2.value)
	{
		alert("$TEXT{Passwords_do_not_match_}");
	}
	else if((pw1.value.length < $PREF{min_password_length})   ||   (pw2.value.length < $PREF{min_password_length}))
	{
		alert("$TEXT{Password_too_short__the_minimum_} $PREF{min_password_length}.");
	}
	else if((pw1.value.length > $PREF{max_password_length})   ||   (pw2.value.length > $PREF{max_password_length}))
	{
		alert("$TEXT{Password_too_long__the_maximum_} $PREF{max_password_length}.");
	}
	else
	{
		passwords_ok = 1;
	}

	return passwords_ok;
}

function monitor_pw_field()
{
	if(!gebi('ubpw1') || !gebi('pw_strength'))
		return;

	gebi('ubpw1').onchange = update_pw_strength_output;
	gebi('ubpw1').onkeyup = update_pw_strength_output;
}

function update_pw_strength_output()
{
	var pw = gebi('ubpw1').value;
	gebi('pw_strength').innerHTML = 'Password strength: ' + get_pw_strength(pw);
}

function check_group_selections(form_id)
{
	//if(gebi('is_signup').value != 1)
	//	return 1;

	var all_group_checkboxes = gebi(form_id).getElementsByClassName('ub_group_checkbox');
	var paid_group_checkboxes = gebi(form_id).getElementsByClassName('ub_paidgroup_checkbox');

	var num_groups_checked = 0;
	for(i = 0; i < all_group_checkboxes.length; i++)
		if(all_group_checkboxes[i].checked)
			num_groups_checked++;

	var paid_groups_checked = 0;
	for(i = 0; i < paid_group_checkboxes.length; i++)
		if(paid_group_checkboxes[i].checked)
			paid_groups_checked++;

	var groups_ok = 0;

	if(("$PREF{user_must_choose_exactly_one_group_on_signup_form}" == "yes")   &&   (num_groups_checked != 1))
	{
		alert("$TEXT{choose_exactly_one_group_on_signup_form}");
	}
	else if(("$PREF{user_must_choose_atleast_one_group_on_signup_form}" == "yes")   &&   (num_groups_checked < 1))
	{
		alert("$TEXT{choose_atleast_one_group_on_signup_form}");
	}
	else if(("$PREF{user_must_choose_exactly_one_paidgroup_on_signup_form}" == "yes")   &&   (paid_groups_checked != 1))
	{
		alert("$TEXT{choose_exactly_one_paidgroup_on_signup_form}");
	}
	else if(("$PREF{user_must_choose_atleast_one_paidgroup_on_signup_form}" == "yes")   &&   (paid_groups_checked < 1))
	{
		alert("$TEXT{choose_atleast_one_paidgroup_on_signup_form}");
	}
	else
	{
		groups_ok = 1;
	}

	return groups_ok;
}

function check_for_required_userbase_fields(form_id)
{
	var onlyinputs = gebi(form_id).getElementsByTagName('input');
	var selects = gebi(form_id).getElementsByTagName('select');
	var textareas = gebi(form_id).getElementsByTagName('textarea');
	var inputs = new Array;

	for(i = 0; i < onlyinputs.length; i++)
		inputs[inputs.length] = onlyinputs[i];

	for(i = 0; i < selects.length; i++)
		inputs[inputs.length] = selects[i];

	for(i = 0; i < textareas.length; i++)
		inputs[inputs.length] = textareas[i];

	var items_missing = 0;
	var email_format_incorrect = 0;
	var radios = new Object;
	var radios_checked = new Object;
	var unchecked_radio = '';

	for(i = 0; i < inputs.length; i++)
	{
		if(inputs[i].type == 'button')
		{
			continue;
		}
		if(inputs[i].type == 'radio'   &&   inputs[i].className.indexOf('required') != -1)
		{
			radios[inputs[i].name] = 1;
			if(inputs[i].checked)
				radios_checked[inputs[i].name] = 1;
		}
		if(inputs[i].className.indexOf('required') != -1   &&   (inputs[i].value == '' || inputs[i].value == undefined))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			items_missing = 1;
		}
		else if(inputs[i].className.indexOf('emailformat') != -1   &&   inputs[i].value.length > 0   &&   !inputs[i].value.match( /.+\@.+\\..+/ ))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			email_format_incorrect = 1;
		}
		else
		{
			inputs[i].style.background	= inputs[i].type == 'radio' || inputs[i].type == 'checkbox' || inputs[i].type == 'button' || inputs[i].type == 'submit' ? 'transparent' : '$PREF{default_bgcolor_for_required_fields}';
			inputs[i].style.color		= '$PREF{default_textcolor_for_required_fields}';
		}
	}

	for (var j in radios)
	{
		if(!radios_checked[j])
			unchecked_radio = j;
	}

	if(items_missing)
	{
		alert("Please fill in the required item(s).");
	}
	else if(email_format_incorrect)
	{
		alert("Please enter a valid email address.");
	}
	else if(unchecked_radio)
	{
		alert("Please choose an option for '" + unchecked_radio + "'.");
	}
	else
	{
		return 1;
	}

	return 0;
}

function focus_username_field()
{
	if(gebi("ubun"))
	{
		gebi("ubun").focus();
	}
}

function show_hide_rows()
{
	var MSIE = navigator.userAgent.indexOf("MSIE") == -1 ? 0 : 1; // IE doesn't support table-row...
	var Enabled = MSIE  ? 'block' : 'table-row';

	if(gebi("ub_datatype").value == 'varchar')
		gebi("ub_fieldmax_row").style.display = Enabled;
	else
		gebi("ub_fieldmax_row").style.display = 'none';

	var fieldtype = gebi("ub_fieldtype").value;

	var mandatory_row = gebi("ub_mandatory_row").style;
	var limitallowedchars_row = gebi("ub_limitallowedchars_row").style;
	var allowedchars_row = gebi("ub_allowedchars_row").style;
	var allowedcharsmsg_row = gebi("ub_allowedcharsmsg_row").style;
	var listitems_row = gebi("ub_listitems_row").style;

	if(fieldtype.indexOf('freeform') != -1)
	{
		mandatory_row.display = Enabled;
		limitallowedchars_row.display = Enabled;
		allowedchars_row.display = Enabled;
		allowedcharsmsg_row.display = Enabled;
		listitems_row.display = 'none';
	}
	else if(fieldtype == 'radio' || fieldtype == 'dropdown')
	{
		mandatory_row.display = Enabled;
		limitallowedchars_row.display = 'none';
		allowedchars_row.display = 'none';
		allowedcharsmsg_row.display = 'none';
		listitems_row.display = Enabled;
	}
	else if(fieldtype == 'checkbox')
	{
		mandatory_row.display = 'none';
		limitallowedchars_row.display = 'none';
		allowedchars_row.display = 'none';
		allowedcharsmsg_row.display = 'none';
		listitems_row.display = 'none';
	}
}

function replace_required_classnames_with_placeholders(elname)
{
	var requiredElementsArray = getElementsByClassName("required", null, elname);
	for (var i=0, il=requiredElementsArray.length, requiredElement; i<il; i++)
	{
		requiredElementsArray[i].className = requiredElementsArray[i].className.replace(/required/, "reqdplaceholder");
		add_hidden_field_to_userform_noting_disabled_field(requiredElementsArray[i].name);
	}
}

function restore_required_classnames_from_placeholders(elname)
{
	var requiredElementsArray = getElementsByClassName("reqdplaceholder", null, elname);
	for (var i=0, il=requiredElementsArray.length, requiredElement; i<il; i++)
	{
		requiredElementsArray[i].className = requiredElementsArray[i].className.replace(/reqdplaceholder/, "required");
		remove_hidden_field_from_userform_noting_disabled_field(requiredElementsArray[i].name);
	}
}

function add_hidden_field_to_userform_noting_disabled_field(fieldname)
{
	var userform = gebi("userform");
	if(userform)
	{
		var field_id = "field_" + fieldname + "_disabled_by_customfield_code";
		if(!gebi(field_id))
		{
			var newfield = document.createElement("input");
			newfield.type = "hidden";
			newfield.id = field_id;
			newfield.name = field_id;
			newfield.value = "yes";
			userform.appendChild(newfield);
		}
	}
}

function remove_hidden_field_from_userform_noting_disabled_field(fieldname)
{
	var userform = gebi("userform");
	if(userform)
	{
		var field_id = "field_" + fieldname + "_disabled_by_customfield_code";
		var thefield = gebi(field_id);
		if(thefield)
			userform.removeChild(thefield);
	}
}

// For the various hidden fields passed to PayPal (item_name_N, item_number_N, quantity_N, etc), the "N"
// must be "1" if you're passing a single item for purchase; and it must be "1" and "2" if you're passing
// two items, etc.  So since the user can check/uncheck any number of items to buy, we can't set those N
// values from the server-side, but instead must update them all each time a box is checked/unchecked.
// Also, if the price for a given item is zero (e.g. because a 100% promo code is used), then don't bother
// sending that one to PayPal because a) it's unnecessary and kind of confusing, and b) if you try to post
// ONLY a single item, and its price is zero, then PayPal throws an error.
//
function update_paidgroup_selections()
{
	var free_groups = [],
	    paid_groups = [];
	var checked_counter = 0;
	var paidgroup_checkbox_groups = gebi("join_paid_group_checkboxes_form").getElementsByClassName("paidgroup_checkbox_group");
	for(i = 0; i < paidgroup_checkbox_groups.length; i++)
	{
		var groupnum = paidgroup_checkbox_groups[i].id.match(/_(\\d+)\$/)[1];

		var price = gebi('paidgroup_checkbox_price_' + groupnum).value;
		var price_is_zero = 0;
		if(price == 0   ||   price == '0.00')
			price_is_zero = 1;

		var this_one_is_checked = paidgroup_checkbox_groups[i].getElementsByClassName("paidgroup_checkboxes")[0].checked;
		if(this_one_is_checked && !price_is_zero)
		{
			checked_counter++;
			paid_groups.push(groupnum);
		}

		if(this_one_is_checked && price_is_zero)
			free_groups.push(groupnum);

		var paidgroup_paypal_fields = paidgroup_checkbox_groups[i].getElementsByClassName("paidgroup_paypal_fields");
		for(j = 0; j < paidgroup_paypal_fields.length; j++)
		{
			if(this_one_is_checked && !price_is_zero)
			{
				paidgroup_paypal_fields[j].disabled = false;
				paidgroup_paypal_fields[j].name = paidgroup_paypal_fields[j].name.replace(/(\\d+)\$/, checked_counter);
			}
			else
			{
				paidgroup_paypal_fields[j].disabled = true;
				paidgroup_paypal_fields[j].name = paidgroup_paypal_fields[j].name.replace(/(\\d+)\$/, "0");
			}
		}
	}
	return { free: free_groups, paid: paid_groups };
}

function submit_joinpaidgroup_checkboxes_form()
{
	var groups = update_paidgroup_selections();
	gebi('paidgroup_checkbox_num_freegroups').value = groups.free.length;
	gebi('paidgroup_checkbox_num_paidgroups').value = groups.paid.length;

	if(groups.free.length == 0 && groups.paid.length == 0)
	{
		alert('Please make one or more selections.');
	}
	else if(groups.free.length == 0 && groups.paid.length > 0)
	{
		gebi('join_paid_group_checkboxes_form').submit();
	}
	else
	{
		var btn = gebi('joinpaidgroup_checkout_btn');
		btn.value = 'Please wait...';
		btn.disabled = true;
		for(var i=0; i<groups.free.length; i++)
		{
			var item_number = gebi('paidgroup_checkbox_item_number_' + groups.free[i]).value;
			var group_name = gebi('paidgroup_checkbox_groupname_' + groups.free[i]).value;
			var user_id = gebi('paidgroup_checkbox_userid_' + groups.free[i]).value;
			gebi('joinpaidgroup_output').innerHTML += '<div id="joining_output_' + item_number + '">Joining for free: ' + group_name + ' (' + item_number + ')...</div>';

			var url_to_get = '$ENV{SCRIPT_NAME}?action=ajaxjoinfreepaidgroup&itemnum=' + item_number + '&uid=' + user_id;
			do_ajax_request(url_to_get, join_free_paid_group__finish);
		}
	}
}

// A "free paid group" is a paid group with a promo code that brings its price to zero.
function join_free_paid_group__finish(req_output)
{
	gebi('paidgroup_checkbox_num_freegroups').value--;

	var vars = getvars(req_output);
	if(req_output.match(/success=1/))
	{
		gebi('joining_output_' + vars.item_number).innerHTML += ' done.';
	}
	else
	{
		gebi('joining_output_' + vars.item_number).innerHTML += ' failed; ' + req_output;
	}

	if(gebi('paidgroup_checkbox_num_freegroups').value == 0)
	{
		if(gebi('paidgroup_checkbox_num_paidgroups').value > 0)
		{
			gebi('joinpaidgroup_output').innerHTML += '<br /><br />Joined free group(s); now redirecting to PayPal to join paid group(s)...<br /><br />';
			window.setTimeout("gebi('join_paid_group_checkboxes_form').submit()", 5000);
		}
		else
		{
			gebi('joinpaidgroup_output').innerHTML += '$TEXT{join_free_paid_groups_done_message}';
		}
	}
}

function hide_element(elname)
{
	var theel = gebi(elname);
	if(theel)
	{
		replace_required_classnames_with_placeholders(theel);
		theel.style.position = 'absolute';
		theel.style.left = '-8000px';
		theel.style.overflow = 'hidden';
		theel.style.height = '0';
		//theel.style.display = 'none'; // display:none on the upload form will cause Safari to fail to upload the file(s).
	}
}

function show_element(elname)
{
	var theel = gebi(elname);
	if(theel)
	{
		restore_required_classnames_from_placeholders(theel);
		theel.style.position = 'relative';
		theel.style.left = '0';
		theel.style.overflow = 'visible'; // or 'auto' ?
		theel.style.height = 'auto';
		//theel.style.display = 'block';
	}
}

function schedule_onclick_action(theel,newfunc)
{
	var oldfunc = (theel.onclick) ? theel.onclick : function () {};
	theel.onclick = function () { oldfunc(); newfunc() };
}

function schedule_onchange_action(theel,newfunc)
{
	var oldfunc = (theel.onchange) ? theel.onchange : function () {};
	theel.onchange = function () { oldfunc(); newfunc() };
}

function schedule_onfocus_action(theel,newfunc)
{
	var oldfunc = (theel.onfocus) ? theel.onfocus : function () {};
	theel.onfocus = function () { oldfunc(); newfunc() };
}

function schedule_onblur_action(theel,newfunc)
{
	var oldfunc = (theel.onblur) ? theel.onblur : function () {};
	theel.onblur = function () { oldfunc(); newfunc() };
}

function update_finalprice(j)
{
	var finalprice = gebi('varprice_' + j).value;
	finalprice = finalprice.replace(/[^\\d\\.]/g, '');
	if(gebi('final_price'))
		gebi('final_price').value = finalprice;
	if(gebi('final_price_alt'))
		gebi('final_price_alt').value = finalprice;
}

function delete_selected_accounts(elname)
{
	if(!gebi(elname))
		return;

	var inputs = gebi(elname).getElementsByTagName("input");
	var toDelete = [];
	for(i = 0; i < inputs.length; i++)
		if(inputs[i].type = 'checkbox')
			if(inputs[i].checked)
			{
				var uid = inputs[i].id.match(/(\\d+)\$/)[1];
				toDelete.push(uid);
			}

	confirmed = 0;
	var msg = "$TEXT{delete_users_confirmation}";
	msg = msg.replace(/%%num%%/, toDelete.length);
	if(toDelete.length > 0)	{ confirmed = window.confirm(msg); }
	else { alert("$TEXT{no_users_selected}"); }

	if(confirmed)
	{
		//overlay_msg("A", "append", "autohide", 'OK then!!');
		//console.log(toDelete);
		var url_to_get = '$ENV{SCRIPT_NAME}?action=ajaxdeleteusers&uids=' + toDelete.join('-');
		do_ajax_request(url_to_get, delete_selected_accounts__finish);
	}
}

function delete_selected_accounts__finish(req_output)
{
	if(req_output.match(/acct_deletion_result=/))
	{
		var rawdata = req_output.match(/acct_deletion_result=num_deleted=(\\d+):::::num_failed=(\\d+):::::deleted_uids=([\\d-]*):::::msg=(.*)/);
		var num_deleted = rawdata[1];
		var num_failed = rawdata[2];
		var deleted_uids = rawdata[3];
		var msg = rawdata[4];
		if(deleted_uids)
		{
			var uids = deleted_uids.split('-');
			for(var i=0; i<uids.length; i++)
			{
				var parent_row_id = 'ub-uid-' + uids[i];
				var parent_row = gebi(parent_row_id);
				parent_row.parentNode.removeChild(parent_row);
			}

			retag_even_and_odd_rows('showusers', 'tr');
		}
		//overlay_msg("A", "append", "nohide", "Successful deletion: " + msg);
		overlay_msg("A", "append", "nohide", msg);
	}
	else
	{
		overlay_msg("A", "append", "nohide", "Error: invalid output from deletion attempt: " + req_output);
	}
}

function cycle_filter_ops(elname)
{
	var op = gebi(elname + 'op');
	var btn = gebi(elname + 'op_btn');
	if(op.value == 'eq') {
		op.value = 'ne';
		btn.innerHTML = '&#8800;';
	}
	else if(op.value == 'ne') {
		op.value = 'gt';
		btn.innerHTML = '&gt;';
	}
	else if(op.value == 'gt') {
		op.value = 'lt';
		btn.innerHTML = '&lt;';
	}
	else if(op.value == 'lt') {
		op.value = 'eq';
		btn.innerHTML = '=';
	}
}

function pagelock_popup(file,groups_allowed)
{
	var div = document.createElement("div");
	div.className = "encpopup ub_lock_popup pagelock_groups_popup";
	div.id = "encpopup";

	var allowed = groups_allowed.split(',');
	var groups_html = '';
	var groups = gebi("lockgroups").value.split(',');
	for(var i=0; i<groups.length; i++) {
		var checked = allowed.indexOf(groups[i]) != -1 ? 'checked="checked"' : '';
		groups_html += '<input type="checkbox" id="checkbox_' + groups[i] + '" value="' + groups[i] + '" ' + checked + ' />' + 
				'<label for="checkbox_' + groups[i] + '">' + groups[i] + '</label><br />' + "\\n";
	}

	div.innerHTML = '<div class="encpopup_inner">' + 
			'<p>$TEXT{pagelock_popup_instructions}</p>' +
			'<form id="pagelock_groups_form">' + "\\n" +
			groups_html +
			'<input type="button" id="pagelock_groups_OK_btn" value="Save" />' +
			'<input type="button" id="pagelock_groups_cancel_btn" value="Cancel" />' +
			'</form>' + "\\n" +
			'</div>';

	document.body.appendChild(div);
	gebi('pagelock_groups_OK_btn').onclick = function(){ pagelock_popup___finish(file) };
	gebi('pagelock_groups_cancel_btn').onclick = function(){ document.body.removeChild(gebi("encpopup")) };
}

function pagelock_popup___finish(file)
{
	var inputs = gebi('pagelock_groups_form').getElementsByTagName("input");
	var groups = [];
	for(i = 0; i < inputs.length; i++)
		if(inputs[i].type == 'checkbox')
			if(inputs[i].checked)
				groups.push(inputs[i].value);

	document.body.removeChild(gebi("encpopup"));
	location.href = "$ENV{SCRIPT_NAME}?action=pagelock&file=" + file + "&groupsallowed=" + groups.join();
}

function dirlock_popup(dir,dir_num,groups_allowed,excl_exts)
{
	var div = document.createElement("div");
	div.className = "encpopup ub_lock_popup dirlock_groups_popup";
	div.id = "encpopup";

	var allowed = groups_allowed.split(',');
	var groups_html = '';
	var groups = gebi("lockgroups").value.split(',');
	for(var i=0; i<groups.length; i++) {
		var checked = allowed.indexOf(groups[i]) != -1 ? 'checked="checked"' : '';
		groups_html += '<input type="checkbox" id="checkbox_' + groups[i] + '" value="' + groups[i] + '" ' + checked + ' />' + 
				'<label for="checkbox_' + groups[i] + '">' + groups[i] + '</label><br />' + "\\n";
	}

	div.innerHTML = '<div class="encpopup_inner">' + 
			'<p>$TEXT{dirlock_popup_instructions}</p>' +
			'<form id="dirlock_groups_form">' + "\\n" +
			groups_html +
			'<p>$TEXT{dirlock_excluded_extension_instructions}</p>' +
			'<input type="text" id="dirlock_excl_exts" value="' + excl_exts + '" />' +
			'<input type="hidden" id="dirlock_dir_num" value="' + dir_num + '" />' +
			'<input type="button" id="dirlock_groups_OK_btn" value="Save" />' +
			'<input type="button" id="dirlock_groups_cancel_btn" value="Cancel" />' +
			'</form>' + "\\n" +
			'</div>';

	document.body.appendChild(div);
	gebi('dirlock_groups_OK_btn').onclick = function(){ dirlock_popup___finish(dir) };
	gebi('dirlock_groups_cancel_btn').onclick = function(){ document.body.removeChild(gebi("encpopup")) };
}

function dirlock_popup___finish(dir)
{
	var inputs = gebi('dirlock_groups_form').getElementsByTagName("input");
	var groups = [];
	for(i = 0; i < inputs.length; i++)
		if(inputs[i].type == 'checkbox')
			if(inputs[i].checked)
				groups.push(inputs[i].value);

	var dir_num = gebi('dirlock_dir_num').value;
	var excl_exts = gebi('dirlock_excl_exts').value.replace(/ /g, '');

	document.body.removeChild(gebi("encpopup"));
	location.href = "$ENV{SCRIPT_NAME}?action=dirlock_lock&dir=" + dir + "&groupsallowed=" + groups.join() + "&dir_num=" + dir_num + "&excl_exts=" + excl_exts;
}



schedule_onload_action(focus_username_field);
schedule_onload_action(set_up_human_test);
schedule_onload_action(monitor_pw_field);

`;

return $js;

}


sub print_html_footer_for_bare_script___nomore
{
	print "\n</div>\n</div>\n</body>\n</html>\n";
}


sub do_app_init()
{
	$PREF{internal_appname_nice}	= 'UserBase';
	$PREF{internal_appname}		= 'userbase';
	$PREF{internal_filename}	= 'userbase';
	$PREF{twochar_app_id}		= 'ub';


	do_preinit();


	verify_server_environment();
	fix_server_environment();


	# Pre-PREF init stuff: default PREF values, etc.
	#
	populate_month_conversion_hashes();
	$PREF{logout_url} = "$ENV{SCRIPT_NAME}?ublogout";
	$PREF{logoutcookie_url} = "$ENV{SCRIPT_NAME}?logoutcookie";
	$PREF{submitbutton_id} = "ub_userform_btn";


	load_hashing_module();
	set_default_prefs_for_all_apps();
	check_for_enc_visitor_id();
	load_external_prefs();
	load_other_prefs_files();


	settle_docroot_datadir_cgimodule_etc();
	cache_and_read_any_nonpost_env_vars();


	# Webconfig must happen after datadir is settled, since it needs to read/write there:
	#
	load_webconfig_prefs();


	figure_out_where_here_is();
	determine_cookie_domain();


	# Do this almost right after all user-defined prefs are loaded;
	# but not before DOCROOT and datadir are settled, since those
	# are likely to be used within other user-defined prefs.
	#
	expand_custom_vars_in_prefs();


	# Load UserBase prefs after settling DOCROOT in case we used
	# %PREF{DOCROOT} in the path to the UserBase prefs file.
	#
	load_userbase_prefs();


	# Now all prefs are loaded.
	#
	do_postpref_processing();
	($PREF{ip}, $PREF{host}) = get_ip_and_host();
	do_blacklisting_and_whitelisting();
	set_table_names();


	set_protoprefix_www_https_etc();


	if(   $PREF{enable_debug} =~ /yes/i   &&   ($qs =~ /debug/ || $ENV{REQUEST_METHOD} =~ /post/i)   )
	{
		$PREF{debug} = 1;
	}


	if($PREF{admin_password_hash_01})
	{
		my $hashbase = ($PREF{admin_password_hash_01} =~ /(.+)v.+/)[0] or exit_with_error qq`Invalid password hash for admin_password_hash_01.`;   # no need to support older formats in UB.
		$PREF{"all_admin_password_hashes"}{$PREF{admin_password_hash_01}} = 1;
		$PREF{"all_admin_password_hash_bases"}{$hashbase} = 1;
	}


	try_to_load_image_modules();


	for($PREF{here_static})
	{
		$_ = $PREF{login_url} unless ($_ && $_ ne $ENV{SCRIPT_NAME});
		$_ = '/cgi-bin/userbase.cgi' unless /./;
	}

	
	# old database user/pass pref checking was here.

	$PREF{default_account_temp_file}			= $PREF{datadir} . '/README-then-DELETEME.txt';

	$PREF{peraccount_salt_length}				= 40 unless exists $PREF{peraccount_salt_length};
	$PREF{max_salt_length}					= 255 unless exists $PREF{max_salt_length};
	$PREF{usernames_are_immutable_once_created}		||= 'yes'; # Do not change this.
	$PREF{groupnames_are_immutable_once_created}		||= 'yes'; # Do not change this.
	$PREF{groups_allowed_to_change_usernames}		||= 'admin';
	$PREF{groups_allowed_to_change_groupnames}		||= 'admin';

	$PREF{app_email_address}				= 'userbase@'.($ENV{HTTP_HOST} =~ /^(www\.)?([^:]+)/)[1] if $PREF{app_email_address} eq 'userbase@example.com';
	$PREF{payment_notification_email_recipients}		= $PREF{webmaster_email_address} unless $PREF{payment_notification_email_recipients};

	$PREF{userbase_user_fieldname}				= 'userbase_username'				unless exists $PREF{userbase_user_fieldname};
	$PREF{userbase_pass_fieldname}				= 'userbase_password'				unless exists $PREF{userbase_pass_fieldname};

	$PREF{event_calendar_reminderlog_table} = $PREF{event_calendar_table} . '_reminderlog';


	$PREF{default_profile_image}				||= $PREF{DOCROOT} . $PREF{app_images_url} . '/profile_default.jpg';
	$PREF{profile_images_folder_url}			= $PREF{appdir_url} . "/profile_images";
	$PREF{profile_images_folder_real}			= $PREF{appdir_real} . "/profile_images";
	create_dir_if_DNE($PREF{profile_images_folder_real},$PREF{writable_dir_perms},'make_parents');


	setup_profile_image_thumbnail_prefs();


	# Stuff that must happen before we process the ?js command:
	#
	if($PREF{enable_human_test} =~ /yes/i)
	{
		if(image_humantest_possible())
		{
			condense_slashes('leave_leading_UNC', $PREF{human_test_image_directory___real});
			$PREF{human_test_image_directory___real} = enc_untaint($PREF{human_test_image_directory___real}, 'keep_path');

			create_dir_if_DNE($PREF{human_test_image_directory___real}, $PREF{writable_dir_perms}, 'make_parents');
			die_nice("\$PREF{human_test_image_directory___real} ('$PREF{human_test_image_directory___real}') does not exist; you must create it.") unless -d "$PREF{human_test_image_directory___real}";
			die_nice("\$PREF{human_test_image_directory___real} ('$PREF{human_test_image_directory___real}') is not writable; you must chmod it to world-writable or 0777.") unless -w "$PREF{human_test_image_directory___real}";

			$PREF{human_test_salt_value} = enc_untaint($PREF{human_test_salt_value});
			($PREF{humantest_code}) = (rand() =~ /(\d{$PREF{human_test_num_digits}})/);
			$PREF{humantest_hash} = sha256_hex($PREF{humantest_code} . $PREF{human_test_salt_value});
			printd "humantest_code=$PREF{humantest_code}, humantest_hash=$PREF{humantest_hash}, human_test_salt_value=$PREF{human_test_salt_value}";
		}
		else
		{
			die_nice qq`
			In order to use the human-test feature, you must enable one of the following settings:
			<br /><br />\n\$PREF{try_to_use_imagemagick_for_humantest} 
			<br /><br />\n\$PREF{try_to_use_gd_for_humantest}
			<br /><br />\n\$PREF{try_to_use_convert_for_humantest} 
			<br /><br />\nYou must also have either the ImageMagick Perl module installed 
			(it is ` . (imagemagick_is_available() ? '' : 'not ') . qq`currently installed), 
			<br /><br />\nor the GD and GD::Simple Perl modules installed 
			(they are ` . (gd_is_available() ? '' : 'not ') . qq`currently installed),
			<br /><br />\nor you must have ImageMagick's "convert" program available and set \$PREF{convert_command} to its path.
			`;
		}
	}


	# Do any actions that are independent of, or that must occur before, check_if_logged_in().
	#
	if($qs eq 'logoutcookie' || get_qs_var('action') eq 'logoutcookie')
	{
		expand_custom_vars_in_prefs('include_undefined');
		delete_login_cookie();
		enc_redirect("$PREF{login_url_qsready}action=loggedout");
	}
	elsif($qs eq 'js'   ||   $qs =~ /action=justjs/)
	{
		create_human_test_image($PREF{humantest_code},$PREF{humantest_hash}) if $PREF{enable_human_test} =~ /yes/i;
		expand_custom_vars_in_prefs('include_undefined');
		print "Content-type: text/javascript\n\n"; print get_js(); exit;
	}
	elsif($qs eq 'css'   ||   $qs =~ /action=justcss/)
	{
		expand_custom_vars_in_prefs('include_undefined');
		print "Content-type: text/css\n\n"; print get_css(); exit;
	}
	elsif($qs =~ /(?:^|&)phase=eacctpndpmt(?:&|$)/)
	{
		expand_custom_vars_in_prefs(\%PREF, 'include_undefined');
		redirect_to_payment_page();
	}
	elsif($qs =~ /(?:^|&)phase=(eacctdis|eacctlimit|eipmismatch|eacctpndvrf|eacctpndadm)(?:&|$)/)
	{
		# These are all login-related errors that will result in an infinite redirection
		# loop unless we catch them & exit here, before check_if_logged_in() happens.

		expand_custom_vars_in_prefs('include_undefined');
		exit_with_error(get_message($1));
	}


	do_early_kmsg_check();
	do_setup_and_dispatch_for_encauth_and_db();
	setup_database_prefs() if $QS{action} eq 'dbsetup';   # need a separate QS arg in the main dispatch chain (ubdbsetup) for use by UB admins in non-encauth mode, since at this point, we don't yet have a DB connection, so can't check for UB admin login.
	get_db_connection();
	create_tables_if_DNE();
	create_initial_admin_account();


	if($MISC{this_is_the_firstrun})
	{
		$MISC{num_accounts_at_firstrun} = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}`");
		applog("num_accounts_at_firstrun=$MISC{num_accounts_at_firstrun}");
	}
	encdebug qq`firstrun=$MISC{firstrun}, this_is_the_firstrun=$MISC{this_is_the_firstrun}, num_accounts_at_firstrun=$MISC{num_accounts_at_firstrun}`;


	# Must occur before check_if_logged_in():
	#
	#$PREF{show_builtin_fields_in_this_section_id} ||= enc_sql_select("SELECT MIN(`id`) FROM `$PREF{field_sections_table}`") || 1;
	#
	# Show the builtin fields in the first section as sorted by position, not by ID, so the user has some control over it.
	#
	$PREF{show_builtin_fields_in_this_section_id} ||= enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}` ORDER BY `section_position` LIMIT 1") || 1;


	check_if_logged_in();
	applog_ub_account_logins();
	check_for_admin_alerts();


	# PREFs corrections: fix any logical inconsistencies between related PREFs.
	#
	if($PREF{require_email_verification_for_new_signups} =~ /yes/i   &&   !(($PREF{use_builtin_email_field} =~ /yes/i && $PREF{email_field_required_during_signup} =~ /yes/i) || $PREF{usernames_must_be_email_addresses} =~ /yes/i)) { die_nice(qq`Error: since you have \$PREF{require_email_verification_for_new_signups} enabled, then you must also enable either: <br /><br />\$PREF{use_builtin_email_field} and \$PREF{email_field_required_during_signup} <br /><br />...or else: <br /><br />\$PREF{usernames_must_be_email_addresses}`); };


	# TODO: this is probably correct (i.e., uncomment it):
	#$PREF{tables_listing_fields_whose_structure_we_manage}{   $PREF{custom_field_list_table}   } = 1;


	# We're done processing prefs now, so expand all %PREF{foo}s, including undefined ones:
	#
	expand_custom_vars_in_prefs('include_undefined');


	update_static_css_and_js_files();


	create_periodic_task({ name => 'check_for_expired_memberships', enabled => 'yes', period => 60*60*1 });   # "60*60*1" is 1 hour, necessary now that we support membership lengths as small as 1 hour.
	check_for_expired_group_memberships() if it_is_time_for_periodic_task('check_for_expired_memberships');


	create_periodic_task({ name => 'activate_and_deactivate_promo_codes', enabled => 'yes', period => 60*60*6 });   # "60*60*6" is 6 hours.
	activate_and_deactivate_promo_codes() if it_is_time_for_periodic_task('activate_and_deactivate_promo_codes');
}


sub start_html_output
{
	start_html_output_std(@_);
}


sub finish_html_output
{
	finish_html_output_std(@_);
}


sub applog_ub_account_logins
{
	if($PREF{member_is_logged_in}   &&   !$MISC{a_userbase_account_has_logged_in_at_some_point})
	{
		$MISC{a_userbase_account_has_logged_in_at_some_point} = 1;
		applog('a_userbase_account_has_logged_in_at_some_point');
	}
	if($PREF{member_is_logged_in}   &&   !$PREF{admin_is_logged_in}   &&   !$MISC{a_userbase_nonadmin_has_logged_in_at_some_point})
	{
		$MISC{a_userbase_nonadmin_has_logged_in_at_some_point} = 1;
		applog('a_userbase_nonadmin_has_logged_in_at_some_point');
	}
	if($PREF{admin_is_logged_in}   &&   !$MISC{a_userbase_admin_has_logged_in_at_some_point})
	{
		$MISC{a_userbase_admin_has_logged_in_at_some_point} = 1;
		applog('a_userbase_admin_has_logged_in_at_some_point');
	}
}


sub get_random_number()
{
	my $ip = $PREF{ip};
	$ip =~ s/\.//g;
	my $time = time();
	my $rand = int(rand(999999)); # random int from 1 to 999999.

	my $random_num = $ip * $time * $rand;

	# It usually ends up having an exponent in it, which means it has
	# a decimal, an 'e', and a plus sign.  So remove them.
	$random_num =~ s/[\.e\+]//gi;

	return $random_num;
}


sub delete_users_ajax($)
{
	my $uids = shift;
	my ($num_deleted, $num_failed, @deleted_uids, @deleted_usernames, @failed_usernames, @errors) = (0, 0, (), (), (), ());

	foreach my $uid (split(/-/, $uids))
	{
		#my @errs = ("Justa test; skipping user $uid");
		my $username = get_user_name($uid);
		my @errs = delete_user($uid, 1);
		if(@errs)
		{
			$num_failed++;
			push(@errors, @errs);
			push(@failed_usernames, $username) if $username;
		}
		else
		{
			$num_deleted++;
			push(@deleted_uids, $uid);
			push(@deleted_usernames, $username);
		}
	}

	my $msg = $num_deleted == 1 ? "1 account deleted: " : "$num_deleted accounts deleted: ";
	$msg .= scalar @deleted_usernames <= 30 ? join(", ", @deleted_usernames) : join(", ", @deleted_usernames[0..29]) . '...';
	if($num_failed)
	{
		$msg .= '<br /><br />' . ($num_failed == 1 ? '1 failure: ' : " $num_failed failures: ");
		$msg .= join(", ", @failed_usernames);
		$msg .= "<br /><br />Errors: <br /><br />" . join("<br /><br />", @errors);
	}

	return ($num_deleted, $num_failed, $msg, join('-', @deleted_uids));
}


# Batchmode: returns an empty array on success, or an array of errors on failure.
# Non-batchmode: redirects to Manage Users on success; dies on error.
sub delete_user($$)
{
	my $user_id = shift;
	my $batchmode = shift;

	my $userid_valid = is_numeric($user_id);

	my $access_granted = (
		(user_is_allowed_to($PREF{logged_in_userid}, 'delete_user_accounts')   &&   !is_admin_acct($user_id))
		||
		(user_is_allowed_to($PREF{logged_in_userid}, 'delete_admin_accounts')   &&   is_admin_acct($user_id))
		||
		(logged_in_user_is_subgroup_manager()   &&   logged_in_subgroup_manager_owns_this_user($user_id))
	);

	my $username = get_user_name($user_id);
	my $not_deleting_self = $username ne $PREF{logged_in_username};

	my $userid_error	= "Error: non-numeric user ID '$user_id'.";
	my $access_error	= $TEXT{Access_denied_};
	my $self_error		= "Error: you can't delete yourself while you're logged in!";

	$userid_valid		|| ($batchmode ? return ($userid_error) : die_nice $userid_error);
	$access_granted		|| ($batchmode ? return ($access_error) : die_nice $access_error);
	$not_deleting_self	|| ($batchmode ? return ($self_error) : die_nice $self_error);


	my $user_exists = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $user_id");
	my $exists_error = "Error: account #$user_id does not exist.";
	$user_exists || ($batchmode ? return ($exists_error) : die_nice $exists_error);

	my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{user_table}` WHERE `id` = $user_id");
	my $retval = $sth->execute();
	my $success = $retval !~ /^(0|0E0)$/;   # execute() returns '0E0' if no rows were affected by the statement.
	my $db_error = "Couldn't delete user '$username' (id=$user_id) from user table. (DB returned '$retval') $DBI::errstr\n";
	$success || ($batchmode ? return ($db_error) : die_nice $db_error);


	my @errors = remove_user_from_all_groups($user_id, $username, $batchmode);

	if($batchmode)	{ return @errors; }
	else		{ @errors ? die_nice(join("<br /><br />\n", @errors)) : enc_redirect("$PREF{login_url}?action=showusers"); }
}


# Batchmode: returns either an array of errors, or an empty array on success.
# Non-batchmode: dies on error; returns empty array on success.
sub remove_user_from_all_groups($$$)
{
	my $user_id = shift;
	my $username = shift;   # necessary even though it seems redundant because we can't look it up after the record's been deleted from the user table.
	my $batchmode = shift;
	die_unless_numeric($user_id, 'User ID');
	my $groups = get_groups_hash($user_id);
	my @errors = ();
	foreach my $group (sort keys %$groups)
	{
		next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
		my $reason = 'user account deleted';
		my @errs = remove_user_from_group($user_id, $group, $reason, $username, $batchmode) if $$groups{$group}{is_member};
		push(@errors, @errs) if @errs;
	}
	return $batchmode ? @errors : @errors ? die_nice(join("<br /><br />\n", @errors)) : ();
}


sub show_results_page
{
	my $m = '';

	if($qs =~ /^rslt=100&?(&uid=\d*&?)?$/)	{ $m .= qq`No changes were made. `;													}
	if($qs =~ /($|&)101(&|$)/)		{ $m .= qq`Username successfully changed. `;												}
	if($qs =~ /($|&)103(&|$)/)		{ $m .= qq`Password successfully changed.&nbsp; Now you must <a href="$PREF{login_url}">login again</a>. `;				}
	if($qs =~ /($|&)113(&|$)/)		{ $m .= qq`Password successfully changed. `;												}
	if($qs =~ /($|&)105(&|$)/)		{ $m .= qq`Real name successfully changed. `;												}
	if($qs =~ /($|&)107(&|$)/)		{ $m .= qq`Email address successfully changed. `;											}

	# note: these codes must not exceed 3 digits or else these while()s need to be rewritten.
	while($qs =~ /109(.+?)(&|$)/g)		{ $m .= qq`Removed user from group '` . enc_urldecode_return($1) . qq`'.<br />`;												}
	while($qs =~ /111(.+?)(&|$)/g)		{ $m .= qq`Added user to group '` . enc_urldecode_return($1) . qq`'.<br />`;													}
	while($qs =~ /137(.+?)(&|$)/g)		{ $m .= qq`Field '$1' updated successfully.<br />`;													}

	# old format, no longer used:
	#if($qs =~ /($|&)121(&|$)/)		{ $m .= qq`Group name successfully changed. `;												}
	#if($qs =~ /($|&)123(&|$)/)		{ $m .= qq`Group description successfully changed. `;											}
	#if($qs =~ /($|&)122(&|$)/)		{ $m .= qq`Group name not updated because the entered name is not valid.</p><p>$PREF{invalid_groupname_message} `;			}
	#if($qs =~ /($|&)124(&|$)/)		{ $m .= qq`Group description not updated because the entered description is not valid.</p><p>$PREF{invalid_groupdesc_message} `;	}

	if($qs =~ /($|&)125(&|$)/)		{ $m .= qq`Account locked successfully. `;												}
	if($qs =~ /($|&)127(&|$)/)		{ $m .= qq`Account unlocked successfully. `;												}
	if($qs =~ /($|&)129(&|$)/)		{ $m .= qq`Account disabled successfully. `;												}
	if($qs =~ /($|&)131(&|$)/)		{ $m .= qq`Account enabled successfully. `;												}
	if($qs =~ /($|&)133(&|$)/)		{ $m .= qq`Force-password-change enabled successfully. `;										}
	if($qs =~ /($|&)135(&|$)/)		{ $m .= qq`Force-password-change disabled successfully. `;										}

	if($qs =~ /($|&)102(&|$)/)		{ $m .= qq`Username not changed because the entered username is not valid.</p><p>$PREF{invalid_username_message} `;			}
	if($qs =~ /($|&)104(&|$)/)		{ $m .= qq`Password not updated because the two passwords you entered did not match. `;							}
	if($qs =~ /($|&)106(&|$)/)		{ $m .= qq`Real name not updated because the entered name is not valid.</p><p>$PREF{invalid_realname_message} `;			}
	if($qs =~ /($|&)108(&|$)/)		{ $m .= qq`Email address not updated because the entered address is not valid. `;							}
	if($qs =~ /($|&)114(&|$)/)		{ $m .= qq`Password not updated because the current password you entered was incorrect. `;						}
	if($qs =~ /($|&)116(&|$)/)		{ $m .= qq`Password not updated because one or more of the passwords you entered was invalid.</p><p>$PREF{invalid_password_message} `;	}

	$m .= qq`<br /><br /><a href="$PREF{login_url}?action=edituser&amp;id=$QS{uid}">View Account</a>?` if $QS{uid} =~ /^\d+$/;

	exit_with_notice($m);
}


sub get_message
{
	my $phase = shift;
	my $m = '';

	if($TEXT{messages}{$phase})	{ $m = $TEXT{messages}{$phase}; }
	else				{ $m .= qq`Invalid phase.`; }

	$m =~ s/%%sqlsafechars%%/$PREF{list_of_sql_safe_characters}/g;
	$m =~ s/%%qs_var_(.+?)%%/get_qs_var($1)/eg;

	return $m;
}


sub show_message
{
	my $phase = shift;
	my $m = '';

	if($TEXT{messages}{$phase})						{ $m = get_message($phase); }
	elsif($phase eq 'esqlsafe'   &&   $qs =~ /(?:^|&)one=(.+?)(?:&|$)/)	{ $m .= qq`$TEXT{Field_contains_non_SQL_safe_characters}: $1\n<br />$TEXT{SQL_safe_characters}: $PREF{list_of_sql_safe_characters}`;	}
	#elsif($phase eq 'spwchg')						{ $m .= qq`Password successfully changed.&nbsp; Now you must <a href="$PREF{login_url}">login again</a>.`;								}
	#elsif($phase eq 'eneedprivs')						{ exit_with_needprivs(); }
	else									{ $m .= qq`Invalid phase.`; }

	do_standard_template_vars_processing($m);

	if($phase =~ /^s/)	{ exit_with_success($m);	}
	else			{ exit_with_error($m);		}
}


#####


# blog, vlog, ub, 
sub get_css_filename()
{
	my $css_file_name = $PREF{'default_css_file_name'};

	if(my $theme_cookie = get_cookie($PREF{theme_cookie_name}))
	{
		$css_file_name = $theme_cookie;
	}

	$css_file_name .= '.css' unless $css_file_name =~ /\.css$/i;

	$css_file_name = "$PREF{'path_to_css_files'}$css_file_name";

	return $css_file_name;
}


#
#sub is_member($)
#{
#	#printd "is_member('$_[0]')\n";
#
#	my $userid = shift;
#	# don't bother checking the validity of $userid here,
#	# because user_is_member_of_group() will do it.
#	return user_is_member_of_group($userid,$PREF{member_group_name});
#}
#


sub group_exists
{
	my $group = shift;
	check_groupname_for_sql_safeness($group);
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
}


# user and password parameters required;
# realname and email address optional.
#
sub add_new_user
{
	my ($user, $hashedpw, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $email_verification_token) = @_;

	my $user			= shift;
	my $hashedpw			= shift;
	my $salt			= shift;
	my $realname			= shift;
	my $email			= shift;

	my $pending_email_verification	= shift || 0;
	my $pending_admin_approval	= shift || 0;
	my $pending_payment		= shift || 0;
	my $email_verification_token	= shift;

	$pending_payment = 1 if $pending_payment;

	my $cdate = offsettime();

	check_username_for_sql_safeness($user);
	check_hashedpw_for_sql_safeness($hashedpw);
	check_salt_for_sql_safeness($salt);
	die_unless_numeric($cdate, "\$cdate in add_new_user");

	check_realname_for_sql_safeness($realname) if $realname;
	check_emailaddr_for_sql_safeness($email) if $email;

	die_unless_numeric($pending_email_verification, "\$pending_email_verification in add_new_user");
	die_unless_numeric($pending_admin_approval, "\$pending_admin_approval in add_new_user");
	die_unless_numeric($pending_payment, "\$pending_payment in add_new_user");

	die_nice("invalid email_verification_token value '$email_verification_token'.") unless $email_verification_token =~ /^\w*$/;

	enc_sql_insert(
		"INSERT INTO `$PREF{user_table}` 
		(`username`, `password`, `salt`, `cdate`, `name`, `email`, `pending_email_verification`, `pending_admin_approval`, `pending_payment`, `email_verification_token`)
		VALUES('$user', '$hashedpw', '$salt', '$cdate', '$realname', '$email', $pending_email_verification, $pending_admin_approval, $pending_payment, '$email_verification_token')
	");

	encdebug("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$user' AND `password` = '$hashedpw' AND `salt` = '$salt' AND `cdate` = '$cdate'");
	my $id = enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$user' AND `password` = '$hashedpw' AND `salt` = '$salt' AND `cdate` = '$cdate'");

	update_password_activity_table($id,$hashedpw,$salt,0);

	return $id;
}


sub add_new_group
{
	my $group = shift;
	my $desc = shift;
	my $mainmenu_title = shift;
	my $mainmenu_position = shift;

	unless($mainmenu_title)
	{
		$mainmenu_title = "$group Links:";
		$mainmenu_title =~ s!^(\w)!\u$1!;
	}

	$mainmenu_position = 1 unless $mainmenu_position;

	check_groupname_for_sql_safeness($group);
	check_groupdesc_for_sql_safeness($desc);
	if($mainmenu_title) { sql_untaint($mainmenu_title); die_unless_sqlsafe($mainmenu_title); }
	if($mainmenu_position) { die_unless_numeric($mainmenu_position,'mainmenu_position'); }

	enc_sql_insert("INSERT INTO `$PREF{group_table}` (`group`, `desc`, `mainmenu_title`, `mainmenu_position`) VALUES('$group', '$desc', '$mainmenu_title', '$mainmenu_position')");
}


sub add_user_to_group
{
	my $user = shift;
	my $group = shift;
	my $reason = shift;   # optional
	return if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

	my $user_id = get_user_id($user);

	check_groupname_for_sql_safeness($group);
	check_ip_address_limit($group);

	my $existing_user_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `group` = '$group'");
	my $new_user_list = $existing_user_list . ',' . $user_id;
	decommaify($new_user_list);

	my $statement = "UPDATE `$PREF{group_table}` SET `members` = '$new_user_list' WHERE `group` = '$group'";
	my $sth = $PREF{dbh}->prepare($statement);
	$sth->execute() or die_nice("$0: add_user_to_group('$user', '$group') failed: $DBI::errstr\n");

	my $group_id = get_group_id($group);
	my $timestamp = offsettime();
	my $changer_userid = $PREF{logged_in_userid} || 0;
	my $ua = $ENV{HTTP_USER_AGENT};
	my $ref = $ENV{HTTP_REFERER};
	my $uri = $PREF{REQ_URI_WITH_QS};
	sql_untaint($ua, $ref, $uri, $reason); die_unless_sqlsafe($ua, $ref, $uri, $reason);

	enc_sql_insert("
		INSERT INTO `$PREF{group_log_table}` (`changer_userid`,`changer_username`,`userid`,`username`,`group_id`,`group_name`,`timestamp`,`date8`,`event`,`reason`,`uri`,`referer`,`ip_address`,`hostname`,`browser`)
					 VALUES($changer_userid, '$PREF{logged_in_username}', $user_id, '$user', $group_id, '$group', $timestamp, $PREF{date8}, 1, '$reason', '$uri', '$ref', '$PREF{ip}', '$PREF{host}', '$ua')
	");

	# If this user previously belonged to a temp group (whether "temporary" or "subscription") and
	# his membership in that group had expired, but he's now re-joined the temp group (or another
	# temp group), then remove him from the built-in "expired" group:
	#
	if(user_is_member_of_group($user_id, $PREF{expired_group_name}, 1) && is_temp_group($group_id))
	{
		remove_user_from_group($user_id, $PREF{expired_group_name}, 'user re-joined a temp/subscription group');
	}

	send_group_membership_update_emailalert('add', $user_id, $group);
}


sub check_ip_address_limit($)
{
	return if is_admin();   # If the admin is calling this sub, then ignore the limit.
	my $group = shift;
	if(my $num_times_one_IP_can_join = enc_sql_select("SELECT `ip_address_limit` FROM `$PREF{group_table}` WHERE `group` = '$group'"))
	{
		my $num_times_this_IP_has_joined = enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_log_table}` WHERE `event`=1 AND `group_name`='$group' AND `ip_address`='$PREF{ip}'");
		exit_with_error qq`$TEXT{ip_address_limit_exceeded_for_group}` if $num_times_this_IP_has_joined >= $num_times_one_IP_can_join;
	}
}


sub add_to_auto_groups($)
{
	my $username = shift;   # caller must verify that username is sqlsafe/valid.
	add_user_to_group($username, $_, 'auto-added at sign-up') for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups}));
	if(my $autogroup = enc_sql_select("SELECT `autogroup` FROM `$PREF{user_table}` WHERE `username` = '$username'"))
	{
		foreach my $pref (sort keys %PREF)
		{
			if($pref =~ /^auto_add_signups_to_groups_from_url_var_(\w+)$/ && $autogroup eq $1 && $PREF{$pref})
			{
				foreach my $group (split(/\s*,\s*/, $PREF{$pref}))
				{
					exit_with_error qq`Error: cannot specify a built-in group (public, member, admin) for auto_add_signups_to_groups_from_url_var.` if is_builtin_group($group);
					exit_with_error qq`Error: group specified in auto_add_signups_to_groups_from_url_var does not exist ("$group").` unless group_exists($group);
					add_user_to_group($username, $group, 'auto-added from URL var at sign-up');
				}
			}
		}
	}
}


# Batchmode: returns either an array of errors, or an empty array on success.
# Non-batchmode: dies on error; returns empty array on success.
sub remove_user_from_group
{
	my $user_id = shift;
	my $group = shift;
	my $reason = shift;
	my $username = shift;   # optional but might be a good idea to make it required.
	my $batchmode = shift;   # optional
	return if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

	check_groupname_for_sql_safeness($group);

	my $user_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `group` = '$group'");
	$user_list =~ s/(^|,)($user_id)(,|$)/$1$3/;
	decommaify($user_list);

	my $statement = "UPDATE `$PREF{group_table}` SET `members` = '$user_list' WHERE `group` = '$group'";
	my $sth = $PREF{dbh}->prepare($statement);
	my $fail_msg = "remove_user_from_group('$user_id', '$group') failed:";
	$sth->execute() or $batchmode ? return ("$fail_msg $DBI::errstr\n") : die_nice("$fail_msg $DBI::errstr\n");
	
	my $group_id = get_group_id($group);
	my $timestamp = offsettime();
	my $ua = $ENV{HTTP_USER_AGENT};
	my $ref = $ENV{HTTP_REFERER};
	my $uri = $PREF{REQ_URI_WITH_QS};
	sql_untaint($ua, $ref, $uri, $reason);
	for($ua, $ref, $uri, $reason)
	{
		if(not_sqlsafe($_))
		{
			$batchmode
			? return ("remove_user_from_group('$user_id', '$group'): removed, but can't log it in group_log_table because var is not SQL-safe: '$_'")
			: die_nice("not SQL-safe: '$_'");
		}
	}
	$username ||= get_user_name($user_id);
	my $changer_userid = $PREF{logged_in_userid} || 0;

	# TODO: at least for remove_user_from_group(), possily for all inserts into group_log_table:
	# When this insert occurs, the changer_userid/username are sometimes wrong.  In particular,
	# when it's a removal due to check_for_expired_group_memberships(), those occur as scheduled
	# tasks even when non-admins visit the script, in which case the "changer" is any random
	# member who happens to be logged in at the time that it_is_time_for_X() returns true.
	enc_sql_insert("
		INSERT INTO `$PREF{group_log_table}` (`changer_userid`,`changer_username`,`userid`,`username`,`group_id`,`group_name`,`timestamp`,`date8`,`event`,`reason`,`uri`,`referer`,`ip_address`,`hostname`,`browser`)
					 VALUES($changer_userid, '$PREF{logged_in_username}', $user_id, '$username', $group_id, '$group', $timestamp, $PREF{date8}, 0, '$reason', '$uri', '$ref', '$PREF{ip}', '$PREF{host}', '$ua')
	");

	my @errors = send_group_membership_update_emailalert('remove', $user_id, $group, $username, $batchmode);
	return $batchmode ? @errors : @errors ? die_nice(join("<br /><br />\n", @errors)) : ();
}


sub add_all_users_to_group
{
	exit_with_needprivs() unless user_is_allowed_to('change_group_memberships');

	my $gid = shift;
	my $group = get_group_name($gid);
	exit_with_error qq`Error: can't add all users to that group.` if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

	my $all_uids = '';
	my $members = get_users_belonging_to_group({ group=>$PREF{member_group_name}, exclude_pending=>1 });
	foreach my $uid (keys %$members)
	{
		$all_uids .= $uid . ',';
	}
	$all_uids =~ s!,$!!;   # strip the trailing comma.

	my $success = enc_sql_update("UPDATE `$PREF{group_table}` SET `members` = '$all_uids' WHERE `id` = '$gid'");
	die_nice(qq`SQL returned "$success" instead of 1 while updating "members" to add all UIDs.`) unless $success > 0;

	my $ua = $ENV{HTTP_USER_AGENT};
	my $ref = $ENV{HTTP_REFERER};
	my $uri = $PREF{REQ_URI_WITH_QS};
	sql_untaint($ua, $ref, $uri); die_unless_sqlsafe($ua, $ref, $uri);
	my $timestamp = offsettime();
	my $changer_userid = $PREF{logged_in_userid} || 0;

	foreach my $uid (keys %$members)
	{
		my $user = get_user_name($uid);
		enc_sql_insert("
			INSERT INTO `$PREF{group_log_table}` (`changer_userid`,`changer_username`,`userid`,`username`,`group_id`,`group_name`,`timestamp`,`date8`,`event`,`uri`,`referer`,`ip_address`,`hostname`,`browser`)
						 VALUES($changer_userid, '$PREF{logged_in_username}', $uid, '$user', $gid, '$group', $timestamp, $PREF{date8}, 1, '$uri', '$ref', '$PREF{ip}', '$PREF{host}', '$ua')
		");
	}

	send_group_membership_update_emailalert('add', 'all', $group);
	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=groups");
}


sub remove_all_users_from_group
{
	exit_with_needprivs() unless user_is_allowed_to('change_group_memberships');

	my $gid = shift;
	my $group = get_group_name($gid);
	exit_with_error qq`Error: can't remove all users from that group.` if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

	my $old_uids_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `id` = $gid");

	# If it's the admin group, remove all users except the logged-in user:
	my $uids = $group eq $PREF{admin_group_name} ? $PREF{logged_in_userid} : '';

	my $success = enc_sql_update("UPDATE `$PREF{group_table}` SET `members` = '$uids' WHERE `id` = '$gid'");
	die_nice(qq`SQL returned "$success" instead of 1 while updating "members" to remove all UIDs.`) unless $success > 0;

	my $ua = $ENV{HTTP_USER_AGENT};
	my $ref = $ENV{HTTP_REFERER};
	my $uri = $PREF{REQ_URI_WITH_QS};
	sql_untaint($ua, $ref, $uri); die_unless_sqlsafe($ua, $ref, $uri);
	my $timestamp = offsettime();
	my $changer_userid = $PREF{logged_in_userid} || 0;

	foreach my $uid (split(/,/, $old_uids_list))
	{
		my $user = get_user_name($uid);
		enc_sql_insert("
			INSERT INTO `$PREF{group_log_table}` (`changer_userid`,`changer_username`,`userid`,`username`,`group_id`,`group_name`,`timestamp`,`date8`,`event`,`uri`,`referer`,`ip_address`,`hostname`,`browser`)
						 VALUES($changer_userid, '$PREF{logged_in_username}', $uid, '$user', $gid, '$group', $timestamp, $PREF{date8}, 0, '$uri', '$ref', '$PREF{ip}', '$PREF{host}', '$ua')
		");
	}

	send_group_membership_update_emailalert('remove', 'all', $group);
	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=groups");
}


sub get_group_manager_ids($)
{
	my $group_id = shift;
	die_unless_numeric($group_id, "group ID");
	return enc_sql_select("SELECT `managers` from `$PREF{group_table}` WHERE `id` = $group_id");
}


# Batchmode: returns either an array of errors, or an empty array on success.
# Non-batchmode: dies on error; returns empty array on success.
sub send_group_membership_update_emailalert
{
	return unless $PREF{group_membership_update_emailalert_enabled} =~ /yes/i;

	my ($action, $user_id, $group, $user, $batchmode) = @_;   # $user and $batchmode are optional
	my $allusers	= 1 if $user_id eq 'all';
	my $username	= $allusers ? '' : $user ? $user : get_user_name($user_id);
	my $realname	= $allusers ? '' : get_real_name($user_id);
	my $email	= $allusers ? '' : get_email_address($user_id);
	
	my $subject	= $PREF{group_membership_update_emailalert_subject};
	my $body	= $allusers ? $PREF{group_membership_update_emailalert_all_body} : $PREF{group_membership_update_emailalert_body};
	
	for($subject, $body)
	{
		s!%%realname%%!$realname!g;
		s!%%username%%!$username!g;
		s!%%user_id%%!$user_id!g;
		s!%%group%%!$group!g;
		s!%%email%%!$email!g;
		s!%%userinfo_url%%!$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=edituser&id=$user_id!g;
		s!%%added_to_or_removed_from%%!$action eq 'add' ? $PREF{group_membership_update_emailalert_added_text} : $PREF{group_membership_update_emailalert_removed_text}!eg;
	}
	
	my @recipients = ();
	foreach my $recipient (split(/\s*,\s*/, $PREF{group_membership_update_emailalert_recipients}))
	{
		if($recipient eq 'managers')
		{
			foreach my $manager_id (split(/\|\|\|/, get_group_manager_ids(get_group_id($group))))
			{
				push (@recipients, get_email_address($manager_id));
			}
		}
		elsif(is_valid_email_address($recipient))
		{
			push @recipients, $recipient;
		}
	}

	my $die_on_email_error = $batchmode ? '' : 'die_on_email_error';
	my @errors = ();
	foreach my $to (@recipients)
	{
		my (undef,$err) = send_email($to,
					$PREF{app_email_address},
					$subject,
					$body,
					($PREF{group_membership_update_emailalert_format} || $PREF{global_email_format}),
					$die_on_email_error
		);
		push(@errors,$err) if $err;
	}

	return $batchmode ? @errors : @errors ? die_nice(join("<br /><br />\n", @errors)) : ();
}


sub get_group_desc
{
	check_gid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `desc` FROM `$PREF{group_table}` WHERE `id` = $_[0]");
}


sub is_temp_group
{
	check_gid_for_uniqueness($_[0]); # checks for sql safeness too.
	my $type = enc_sql_select("SELECT `type` FROM `$PREF{group_table}` WHERE `id` = $_[0]");
	return $type =~ /temporary|subscription/i;
}


sub set_table_names()
{
	my $prefix = 'ubtrial';
	$PREF{userbase_table_name_prefix} = $prefix;

	$PREF{user_table}		= $prefix . '_users';
	$PREF{group_table}		= $prefix . '_groups';
	$PREF{pwreset_table}		= $prefix . '_pwreset';
	$PREF{custom_field_list_table}	= $prefix . '_custom_fields';
	$PREF{field_sections_table}	= $prefix . '_field_sections';
	$PREF{paypal_ipn_table}		= $prefix . '_paypal_ipn';
	$PREF{payments_table}		= $prefix . '_payments';
	$PREF{logins_table}		= $prefix . '_logins';
	$PREF{failed_logins_table}	= $prefix . '_failed_logins';
	$PREF{password_activity_table}	= $prefix . '_password_activity';
	$PREF{userinfo_updates_table}	= $prefix . '_userinfo_updates';
	$PREF{event_calendar_table}	= $prefix . '_event_calendar';
	$PREF{group_log_table}		= $prefix . '_group_log';
	$PREF{member_mainmenu_table}	= $prefix . '_mainmenu_for_' . lc($PREF{member_group_name});
	$PREF{admin_mainmenu_table}	= $prefix . '_mainmenu_for_' . lc($PREF{admin_group_name});
	$PREF{promo_table}		= $prefix . '_promos';
	$PREF{sent_mail_table}		||= $prefix . '_sent_mail';
}


sub create_tables_if_DNE
{
	create_periodic_task({ name => 'create_and_update_db_tables', enabled => 'yes', period => 60*60*24 });   # "60*60*24" is 24 hours.
	return unless $MISC{version_number_changed} || it_is_time_for_periodic_task('create_and_update_db_tables') || ($PREF{force_database_table_checks} =~ /yes/i) || !db_table_exists($PREF{user_table});   # always verify that the user table exists, as a sanity check / fallback.

	create_group_table_if_DNE();
	create_pwreset_table_if_DNE();
	create_field_sections_table_if_DNE();
	create_custom_fields_table_if_DNE();
	create_paypal_ipn_table_if_DNE();
	create_payments_table_if_DNE();
	create_logins_table_if_DNE();
	create_failed_logins_table_if_DNE();
	create_password_activity_table_if_DNE();
	create_userinfo_updates_table_if_DNE();
	create_admin_mainmenu_table_if_DNE();
	create_member_mainmenu_table_if_DNE();
	create_event_calendar_table_if_DNE();
	create_group_log_table_if_DNE();
	create_promo_table_if_DNE();
	create_sent_mail_table_if_DNE();
	create_expired_memberships_group_if_DNE();

	my $table = $PREF{user_table};
	if( ! db_table_exists($table) )
	{
		printd "$0: table $table does not exist; attempting to create it now.\n";

		# 20081016: added new column "lastactive" which records the timestamp of the
		# last time we saw a given user (i.e. last pageview, not last login).  the
		# existing "loggedin" column does the same thing, except that it gets reset
		# to zero when a user logs out, so rather than do a bunch of refactoring
		# of all the code that uses the loggedin column, we'll create a new lastactive
		# column expressly for that purpose instead.

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR(4) NOT NULL UNIQUE, "
				. " `password` VARCHAR(255) NOT NULL, "
				. " `salt` VARCHAR(255) NOT NULL, "
				. " `name` VARCHAR($PREF{max_realname_length}), "
				. " `email` VARCHAR($PREF{max_emailaddr_length}), "
				. " `cdate` BIGINT UNSIGNED NOT NULL, "
				. " `loggedin` BIGINT UNSIGNED, "
				. " `lastactive` BIGINT UNSIGNED, "
				. " `first_visit_today` CHAR(15) NOT NULL DEFAULT '', "
				. " `numusers` INT UNSIGNED, "
				. " `mrsession` VARCHAR(85), "
				. " `failed_logins` VARCHAR(255), "
				. " `ip` VARCHAR(40), "
				. " `acct_locked` BOOL, "
				. " `acct_disabled` BOOL, "
				. " `pending_email_verification` TINYINT(1) UNSIGNED, "
				. " `completed_email_verification` TINYINT(1) UNSIGNED, "
				. " `pending_admin_approval` TINYINT(1) UNSIGNED, "
				. " `completed_admin_approval` TINYINT(1) UNSIGNED, "
				. " `pending_payment` TINYINT(1) UNSIGNED, "
				. " `email_verification_token` VARCHAR(200), "
				. " `forcepwchng` TINYINT(1) UNSIGNED, "
				. " `autogroup` VARCHAR(100) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("$0: couldn't create user table '$table': $DBI::errstr\n");

		printd "$0: created table $table successfully.\n";
		applog("created user table '$table'");

		#create_random_admin_account_and_exit();
	}

	add_db_column_if_DNE($table, 'salt',				'VARCHAR(50) NOT NULL');
	add_db_column_if_DNE($table, 'failed_logins',			'VARCHAR(255)');
	add_db_column_if_DNE($table, 'acct_locked',			'BOOL');
	add_db_column_if_DNE($table, 'ip',				'VARCHAR(40)');
	add_db_column_if_DNE($table, 'email_verification_token',	'VARCHAR(200)');
	add_db_column_if_DNE($table, 'numusers',			'INT UNSIGNED');
	add_db_column_if_DNE($table, 'acct_disabled',			'BOOL');
	add_db_column_if_DNE($table, 'forcepwchng',			'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'pending_email_verification',	'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'pending_admin_approval',		'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'pending_payment',			'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'completed_email_verification',	'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'completed_admin_approval',	'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'lastactive',			'BIGINT UNSIGNED AFTER loggedin');
	add_db_column_if_DNE($table, 'autogroup',			'VARCHAR(100) AFTER forcepwchng');
	add_db_column_if_DNE($table, 'first_visit_today',		'CHAR(15) NOT NULL AFTER lastactive');

	my $field_details = get_field_details_from_db($table, 'username');
	unless($$field_details{key} =~ /uni/i)
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` MODIFY `username` VARCHAR($PREF{max_username_length}) NOT NULL UNIQUE;");
		$sth->execute() or die_nice("couldn't add UNIQUE key to 'username' column on table $table: $DBI::errstr\n");
		encdebug "added UNIQUE key to 'username' field on table $table";
	}

	enlarge_varchar_field_if_necessary($table, 'password', 255);
	enlarge_varchar_field_if_necessary($table, 'salt', 255);
	enlarge_varchar_field_if_necessary($table, 'email_verification_token', 200);
}


sub create_random_admin_account_and_exit()
{
	my ($user,$pass) = ();
	my $umax = $PREF{max_username_length} < 12 ? $PREF{max_username_length} : 12; $umax = 12 unless $umax;
	my $pmax = $PREF{max_password_length} < 12 ? $PREF{max_password_length} : 12; $pmax = 12 unless $pmax;
	while(length($user) < $umax)	{ $user .= join '', ('A'..'Z', 'a'..'z')[rand 62]; }
	while(length($pass) < $pmax)	{ $pass .= join '', (0..9, 'A'..'Z', 'a'..'z')[rand 62]; }

	$user = lc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
	$user = uc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

	my ($crypted_pass, $salt) = create_new_password_hash($pass);

	add_new_user($user, $crypted_pass, $salt);
	add_user_to_group($user,$PREF{admin_group_name});

	my $default_file = $PREF{datadir} . '/README-then-DELETEME.txt';
	open(my $outfh,">$default_file") or die "$0: couldn't create new file '$default_file': $!\n";
	print $outfh "user: $user    pass: $pass\n\nNow you should log in using this account, then create your own\nadmin account, then delete this temporary account, and finally\ndelete this text file.\n";
	close $outfh or die "$0: couldn't close $default_file after creating it: $!\n";
	chmod($PREF{writable_file_perms},$default_file) or die "$0: couldn't chmod file '$default_file': $!\n";

	exit_with_output(qq`<h1>Important Note</h1><p>It looks like this is the first time you've run UserBase, or else your user tables have been deleted, or you've requested a random admin account.&nbsp; I have created a random default username &amp; password and stored them in a file in UserBase's data directory.&nbsp; Use those to log in and create your own accounts.</p>\n<p>This message will not be displayed again.&nbsp; Reload this page to log in.</p>\n`);
}


sub create_group_table_if_DNE
{
	my $table = $PREF{group_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `group` VARCHAR($PREF{max_groupname_length}) NOT NULL, "
				. " `active` BOOL NOT NULL DEFAULT 0, "
				. " `desc` TEXT, "
				. " `members` TEXT, "
				. " `managers` TEXT, "
				. " `mainmenu_title` TEXT, "
				. " `mainmenu_position` BIGINT UNSIGNED, "
				. " `show_on_signup_page` TINYINT(1) UNSIGNED, "
				. " `label_for_signup_page` TEXT, "

				. " `type` VARCHAR(20) NOT NULL DEFAULT '', "
				#. " `length_in_days` INT UNSIGNED NOT NULL DEFAULT 0, "   # 201701: replaced by length_in_hours.
				. " `length_in_hours` INT UNSIGNED NOT NULL DEFAULT 0, "
				. " `price` DECIMAL(10,2) NOT NULL DEFAULT 0, "
				. " `price_is_variable` TINYINT(1) UNSIGNED NOT NULL DEFAULT 0, "
				. " `code` VARCHAR(255) NOT NULL DEFAULT '', "
				#. " `trial_period_in_days` INT UNSIGNED NOT NULL, "

				. " `daily_access_limit` INT UNSIGNED NOT NULL DEFAULT 0, "
				. " `ip_address_limit` INT UNSIGNED NOT NULL DEFAULT 0, "
				. " `force_new_signups_to_join` TINYINT(1) UNSIGNED, "
				. " `force_new_admincreated_accounts_to_join` TINYINT(1) UNSIGNED, "
				. " `force_new_subadmincreated_accounts_to_join` TINYINT(1) UNSIGNED "


				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
		applog("created table '$PREF{user_table}'");

		add_new_group($PREF{public_group_name}, 'All users including unregistered users (i.e. strangers) are automatically members of this special public group.');
		add_new_group($PREF{member_group_name}, 'All registered non-pending users are automatically members of this special members group.');
		add_new_group($PREF{admin_group_name},  'Administrators have unlimited access to all features of all web applications.');
	}

	add_db_column_if_DNE($table, 'show_on_signup_page',		'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'label_for_signup_page',		'TEXT');
	add_db_column_if_DNE($table, 'managers',			'TEXT AFTER members');
	add_db_column_if_DNE($table, 'mainmenu_title',			'TEXT AFTER managers');
	add_db_column_if_DNE($table, 'mainmenu_position',		'BIGINT UNSIGNED AFTER mainmenu_title');
	add_db_column_if_DNE($table, 'active',				'BOOL NOT NULL DEFAULT 0 AFTER group');
	add_db_column_if_DNE($table, 'type',				"VARCHAR(20) NOT NULL DEFAULT '' AFTER label_for_signup_page");
	#add_db_column_if_DNE($table, 'length_in_days',			'INT UNSIGNED NOT NULL DEFAULT 0 AFTER type');
	add_db_column_if_DNE($table, 'price',				'DECIMAL(10,2) NOT NULL DEFAULT 0 AFTER length_in_hours');
	add_db_column_if_DNE($table, 'code',				"VARCHAR(255) NOT NULL DEFAULT '' AFTER price");
	add_db_column_if_DNE($table, 'force_new_signups_to_join',	'TINYINT(1) UNSIGNED AFTER code');
	add_db_column_if_DNE($table, 'force_new_admincreated_accounts_to_join', 'TINYINT(1) UNSIGNED AFTER force_new_signups_to_join');
	add_db_column_if_DNE($table, 'force_new_subadmincreated_accounts_to_join', 'TINYINT(1) UNSIGNED AFTER force_new_admincreated_accounts_to_join');
	add_db_column_if_DNE($table, 'price_is_variable',		'TINYINT(1) UNSIGNED NOT NULL DEFAULT 0 AFTER price');
	add_db_column_if_DNE($table, 'daily_access_limit',		'INT UNSIGNED NOT NULL DEFAULT 0 AFTER code');
	add_db_column_if_DNE($table, 'ip_address_limit',		'INT UNSIGNED NOT NULL DEFAULT 0 AFTER daily_access_limit');
	add_db_column_if_DNE($table, 'length_in_hours',			'INT UNSIGNED NOT NULL DEFAULT 0 AFTER type');
}


sub create_group_log_table_if_DNE()
{
	my $table = $PREF{group_log_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		# This table is for logging all group membership changes.
		# "event" is 0 for "user was removed from the group" or 1 for "user was added to the group".

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `changer_userid` BIGINT NOT NULL, "   # can't be unsigned since some of our userids are negative (-1, -2, and -3).
				. " `changer_username` VARCHAR(255) NOT NULL, "
				. " `userid` BIGINT UNSIGNED NOT NULL, "
				. " `username` VARCHAR(255) NOT NULL, "
				. " `group_id` BIGINT UNSIGNED NOT NULL, "
				. " `group_name` VARCHAR(255) NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `date8` BIGINT UNSIGNED NOT NULL, "
				. " `event` BOOL NOT NULL DEFAULT 0, "
				. " `reason` VARCHAR(255) NOT NULL, "
				. " `uri` TEXT NOT NULL, "
				. " `referer` TEXT NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	if( db_column_exists('action', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` CHANGE `action` `event` VARCHAR(255) NOT NULL;");
		$sth->execute() or die_nice "could not rename column 'action' to 'event' on table '$table': $DBI::errstr\n";
		enc_warn "added column to table '$table'.";
	}

	add_db_column_if_DNE($table, 'uri',	'TEXT NOT NULL AFTER event');
	add_db_column_if_DNE($table, 'referer',	'TEXT NOT NULL AFTER uri');
	add_db_column_if_DNE($table, 'reason',	'VARCHAR(255) NOT NULL AFTER event');
}


sub create_pwreset_table_if_DNE
{
	my $table = $PREF{pwreset_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR($PREF{max_username_length}) NOT NULL, "
				. " `token` VARCHAR(100) NOT NULL, "
				. " `requestdate` BIGINT UNSIGNED NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	enlarge_varchar_field_if_necessary($PREF{pwreset_table}, 'token', 200);
}


sub create_field_sections_table_if_DNE()
{
	my $table = $PREF{field_sections_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement = "
		CREATE TABLE `$table` (
		`id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
		`name` VARCHAR(255) NOT NULL,
		`label` VARCHAR(255) NOT NULL,
		`section_position` INT UNSIGNED NOT NULL
		)
		";

		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";

		foreach my $stmt (split(/\n/, $PREF{field_sections_table_default_values}))
		{
			enc_sql_insert($stmt) if $stmt;
		}
	}

	add_db_column_if_DNE($table, 'label',	'VARCHAR(255) NOT NULL AFTER name');
}


sub create_custom_fields_table_if_DNE
{
	my $table = $PREF{custom_field_list_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `fieldposition` INT NOT NULL, "
				. " `section` VARCHAR(255) NOT NULL, "
				. " `enabled` BOOL NOT NULL DEFAULT 0, "
				. " `fieldname` VARCHAR(100) NOT NULL, "
				. " `fieldlabel` VARCHAR(255) NOT NULL, "
				. " `datatype` VARCHAR(100) NOT NULL, "
				. " `fieldtype` VARCHAR(100) NOT NULL, "
				. " `fieldmax` TINYINT UNSIGNED, "
				. " `mandatory` BOOL NOT NULL DEFAULT 0, "

				. " `show_on_signup_page` BOOL NOT NULL DEFAULT 0, "
				. " `groups_allowed_to_view` TEXT NOT NULL, "
				. " `groups_allowed_to_edit` TEXT NOT NULL, "

				. " `limitallowedchars` BOOL NOT NULL DEFAULT 0, "
				. " `allowedchars` TEXT NOT NULL, "
				. " `allowedcharsmsg` VARCHAR(255), "
				. " `listitems` TEXT NOT NULL, "
				. " `defaultvalue` TEXT NOT NULL, "   # 20100114: testing "NOT NULL" here; should we use this always, from now on?
				. " `field_actions` TEXT NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	add_db_column_if_DNE($table, 'defaultvalue',		'TEXT NOT NULL');
	add_db_column_if_DNE($table, 'section',			'VARCHAR(255) NOT NULL AFTER fieldposition');
	add_db_column_if_DNE($table, 'field_actions',		'TEXT NOT NULL');
	add_db_column_if_DNE($table, 'show_on_signup_page',	'BOOL NOT NULL DEFAULT 0 AFTER mandatory');
	add_db_column_if_DNE($table, 'groups_allowed_to_view',	'TEXT NOT NULL AFTER show_on_signup_page');
	add_db_column_if_DNE($table, 'groups_allowed_to_edit',	'TEXT NOT NULL AFTER groups_allowed_to_view');
}


sub create_paypal_ipn_table_if_DNE
{
	my $table = $PREF{paypal_ipn_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `date` BIGINT UNSIGNED NOT NULL, "
				. " `date8` BIGINT UNSIGNED NOT NULL, "
				. " `txn_id` VARCHAR(50) NOT NULL, "
				. " `allvars` TEXT NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}



sub create_payments_table_if_DNE
{
	my $table = $PREF{payments_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `date` BIGINT UNSIGNED NOT NULL, "
				. " `date8` BIGINT UNSIGNED NOT NULL, "
				. " `paypal_date` BIGINT UNSIGNED NOT NULL, "
				. " `paypal_date8` BIGINT UNSIGNED NOT NULL, "
				. " `item_number` VARCHAR(50) NOT NULL, "
				. " `item_name` VARCHAR(255) NOT NULL, "
				. " `quantity` INT UNSIGNED NOT NULL, "
				. " `item_cost` DECIMAL(10,2) NOT NULL, "
				. " `transaction_type` VARCHAR(255) NOT NULL, "
				. " `transaction_cost` DECIMAL(10,2) NOT NULL, "
				. " `promo_code` VARCHAR(255) NOT NULL, "
				. " `txn_id` VARCHAR(50) NOT NULL, "
				. " `userid` BIGINT UNSIGNED NOT NULL, "
				. " `buyer_email` VARCHAR(255) NOT NULL, "
				. " `buyer_firstname` VARCHAR(255) NOT NULL, "
				. " `buyer_lastname` VARCHAR(255) NOT NULL, "
				#. " `days_purchased` VARCHAR(10) NOT NULL, "   # replaced by hours_purchased in January 2017.
				. " `hours_purchased` VARCHAR(10) NOT NULL, "
				. " `group_name` VARCHAR(255) NOT NULL, "
				. " `group_id` INT UNSIGNED NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	#add_db_column_if_DNE($table, 'days_purchased',		'VARCHAR(10) NOT NULL AFTER buyer_lastname');
	add_db_column_if_DNE($table, 'hours_purchased',		'VARCHAR(10) NOT NULL AFTER buyer_lastname'); # Added Jan 2017.
	add_db_column_if_DNE($table, 'group_name',		'VARCHAR(255) NOT NULL AFTER hours_purchased');
	add_db_column_if_DNE($table, 'group_id',		'INT UNSIGNED NOT NULL AFTER group_name');
	add_db_column_if_DNE($table, 'transaction_type',	'VARCHAR(255) NOT NULL AFTER quantity');
	add_db_column_if_DNE($table, 'item_cost',		'DECIMAL(10,2) NOT NULL AFTER quantity');
	add_db_column_if_DNE($table, 'promo_code',		'VARCHAR(255) NOT NULL AFTER transaction_cost');
}


sub create_logins_table_if_DNE
{
	my $table = $PREF{logins_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `user_id` BIGINT UNSIGNED NOT NULL, "
				. " `session_id` VARCHAR(85) NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL, "
				. " INDEX (`timestamp`)"
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	my $timestamp_field_details = get_field_details_from_db($table,'timestamp');
	unless($$timestamp_field_details{key} =~ /mul/i)
	{
		my $statement = qq`alter table $table add index (timestamp);`;
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't add index to timestamp column on table '$table': $DBI::errstr\n");
		encdebug "added index to timestamp field on table $table";
	}
}


sub create_failed_logins_table_if_DNE
{
	my $table = $PREF{failed_logins_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR(255) NOT NULL, "
				. " `password_fingerprint` VARCHAR(85) NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_password_activity_table_if_DNE
{
	my $table = $PREF{password_activity_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `user_id` BIGINT UNSIGNED NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `password_fingerprint` VARCHAR(85) NOT NULL, "
				. " `salt` VARCHAR(50) NOT NULL, "
				. " `user_who_did_update` BIGINT UNSIGNED NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_userinfo_updates_table_if_DNE
{
	my $table = $PREF{userinfo_updates_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `changer_id` BIGINT UNSIGNED NOT NULL, "
				. " `changee_id` BIGINT UNSIGNED NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `item_changed` VARCHAR(255) NOT NULL, "
				. " `old_value` TEXT NOT NULL, "
				. " `new_value` TEXT NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_promo_table_if_DNE
{
	my $table = $PREF{promo_table};
	unless(db_table_exists($table))
	{
		enc_warn "table $table does not exist; attempting to create it now.\n";

		# note: timestamp is the epoch-time in seconds; date is date17 (YYYYMMDD-HH:MM:SS).
		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `timestamp_created` BIGINT UNSIGNED NOT NULL, "
				. " `promo_code` VARCHAR(50) NOT NULL, "
				. " `active` TINYINT(1) UNSIGNED NOT NULL, "
				. " `type` VARCHAR(50) NOT NULL, "
				. " `value` VARCHAR(10) NOT NULL, "
				. " `description` TEXT NOT NULL, "
				. " `redemption_count` BIGINT UNSIGNED NOT NULL DEFAULT 0, "
				. " `redemption_limit` BIGINT UNSIGNED, "
				. " `activation_date` BIGINT UNSIGNED, "
				. " `expiration_date` BIGINT UNSIGNED, "
				. " `valid_for_groups` TEXT NOT NULL"
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr\n");

		enc_warn "created table '$table' successfully.\n";
	}

	add_db_column_if_DNE($table, 'redemption_count',	'BIGINT UNSIGNED NOT NULL DEFAULT 0');
	add_db_column_if_DNE($table, 'redemption_limit',	'BIGINT UNSIGNED');
	add_db_column_if_DNE($table, 'expiration_date',		'BIGINT UNSIGNED');
	add_db_column_if_DNE($table, 'valid_for_groups',	"TEXT NOT NULL DEFAULT ''");
	add_db_column_if_DNE($table, 'activation_date',		'BIGINT UNSIGNED AFTER redemption_limit');
}


sub create_admin_mainmenu_table_if_DNE
{
	my $table = $PREF{admin_mainmenu_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `link_position` INT UNSIGNED NOT NULL, "
				. " `link_text` VARCHAR(255), "
				. " `link_address` TEXT NOT NULL, "
				. " `link_extra_attributes` TEXT, "
				. " `hide_link` TINYINT(1) UNSIGNED, "
				. " `autohide` BOOL NOT NULL DEFAULT 0, "
				. " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable_msg` TEXT, "
				. " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";

		create_default_links_in_admin_mainmenu();
	}

	add_db_column_if_DNE($table, 'hide_link',	'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'link_position',	'INT UNSIGNED NOT NULL AFTER id');
	add_db_column_if_DNE($table, 'autohide',	'BOOL NOT NULL DEFAULT 0 AFTER hide_link');

	# Also add any of our built-in links if they're missing (which they would be
	# on new installs, or on updates from previous versions where the db table
	# already existed but some of the links didn't, etc).
	#
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=viewpayments'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('25', 'View All Payments', '%PREF{login_url_qsready}action=viewpayments', TRUE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=grouplog'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('42', 'View Group Log', '%PREF{login_url_qsready}action=grouplog', FALSE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=adminalerts'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('9', '$TEXT{Admin_Alerts}', '%PREF{login_url_qsready}action=adminalerts', FALSE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=webconfig'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('53', 'Settings', '%PREF{login_url_qsready}action=webconfig', FALSE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=managepagelock'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('23', 'PageLock: Manage Protected Pages', '%PREF{login_url_qsready}action=managepagelock', FALSE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=dirlock'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('24', 'DirLock: Manage Protected Directories', '%PREF{login_url_qsready}action=dirlock', FALSE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=promos'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('27', 'Manage Promo Codes', '%PREF{login_url_qsready}action=promos', TRUE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=payreport'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('26', 'Payments Report', '%PREF{login_url_qsready}action=payreport', TRUE)");
	}
}


sub create_member_mainmenu_table_if_DNE
{
	my $table = $PREF{member_mainmenu_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `link_position` INT UNSIGNED NOT NULL, "
				. " `link_text` VARCHAR(255), "
				. " `link_address` TEXT NOT NULL, "
				. " `link_extra_attributes` TEXT, "
				. " `hide_link` TINYINT(1) UNSIGNED, "
				. " `autohide` BOOL NOT NULL DEFAULT 0, "
				. " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable_msg` TEXT, "
				. " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	add_db_column_if_DNE($table, 'hide_link',	'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'link_position',	'INT UNSIGNED NOT NULL AFTER id');
	add_db_column_if_DNE($table, 'autohide',	'BOOL NOT NULL DEFAULT 0 AFTER hide_link');

	# Also add any of our built-in links if they're missing (which they would be
	# on new installs, or on updates from previous versions where the db table
	# already existed but some of the links didn't, etc).
	#
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=viewuser'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`) VALUES('10', 'View My Profile', '%PREF{login_url_qsready}action=viewuser')");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=edituser'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`) VALUES('20', 'Edit My Profile', '%PREF{login_url_qsready}action=edituser')");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=changeimage'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`) VALUES('30', 'Change Profile Image', '%PREF{login_url_qsready}action=changeimage')");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=joinpaidgroup'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('35', 'Join a Paid Group', '%PREF{login_url_qsready}action=joinpaidgroup', TRUE)");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=viewpayments'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('40', 'View My Payments', '%PREF{login_url_qsready}action=viewpayments', TRUE)");
	}
}


sub create_expired_memberships_group_if_DNE
{
	my $group = $PREF{expired_group_name};
	add_new_group($group, "When a user's temporary or subscription group-membership expires, the user will automatically be added to this group, and then automatically removed if/when that user re-joins a temporary/subscription group.") unless group_exists($PREF{expired_group_name});

	create_mainmenu_table_for_group($group);

	my $mainmenu_table = $PREF{userbase_table_name_prefix} . '_mainmenu_for_' . lc($group);
	unless(enc_sql_select("SELECT COUNT(*) FROM `$mainmenu_table` WHERE `link_address` = '%PREF{login_url_qsready}action=joinpaidgroup'"))
	{
		enc_sql_insert("INSERT INTO `$mainmenu_table` (`link_position`, `link_text`, `link_address`, `autohide`) VALUES('35', 'Renew Your Subscription', '%PREF{login_url_qsready}action=joinpaidgroup', TRUE)");
	}
}


sub create_event_calendar_table_if_DNE
{
	my $table = $PREF{event_calendar_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		# The reminder is a number of minutes, for example a value of 1440 would mean to send a reminder 1 day before the event date.

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `userid` INT UNSIGNED NOT NULL, "
				. " `name` VARCHAR(255) NOT NULL, "
				. " `description` TEXT NOT NULL, "
				. " `date` INT UNSIGNED NOT NULL, "
				. " `time` INT UNSIGNED NOT NULL, "
				. " `reminder1` INT UNSIGNED NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	$table = $PREF{event_calendar_reminderlog_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		# date12 is the YYYYMMDDHHMM datestamp when the reminder was sent.

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR(100) NOT NULL, "
				. " `recipient` VARCHAR(100) NOT NULL, "
				. " `eventname` VARCHAR(255) NOT NULL, "
				. " `date12` BIGINT UNSIGNED NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_mainmenu_table_for_group($)
{
	my $group = shift;
	my $group_raw = $group;
	$group =~ s!\W!!g;
	return unless $group;
	my $table = $PREF{userbase_table_name_prefix} . '_mainmenu_for_' . lc($group);
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `link_position` INT UNSIGNED NOT NULL, "
				. " `link_text` VARCHAR(255), "
				. " `link_address` TEXT NOT NULL, "
				. " `link_extra_attributes` TEXT, "
				. " `hide_link` TINYINT(1) UNSIGNED, "
				. " `autohide` BOOL NOT NULL DEFAULT 0, "
				. " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable_msg` TEXT, "
				. " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}

	add_db_column_if_DNE($table, 'hide_link',	'TINYINT(1) UNSIGNED');
	add_db_column_if_DNE($table, 'link_position',	'INT UNSIGNED NOT NULL AFTER id');
	add_db_column_if_DNE($table, 'autohide',	'BOOL NOT NULL DEFAULT 0 AFTER hide_link');

	create_default_links_in_subgroup_manager_mainmenu($table) if $PREF{groups_that_can_manage_subgroup_users} =~ /(^|,)\s*$group_raw\s*(,|$)/;
}


sub delete_mainmenu_table_for_group($)
{
	my $group = shift;
	$group =~ s!\W!!g;
	return unless $group;
	my $table = $PREF{userbase_table_name_prefix} . '_mainmenu_for_' . lc($group);
	if(db_table_exists($table))
	{
		printd "table '$table' exists; attempting to delete it now.";

		my $statement = "DROP TABLE `$table`";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't delete table '$table': $DBI::errstr");

		printd "deleted table '$table' successfully.";
	}
}


sub create_default_links_in_admin_mainmenu()
{
	my $undeletable_msg = 'This link is an important part of the system and should not be deleted.';

	my %links = (
		 9 => { text => $TEXT{Admin_Alerts},		url => '%PREF{login_url_qsready}action=adminalerts', },
		11 => { text => $TEXT{Manage_Users},		url => '%PREF{login_url}?action=showusers', },
		13 => { text => 'Manage Groups',		url => '%PREF{login_url}?action=groups', },
		17 => { text => 'Manage Custom Fields',		url => '%PREF{login_url}?action=customfields', },
		21 => { text => 'Manage Field Sections',	url => '%PREF{login_url}?action=fieldsections', },
		23 => { text => 'PageLock: Manage Protected Pages',	url => '%PREF{login_url_qsready}action=managepagelock', },
		24 => { text => 'DirLock: Manage Protected Directories',	url => '%PREF{login_url_qsready}action=dirlock', },
		25 => { text => 'View Payments',		url => '%PREF{login_url_qsready}action=viewpayments',	autohide => 1 },
		26 => { text => 'Payments Report',		url => '%PREF{login_url_qsready}action=payreport',	autohide => 1 },
		27 => { text => 'Manage Promo Codes',		url => '%PREF{login_url_qsready}action=promos',		autohide => 1 },
		30 => { text => 'View Logins',			url => '%PREF{login_url}?action=showlogins', },
		32 => { text => 'View Failed Logins',		url => '%PREF{login_url}?action=showfailedlogins', },
		35 => { text => 'View Password Updates',	url => '%PREF{login_url}?action=showpwlog', },
		39 => { text => 'View User Info Updates',	url => '%PREF{login_url}?action=infoupdates', },
		42 => { text => 'View Group Log',		url => '%PREF{login_url_qsready}action=grouplog', },
		45 => { text => 'Import Users',			url => '%PREF{login_url}?action=csvimport', },
		49 => { text => 'Export Users',			url => '%PREF{login_url}?action=csvexport', },
		53 => { text => 'Settings',			url => '%PREF{login_url_qsready}action=webconfig', },
		54 => { text => 'View Preferences',		url => '%PREF{login_url}?action=showprefs', },
		56 => { text => 'View Server Information',	url => '%PREF{login_url}?action=serverinfo', },
		60 => { text => 'Check Image Modules',		url => '%PREF{login_url}?action=imagemodules', },
	);

	foreach my $i (sort keys %links)
	{
		next if enc_sql_select("SELECT COUNT(*) FROM `$PREF{admin_mainmenu_table}` WHERE `link_address` = '$links{$i}{url}'");
		$links{$i}{autohide} ||= 0;   # Otherwise, some MySQL servers will fail with: "Incorrect integer value: '' for column 'autohide'".
		enc_sql_insert("INSERT INTO `$PREF{admin_mainmenu_table}` (`link_position`,`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`,`autohide`) "
		. "VALUES($i, '$links{$i}{text}', '$links{$i}{url}', 1, '$undeletable_msg', 'link_address', '$links{$i}{autohide}')");
	}
}


# Note: caller must ensure that the $table passed in is SQL-safe.
sub create_default_links_in_subgroup_manager_mainmenu($)
{
	my $table = shift;
	my $undeletable_msg = 'This link is an important part of the system and should not be deleted.';
	my $link_address = '%PREF{login_url}?action=showusers';

	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '$link_address'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`,`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`) "
		. "VALUES(1, '$TEXT{Manage_Users}', '$link_address', 1, '$undeletable_msg', 'link_address')");
	}
	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=joinpaidgroupsubs'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`, `autohide`) "
		. "VALUES('36', 'Add Users to Paid Group', '%PREF{login_url_qsready}action=joinpaidgroupsubs', TRUE)");
	}
}


sub edit_main_menu()
{
	my $gid = get_qs_var('gid') or exit_with_error($TEXT{Must_pass_group_id_});
	my $group = get_group_name($gid);
	my $group_for_tablename = $group;
	$group_for_tablename =~ s!\W!!g;
	exit_with_needprivs() unless user_is_allowed_to('edit_all_mainmenus') || user_is_allowed_to("edit_${group_for_tablename}_mainmenu");

	my $tableprefname	= $PREF{userbase_table_name_prefix} . '_mainmenu_for_' . lc($group_for_tablename);
	my $viewerprefname	= 'mainmenu';
	my $allowed_to_view	= 1;
	my $allowed_to_create	= 1;
	my $allowed_to_edit	= 1;
	my $allowed_to_delete	= 1;




	$PREF{"${viewerprefname}_viewer_title"}					||= 'Edit Mainmenu For Group: ' . $group;

	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{link_address}		= "for links to pages within $ENV{HTTP_HOST}, start with a slash and leave off the $ENV{HTTP_HOST}, e.g. '/somepage.html' not '$ENV{HTTP_HOST}/somepage.html'.<br />this can be left blank, to make this item be a plain text row in the menu";
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{link_position}		= "can be any number, or can be left blank";
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{link_extra_attributes}	= "optional; can contain any valid HTML attributes for link elements, such as style, target, etc";

	$PREF{"${viewerprefname}_viewer_item_name"}				||= 'link';
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id';
	$PREF{"${viewerprefname}_viewer_max_display_length"}			||= 500;
	$PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 25;

	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			||= qq`text-align: left;`;
	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		||= qq`text-align: left;`;

	$PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'link_position';

	$PREF{"${viewerprefname}_POST_value_transforms"}{link_position}		= 'preset:next_int_if_null_or_zero';





	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


#sub emailaddr_is_valid				{ return ($_[0] =~ /.+\@.+\..+/   &&   $_[0] !~ /\s/			&&	length($_[0]) < $PREF{max_emailaddr_length});												}
sub emailaddr_is_valid				{ return (is_valid_email_address($_[0])   &&   $_[0] !~ /\s/		&&	length($_[0]) < $PREF{max_emailaddr_length});												}
sub ip_is_valid					{ return ($_[0] =~ /^[0-9A-Za-z\.:]+$/      				&&	length($_[0]) <= 40);															}
sub groupdesc_is_valid				{ return 									length($_[0]) < $PREF{max_group_description_length};											}
sub salt_is_valid				{ return									length($_[0]) < $PREF{max_salt_length};													}


sub realname_is_valid
{
	return 0 if length($_[0]) > $PREF{max_realname_length};
	return 0 if ($_[0] =~ /_/ && $PREF{allow_underscores_in_realnames} !~ /yes/i);
	return 0 if ($_[0] =~ /\$\@\t\n\\/);   # explicitly reject a few really shady items.
	unless($_[0] =~ /^[\p{Alnum}\.'" -]+$/   &&   $_[0] =~ /^\p{Alpha}/) { enc_warn qq`realname '$_[0]' fails word-test so returning invalid`; return 0; };
	if(not_sqlsafe($_[0])) { enc_warn qq`realname '$_[0]' is not_sqlsafe so returning invalid`; return 0; };
	return 1;
}


sub password_is_valid
{
	my $pw = shift;
	if(length($pw) < $PREF{min_password_length})
	{
		return 0;
	}
	if(length($pw) > $PREF{max_password_length})
	{
		return 0;
	}
	if($PREF{passwords_must_contain_a_lowercase_letter} =~ /yes/i   &&   $pw !~ /[a-z]/)
	{
		return 0;
	}
	if($PREF{passwords_must_contain_an_uppercase_letter} =~ /yes/i   &&   $pw !~ /[A-Z]/)
	{
		return 0;
	}
	if($PREF{passwords_must_contain_a_number} =~ /yes/i   &&   $pw !~ /[0-9]/)
	{
		return 0;
	}
	if($PREF{passwords_must_contain_a_nonalphanumeric_char} =~ /yes/i   &&   $pw =~ /^[0-9a-zA-Z]+$/)
	{
		return 0;
	}
	return 1;
}


# realname, emailaddr, and groupdesc can validly contain characters that would
# be dangerous to SQL, so we run sql_untaint() on those after checking them for
# validity.
#
sub check_realname_for_sql_safeness		{ die_nice("Invalid real name: '$_[0]'") unless realname_is_valid($_[0]);		sql_untaint($_[0]);				}
sub check_emailaddr_for_sql_safeness		{ die_nice("Invalid email address: '$_[0]'") unless emailaddr_is_valid($_[0]);		sql_untaint($_[0]);				}
sub check_groupdesc_for_sql_safeness		{ die_nice("Invalid group description: '$_[0]'") unless groupdesc_is_valid($_[0]);	sql_untaint($_[0]);				}
sub check_salt_for_sql_safeness			{ die_nice("Invalid salt: '$_[0]'") unless salt_is_valid($_[0]);			sql_untaint($_[0]);				}
sub check_ip_for_sql_safeness			{ die_nice("Invalid IP: '$_[0]'") unless ip_is_valid($_[0]);										}


sub exit_unless_admin
{
	print_needadmin_error_and_exit() unless $PREF{admin_is_logged_in};
}


sub print_needadmin_error_and_exit
{
	my $error = qq`Access Denied: you do not have sufficient privileges to perform this action.`;
	if(!$PREF{admin_is_logged_in})
	{
		$error .= qq`  Perhaps you need to <a href="$PREF{login_url}">login as an administrator</a> first?`;
	}
	exit_with_error($error);
}


sub showusers_new()
{
	my $tableprefname	= 'user_table';
	my $viewerprefname	= 'user';
	my $allowed_to_view	= $PREF{admin_is_logged_in};
	my $allowed_to_create	= 0; #$PREF{admin_is_logged_in};
	my $allowed_to_edit	= $PREF{admin_is_logged_in};
	my $allowed_to_delete	= 0; #$PREF{admin_is_logged_in};




	$PREF{"${viewerprefname}_viewer_title"}					||= 'New Manage Users Page (Testing)';
	$PREF{"${viewerprefname}_viewer_footer_note"}				= qq``;
	$PREF{"${viewerprefname}_viewer_item_name"}				||= 'user';
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id,password,salt,mrsession,failed_logins,ip,numusers,email_verification_token,acct_locked,acct_disabled,pending_email_verification,completed_email_verification,pending_admin_approval,completed_admin_approval,pending_payment,forcepwchng,autogroup';
	$PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 25;
	$PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'username';

	$PREF{"${viewerprefname}_viewer_uneditable_columns"}			= 'username';

	#$PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			||= qq`text-align: left;`;
	#$PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		||= qq`text-align: left;`;

	$PREF{"${viewerprefname}_viewer_title_transforms"}{cdate}		= 'Date Created';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{loggedin}		= 'Last Login';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{lastactive}		= 'Last Active';

	$PREF{"${viewerprefname}_viewer_value_transforms"}{cdate}		= qq`%%variable%% = %%variable%% ? strftime("%Y%m%d-%H%M",localtime(%%variable%%)) : '00000000-0000';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{loggedin}		= qq`%%variable%% = %%variable%% ? strftime("%Y%m%d-%H%M",localtime(%%variable%%)) : '00000000-0000';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{lastactive}		= qq`%%variable%% = %%variable%% ? strftime("%Y%m%d-%H%M",localtime(%%variable%%)) : '00000000-0000';`;


	$PREF{"${viewerprefname}_viewer_extra_columns"}{status}			= { position => 2, value => '' };
	$PREF{"${viewerprefname}_viewer_value_transforms"}{status}		= qq`

		if(account_is_pending(%%id%%))
		{
			my \$pending_msg = '';
			\$pending_msg	.= 'pending payment, ' if account_is_pending_payment(%%id%%);
			\$pending_msg	.= 'pending email verification, ' if account_is_pending_email_verification(%%id%%);
			\$pending_msg	.= 'pending admin approval, ' if account_is_pending_admin_approval(%%id%%);
			\$pending_msg	=~ s!,\s*\$!!;
			\$pending_msg	||= 'pending';

			%%variable%% = '<a href="' . "$PREF{login_url_qsready}" . 'action=approve_or_del&amp;uid=%%id%%">' . "\$pending_msg" . '</a>';
		}
		else
		{
			%%variable%% = 'active';
		}

	`;


	$PREF{"${viewerprefname}_viewer_extra_columns"}{groups}			= { position => 9, value => '' };
	$PREF{"${viewerprefname}_viewer_value_transforms"}{groups}		= qq`

		my \@groups = ();
		my \$groups = get_groups_hash(%%id%%);
		foreach my \$group (sort { lc(\$a) cmp lc(\$b) } keys %\$groups)
		{
			next if \$group =~ /^(\$PREF{public_group_name}|\$PREF{member_group_name})\$/i;
			if(\$\$groups{\$group}{is_member})
			{
				push \@groups, '<!-- ' . "\$group" . ' --><a href="' . "$PREF{login_url_qsready}" . 'action=groups&amp;editmode=true&amp;editid=' . "\$\$groups{\$group}{id}" . '">' . "\$group" . '</a>';
			}
		}
		%%variable%% = join '<br />', \@groups;

	`;



	if(paid_groups_enabled())
	{
		$PREF{"${viewerprefname}_viewer_extra_columns"}{PayPal_Email}	= { position => 8, value => '' };

		$PREF{"${viewerprefname}_viewer_value_transforms"}{PayPal_Email}= qq`

			my \$raw_paypal_data = enc_sql_select("SELECT allvars FROM $PREF{paypal_ipn_table} WHERE allvars like '%option_selection1=%%id%%\n_SPTR_%'");
			my \$payer_email = (\$raw_paypal_data =~ /payer_email=(.+?)\n*_SPTR_/s)[0];
			%%variable%% = \$payer_email;

		`;
	}




	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub manage_bulk_user_actions
{
	exit_with_needprivs() unless user_is_allowed_to('manage_account_locks') && user_is_allowed_to('force_password_changes');
	my $output = '';

	if($qs =~ /forcepwchngall=yes/)
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET forcepwchng = 1 WHERE `id` != $PREF{logged_in_userid}");
		$output .= $success ? "Successfully enabled forcepwchng on $success accounts." : "Tried to enable forcepwchng but no accounts were updated (got '$success')?"; $output .= "<br /><br />";
	}
	if($qs =~ /forcelogoutall=yes/)
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `mrsession` = '', loggedin = 0, numusers = 0 WHERE `id` != $PREF{logged_in_userid}");
		$output .= $success ? "Completed force-logout on $success accounts." : "Tried to force-logout-all but no accounts were updated (got '$success')?"; $output .= "<br /><br />";
	}
	if($qs =~ /forcepwresetall=yes/)
	{
		# Note: length of the invalid strings used here for pw/salt should be at least 64, to avoid matching any of the tests for old, too-short passwords.
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET password = 'The password for this account has been reset.....................', salt = 'The salt for this account has been reset.........................' WHERE `id` != $PREF{logged_in_userid}");   # this reset password should be something that a real password (which is a hash output) can never be.
		$output .= $success ? "Completed force-password-reset on $success accounts." : "Tried to force-password-reset-all but no accounts were updated (got '$success')?"; $output .= "<br /><br />";
	}

	if(!$output)
	{
		$output = qq`<div style="max-width: 500px; margin: 0 auto;">\n`
			. qq`<p><strong>Require all passwords to be changed:</strong> immediately <a href="$PREF{here_qsready}action=bulkuser&amp;forcepwchngall=yes&amp;noautoredirect=true">set the 'forcepwchng' flag</a> on every account except mine, so users can still log in, but must change their password immediately afterwards (does not log anyone out).</p>\n`
			. qq`<p><br /><br /><strong>Force-reset all passwords:</strong> immediately <a href="$PREF{here_qsready}action=bulkuser&amp;forcepwresetall=yes&amp;noautoredirect=true">scramble all password hashes</a> except mine, so that users must use the <a href="$PREF{here_qsready}action=pwreset1">Reset Password page</a> before they can log in again (does not log anyone out).</p>\n`
			. qq`<p><br /><br /><strong>Logout all users:</strong> immediately <a href="$PREF{here_qsready}action=bulkuser&amp;forcelogoutall=yes&amp;noautoredirect=true">log everyone out</a> except me.</p>\n`
			. qq`<p><br /><br /><strong>Logout and reset:</strong> immediately <a href="$PREF{here_qsready}action=bulkuser&amp;forcelogoutall=yes&amp;forcepwresetall=yes&amp;noautoredirect=true">logout &amp; password-reset all accounts</a> except mine.</p>\n`
			. "</div>\n";
	}

	output_and_exit({ title=>"Bulk User Actions", msg=>$output });
}


sub showusers
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'view_all_accounts') || logged_in_user_is_subgroup_manager();

	#my ($num_active,$num_pending,$num_disabled) = get_num_accounts();
	#my $num_total_accounts = $num_active + $num_pending + $num_disabled;
	#
	# The get_num_accounts() call can actually be pretty slow (>5s on a site with just
	# ~300 accounts on a shared server) so just get the total here instead, and tally
	# the individual active/pending/disabled numbers in the main loop below.
	#
	my ($num_active,$num_pending,$num_disabled) = (0,0,0);
	my $num_total_accounts = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}`");

	my $letter = $qs =~ /(?:^|&)which=([0-9a-z])(?:&|$)/i ? $1 : $qs =~ /(?:^|&)which=all(?:&|$)/i ? 'all' : $num_total_accounts < 30 ? 'all' : 'a';

	my $restriction = $letter eq 'all' ? undef : " WHERE LOWER(`username`) LIKE LOWER('$letter%') ";

	my %columns = ();
	$columns{'00'}{name} = 'ubcheckboxes';	$columns{'00'}{title} = '';
	$columns{'01'}{name} = 'ubactions';	$columns{'01'}{title} = 'Actions';
	$columns{'02'}{name} = 'ubusername';	$columns{'02'}{title} = 'Username';
	$columns{'03'}{name} = 'ubpassword';	$columns{'03'}{title} = 'Password Hash';
	if(user_is_allowed_to('see_groups_on_user_form'))	{ $columns{'05'}{name} = 'ubgroups';	$columns{'05'}{title} = 'Groups'; }
	if($PREF{use_builtin_realname_field} =~ /yes/i)		{ $columns{'06'}{name} = 'ubrealname';	$columns{'06'}{title} = 'Real Name'; }
	if($PREF{use_builtin_email_field} =~ /yes/i)		{ $columns{'07'}{name} = 'ubemail';	$columns{'07'}{title} = 'Email Address'; }
	$columns{'08'}{name} = 'ubcreatedate';	$columns{'08'}{title} = 'Date Created';
	$columns{'09'}{name} = 'ubpendpaymt';	$columns{'09'}{title} = 'Pending Payment';
	$columns{'10'}{name} = 'ubloggedin';	$columns{'10'}{title} = 'Logged In';
	$columns{'11'}{name} = 'ublastlogin';	$columns{'11'}{title} = 'Last Login';
	$columns{'12'}{name} = 'ubsincelogin';	$columns{'12'}{title} = 'Days Since Login';
	$columns{'13'}{name} = 'ublastactive';	$columns{'13'}{title} = 'Last Active';
	$columns{'14'}{name} = 'ubfirst_visit_today'; $columns{'14'}{title} = 'First Visit Today';
	$columns{'15'}{name} = 'ubdaysinactive'; $columns{'15'}{title} = 'Days Inactive';
	$columns{'16'}{name} = 'ubdaysexp';	$columns{'16'}{title} = 'Days Expired';

	if(paid_groups_enabled())
	{
		$columns{'17'}{name} = 'ubtxnids'; $columns{'17'}{title} = 'Transaction IDs';
	}

	my $i = 18;   # set to the next number after the highest key in %columns just above here.
	my %custom_fields = ();
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
	{
		my ($fieldname,$fieldlabel,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT fieldname,fieldlabel,enabled FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
		$sth->execute() or die_nice("$PREF{internal_appname}: Error: showusers(): $DBI::errstr\n");
		$sth->bind_columns(\$fieldname,\$fieldlabel,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			next unless db_column_exists($fieldname, $PREF{user_table});
			next if (!$enabled && $PREF{hide_disabled_fields_on_userlist_page} =~ /yes/i);

			$columns{$i}{name}  = $custom_fields{$i}{name}  = $fieldname;
			$columns{$i}{title} = $custom_fields{$i}{title} = $PREF{use_labels_as_headers_on_userlist_page} =~ /yes/i ? $fieldlabel : $fieldname;
			$i++;
		}
	}

	start_html_output(logged_in_user_is_subgroup_manager() ? $TEXT{Manage_Users___subadmin} : $TEXT{Manage_Users});

	print logged_in_user_is_subgroup_manager() ? $TEXT{manage_users_intro_note___subadmin} : $TEXT{manage_users_intro_note};

	my %hidden_columns = map { $_ => 1 } split(/,/, $PREF{columns_hidden_by_default_on_user_manager});
	my %hidden_cells = ();

	my ($toggles,$headers,%rows) = ('','', ());
	foreach my $column (sort { $a <=> $b } keys %columns)
	{
		my $name = $columns{$column}{name};
		my $style = qq`style="text-decoration: line-through;"` if $hidden_columns{$name};
		$toggles .= qq`<a href="#" onclick="toggle_column('col_$name'); return false" id="link-col_$name" $style>$columns{$column}{title}</a>&nbsp; `;

		$hidden_cells{$name} = qq`style="display: none;"` if $hidden_columns{$name};

		my $new_qs = $qs;
		$new_qs =~ s/(^|&)sort=\w+?(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)reverse=\d(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)phase=\w+?(&|$)/$1$2/g;
		$new_qs .= "&sort=$name";
		#if($qs !~ /(?:^|&)reverse=1(?:&|$)/   &&   $qs =~ /(?:^|&)sort=\w+?(?:&|$)/) { $new_qs .= "&reverse=1"; }
		if($qs =~ /(?:^|&)reverse=1(?:&|$)/) { $new_qs .= "&reverse=0"; } else { $new_qs .= "&reverse=1"; }
		$new_qs =~ s/&+/&amp;/g;

		$headers .= qq`<th class="col_$name" $hidden_cells{$name}><a href="$PREF{login_url}?$new_qs">$columns{$column}{title}</a></th>`;
	}


	print_account_list_filters(\%columns) if $PREF{account_list_filters_position} eq 'top';


	print qq`<div id="columntoggles">Show/hide:&nbsp; $toggles</div>\n`;
	print qq`<div class="enc_tbl" id="showusers">\n<table>\n<tr class="headers">$headers</tr>\n`;

	$i = 1;
	my $userdata = enc_sql_select_multi("SELECT * FROM `$PREF{user_table}` $restriction ORDER BY `username`");
	foreach my $k (sort { $a <=> $b } keys %$userdata)
	{
		my ($id,$username,$name,$email,$cdate,$loggedin)
		= ($$userdata{$k}{id}, $$userdata{$k}{username}, $$userdata{$k}{name}, $$userdata{$k}{email}, $$userdata{$k}{cdate}, $$userdata{$k}{loggedin});

		my %ubfields = (
			ubusername => $username,
			ubrealname => $name,
			ubemail => $email,
		);

		my (@groups,@groups_raw) = ();
		my $groups = get_groups_hash($id);
		foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
		{
			next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
			if($$groups{$group}{is_member})
			{
				push @groups, qq`<!-- $group --><a href="$PREF{login_url}?action=groups&amp;editmode=true&amp;editid=$$groups{$group}{id}">$group</a>`;
				push @groups_raw, $group;
			}
		}

		next if (logged_in_user_is_subgroup_manager()   &&   !logged_in_subgroup_manager_owns_this_user($id));

		if(paid_groups_enabled())
		{
			my $txnids = enc_sql_select_multi("SELECT txn_id FROM `$PREF{payments_table}` WHERE `userid` = $id");
			my @txnids = ();
			foreach my $k (sort keys %$txnids) { push(@txnids, $$txnids{$k}{txn_id}) if $$txnids{$k}{txn_id}; }
			$ubfields{ubtxnids} = join(',', @txnids);   # for the filters.
			$ubfields{ubtxnids_html} = join('<br />', @txnids);
		}

		$ubfields{ubdaysexp} = '<span title="not expired">N/A</span>';
		if(user_is_member_of_group($id, $PREF{expired_group_name}, 1))
		{
			my $exp_date = enc_sql_select("select max(date8) from $PREF{group_log_table} where group_name = '$PREF{expired_group_name}' and userid = $id");
			$ubfields{ubdaysexp} = $exp_date ? num_elapsed_days_between_datestring8_dates($exp_date, $PREF{today}) : '?';
		}

		my $lastlogin = enc_sql_select("SELECT MAX(`timestamp`) FROM `$PREF{logins_table}` WHERE `user_id` = $id");
		my $lastactive = $$userdata{$k}{lastactive} || $lastlogin;
		my $first_visit_today = $$userdata{$k}{first_visit_today};

		# Note: we'll do a bit of extra code work here, checking prefs instead of calling
		# the subs like account_is_pending_email_verification(), to avoid the extra SQL
		# queries that those subs would do, since we already have that SQL data here in
		# our %userdata hash.
		#
		my $pending_payment	= $$userdata{$k}{pending_payment};
		my $pending_verif	= $$userdata{$k}{pending_email_verification} && $PREF{require_email_verification_for_new_signups} =~ /yes/i;
		my $pending_approval	= $$userdata{$k}{pending_admin_approval} && $PREF{require_admin_approval_for_new_signups} =~ /yes/i;

		$ubfields{ubpendpaymt}	= $pending_payment ? 'yes' : 'no';
		$ubfields{ubsincelogin}	= $lastlogin ? int((offsettime() - $lastlogin) / (60*60*24)) : 0;
		$ubfields{ubdaysinactive}= $lastactive ? int((offsettime() - $lastactive) / (60*60*24)) : 0;


		my $filter_match_fail = 0;
		foreach my $j (1..3)
		{
			my $ftrfield = get_qs_var("ftr${j}f");
			my $ftrvalue = get_qs_var("ftr${j}v");
			my $ftr_op = get_qs_var("ftr${j}op");
			next if !$ftrfield;

			foreach my $field (keys %ubfields)
			{
				if($ftr_op eq 'eq')	{ $filter_match_fail = 1 if $ftrfield eq $field && $ubfields{$field} !~ /$ftrvalue/i; }
				elsif($ftr_op eq 'ne')	{ $filter_match_fail = 1 if $ftrfield eq $field && $ubfields{$field} =~ /$ftrvalue/i; }
				elsif($ftr_op eq 'gt')	{ $filter_match_fail = 1 if $ftrfield eq $field && $ubfields{$field} <= $ftrvalue; }
				elsif($ftr_op eq 'lt')	{ $filter_match_fail = 1 if $ftrfield eq $field && $ubfields{$field} >= $ftrvalue; }
			}

			my $groups_match = 0;
			foreach my $group (@groups_raw)
			{
				if($ftr_op eq 'eq')	{ $groups_match = 1 if $group =~ /$ftrvalue/i; }
				elsif($ftr_op eq 'ne')	{ $groups_match = 1 if $group !~ /$ftrvalue/i; }
				# TODO? Implement gt/lt for group names?
			}
			$groups_match = 1 if !@groups_raw && $ftrvalue eq '';
			$filter_match_fail = 1 if $ftrfield eq 'ubgroups' && !$groups_match;

			my $custom_fields_match = 1;
			foreach my $custfield (sort { $a <=> $b } keys %custom_fields)
			{
				my $custfield = $custom_fields{$custfield}{name};
				my $custvalue = $$userdata{$k}{$custfield};
				next unless $ftrfield eq $custfield;

				#if($ftrvalue eq '')	{ $custom_fields_match = 0 if $custvalue ne $ftrvalue; }
				#else			{ $custom_fields_match = 0 if $custvalue !~ /$ftrvalue/i; }

				if($ftr_op eq 'eq')	{ $custom_fields_match = 0 if $custvalue !~ /$ftrvalue/i; }
				elsif($ftr_op eq 'ne')	{ $custom_fields_match = 0 if $custvalue =~ /$ftrvalue/i; }
				elsif($ftr_op eq 'gt')	{ $custom_fields_match = 0 if $custvalue <= $ftrvalue; }
				elsif($ftr_op eq 'lt')	{ $custom_fields_match = 0 if $custvalue >= $ftrvalue; }
			}
			$filter_match_fail = 1 unless $custom_fields_match;
		}
		next if $filter_match_fail;

		$rows{$i}{uid}		= $id;
		$rows{$i}{ubcheckboxes}	= qq`<td class="col_ubcheckboxes" $hidden_cells{ubcheckboxes}><input type="checkbox" class="acctboxes" name="acctchkbox$id" id="acctchkbox$id" /></td>`;
		$rows{$i}{ubusername}	= qq`<td class="col_ubusername" $hidden_cells{ubusername}>$username</td>`;
		$rows{$i}{ubpassword}	= qq`<td class="col_ubpassword" $hidden_cells{ubpassword}>$$userdata{$k}{password}</td>`;
		$rows{$i}{ubgroups}	= qq`<td class="col_ubgroups" $hidden_cells{ubgroups}>` . (join '<br />', sort { lc($a) cmp lc($b) } @groups) . qq`</td>` if user_is_allowed_to('see_groups_on_user_form');
		$rows{$i}{ubrealname}	= ($PREF{use_builtin_realname_field} =~ /yes/i ? qq`<td class="col_ubrealname" $hidden_cells{ubrealname}>$name</td>` : '');
		$rows{$i}{ubemail}	= qq`<td class="col_ubemail" $hidden_cells{ubemail}><a href="mailto:$email">$email</a></td>`;
		$rows{$i}{ubcreatedate}	= qq`<td class="col_ubcreatedate" $hidden_cells{ubcreatedate}>` . strftime($PREF{date_format_for_users_page},localtime($cdate)) . qq`</td>`;
		$rows{$i}{ubpendpaymt}	= qq`<td class="col_ubpendpaymt" $hidden_cells{ubpendpaymt}>$ubfields{ubpendpaymt}</td>`;
		$rows{$i}{ubloggedin}	= qq`<td class="col_ubloggedin" $hidden_cells{ubloggedin}>` . ($loggedin && !login_session_expired($loggedin) ? 'yes' : 'no') . qq`</td>`;
		$rows{$i}{ublastlogin}	= qq`<td class="col_ublastlogin" $hidden_cells{ublastlogin}>` . ($lastlogin ? strftime($PREF{date_format_for_users_page},localtime($lastlogin)) : '00000000-0000') . qq`</td>`;
		$rows{$i}{ubsincelogin}	= qq`<td class="col_ubsincelogin" $hidden_cells{ubsincelogin}>$ubfields{ubsincelogin}</td>`;
		$rows{$i}{ublastactive}	= qq`<td class="col_ublastactive" $hidden_cells{ublastactive}>` . ($lastactive ? strftime($PREF{date_format_for_users_page},localtime($lastactive)) : '00000000-0000') . qq`</td>`; # note: using "00000000-0000" rather than "never" so it sorts properly.
		$rows{$i}{ubfirst_visit_today} = qq`<td class="col_ubfirst_visit_today" $hidden_cells{ubfirst_visit_today}>$first_visit_today</td>`;
		$rows{$i}{ubdaysinactive}= qq`<td class="col_ubdaysinactive" $hidden_cells{ubdaysinactive}>$ubfields{ubdaysinactive}</td>`;
		$rows{$i}{ubdaysexp}	= qq`<td class="col_ubdaysexp" $hidden_cells{ubdaysexp}>$ubfields{ubdaysexp}</td>`;
		$rows{$i}{ubtxnids}	= qq`<td class="col_ubtxnids" $hidden_cells{ubtxnids}>$ubfields{ubtxnids_html}</td>`;

		my $actions_links = qq`<a href="$PREF{login_url}?action=edituser&amp;id=$id">edit</a>&nbsp; <a href="#" onclick="if(window.confirm('$TEXT{Are_you_sure_you_want_to_delete_user} $username?')) { location.href='$ENV{SCRIPT_NAME}?action=commitdeleteuser&amp;id=$id'; } return false;">delete</a>`;

		if($pending_payment || $pending_verif || $pending_approval)
		{
			$num_pending++;
			$rows{$i}{pending} = 1;

			my $pending_msg	 = '';
			$pending_msg	.= 'pending payment, '			if $pending_payment;
			$pending_msg	.= 'pending email verification, '	if $pending_verif;
			$pending_msg	.= 'pending admin approval, '		if $pending_approval;
			$pending_msg	=~ s!,\s*$!!;
			$pending_msg	||= 'pending';

			$rows{$i}{ubactions} = qq`<td class="col_ubactions" $hidden_cells{ubactions}><a href="$PREF{login_url}?action=approve_or_del&amp;uid=$id">$pending_msg</a></td>`;
		}
		elsif($$userdata{$k}{acct_disabled})
		{
			$num_disabled++;
			$rows{$i}{disabled} = 1;
			$rows{$i}{ubactions} = qq`<td class="col_ubactions" $hidden_cells{ubactions}><span class="disabled_label">disabled&nbsp; </span>$actions_links</td>`;
		}
		else
		{
			$num_active++;
			$rows{$i}{active} = 1;
			$rows{$i}{ubactions} = qq`<td class="col_ubactions" $hidden_cells{ubactions}>$actions_links</td>`;
		}

		foreach my $field (sort { $a <=> $b } keys %custom_fields)
		{
			my $name = $custom_fields{$field}{name};
			my $value = $$userdata{$k}{$name};
			$rows{$i}{$name} = qq`<td class="col_$name" $hidden_cells{$name}>$value</td>`;
		}

		$i++;
	}

	my $add_user_label = logged_in_user_is_subgroup_manager() ? $TEXT{Add_User___subadmin} : $TEXT{Add_User};

	$i = 1;
	print qq`<tr class="` . oddeven($i) . qq`"><td colspan="20" style="font-style: italic;"><a href="$PREF{login_url}?action=adduser">$add_user_label</a></td></tr>\n` if scalar(keys %rows) > 15;

	my $sortkey = $qs =~ /(?:^|&)sort=(\w+?)(?:&|$)/ ? $1 : $PREF{default_sort_column_for_user_manager};
	my $reverse = $qs =~ /(?:^|&)reverse=1(?:&|$)/ ? 1 : 0; # toggle the 1s and 0s to reverse by default or not.
	foreach my $row (sort { $reverse ? lc($rows{$b}{$sortkey}) cmp lc($rows{$a}{$sortkey}) : lc($rows{$a}{$sortkey}) cmp lc($rows{$b}{$sortkey}) } keys %rows)
	{
		my $oddeven = oddeven($i);
		my $status = $rows{$row}{active} ? 'active' : $rows{$row}{disabled} ? 'disabled' : 'pending';
		print qq`<tr id="ub-uid-$rows{$row}{uid}" class="$oddeven $status">`;
		foreach my $column (sort { $a <=> $b } keys %columns)
		{
			print $rows{$row}{ $columns{$column}{name} };
		}
		print qq`</tr>\n`;
	}

	print qq`<tr class="usersfooter ` . oddeven($i) . qq`"><td colspan="20">
			<button id="selectall_btn" name="selectall" onclick="select_boxes('showusers',true)">$TEXT{Select_All}</button>
			<button id="selectnone_btn" name="selectnone" onclick="select_boxes('showusers',false)">$TEXT{Select_None}</button>
			<button id="deleteselected_btn" name="deleteselected" onclick="delete_selected_accounts('showusers')"><i class="fa fa-user-times fa-lg"></i> $TEXT{Delete_Selected}</button>
			<button id="adduser_btn" name="adduser" onclick="location.href='$PREF{login_url}?action=adduser'"><i class="fa fa-user-plus fa-lg"></i> $add_user_label</button>
		</td></tr>\n`;
	print qq`</table>\n</div>\n`;

	if(user_is_allowed_to($PREF{logged_in_userid}, 'view_all_accounts'))
	{
		print	  qq`<div class="table-footer-info">Accounts: `
			. qq`$num_active active`
			. qq` / $num_pending pending`
			. qq` / $num_disabled disabled`
			. ' / ' . get_num_loggedin_users() . ' logged in'
			. qq`</div>\n`;
	}

	my $qsforpages = $qs; $qsforpages =~ s!(^|&)which=(?:all|[A-Za-z])(&|$)!$1$2!g; defooify('&', $qsforpages);
	print qq`<p class="listug-letters">Browse:\n<a href="$PREF{login_url}?$qsforpages&amp;which=all"` . ('all' eq lc($letter) ? ' class="current"' : '') . qq`>All</a>`;
	foreach my $char ('A'..'Z', 0..9)
	{
		print qq`<a href="$PREF{login_url}?$qsforpages&amp;which=$char"` . ($char eq uc($letter) ? ' class="current"' : '') . qq`>$char</a>`;
	}
	print qq`\n</p>`;


	print_account_list_filters(\%columns) if $PREF{account_list_filters_position} ne 'top';


	print qq`

	<script type="text/javascript">

	function toggle_column(theclass)
	{
		var rows = gebi('showusers').getElementsByTagName('tr');
		var col_is_hidden = 0;

		var cells = new Array;
		for(i = 0; i < rows.length; i++)
		{
			var headers = rows[i].getElementsByTagName('th');
			for(j = 0; j < headers.length; j++)
				if(headers[j].className == theclass)
					cells.push(headers[j]);

			var nonheaders = rows[i].getElementsByTagName('td');
			for(j = 0; j < nonheaders.length; j++)
				if(nonheaders[j].className == theclass)
					cells.push(nonheaders[j]);
		}
		for(i = 0; i < cells.length; i++)
		{
			if(cells[i].style.display == 'none')
			{
				cells[i].style.display = navigator.userAgent.indexOf("MSIE") ==  -1 ? 'table-cell' : 'block'; // IE doesn't support table-cell...
				gebi("link-" + theclass).style.textDecoration = '';
			}
			else
			{
				cells[i].style.display = 'none';
				gebi("link-" + theclass).style.textDecoration = 'line-through';
				col_is_hidden = 1;
			}
		}

		set_visible_cols_cookie(theclass, col_is_hidden);
	}

	</script>

	`;

	finish_html_output();
}


sub print_account_list_filters($)
{
	my $cols_hashref = shift; my %columns = %$cols_hashref;
	print qq`<div id="acct_list_filter_div">
		<form method="get" action="$PREF{login_url}" name="acct_list_filter_form" id="acct_list_filter_form">
		<input type="hidden" name="action" value="showusers" />
		<input type="hidden" name="which" value="all" />
		$TEXT{accountlist_filter_label}`;
	foreach my $j (1..3)
	{
		my $field = get_qs_var("ftr${j}f");
		my $value = get_qs_var("ftr${j}v");
		my $op = get_qs_var("ftr${j}op") || 'eq';
		print qq`<select name="ftr${j}f"><option></option>`;
		foreach my $column (sort { $a <=> $b } keys %columns)
		{
			my $name = $columns{$column}{name};
			next if $name =~ /^(ubcreatedate|ubloggedin|ublastlogin|ublastactive|ubactions|ubcheckboxes)$/i;
			print qq`<option value="$name" ` . ($name eq $field ? qq`selected="selected"` : '') . qq`>$columns{$column}{title}</option>\n`;
		}
		print qq`</select>
		<button type="button" onclick="cycle_filter_ops('ftr${j}');return false" name="ftr${j}op_btn" id="ftr${j}op_btn">`
			. ($op eq 'eq' ? '=' : $op eq 'ne' ? '&#8800;' : $op eq 'gt' ? '&gt;' : '&lt;') . qq`</button>
		<input type="hidden" name="ftr${j}op" id="ftr${j}op" value="$op" />
		<input type="text" name="ftr${j}v" id="acct_list_ftr${j}v" class="acct_list_filter" value="$value" />
		`;
	}
	print qq`<input type="submit" id="acct_list_filter_submit" value="Filter" />\n</form>\n</div>\n\n`;
}


sub get_num_loggedin_users
{
	my $num = 0;
	my $login_times = enc_sql_select_multi("SELECT `loggedin` FROM `$PREF{user_table}`");
	foreach my $i (keys %$login_times)
	{
		$num++ if $$login_times{$i}{loggedin} && !login_session_expired($$login_times{$i}{loggedin});
	}
	return $num;
}


sub get_num_accounts
{
	unless($PREF{num_active_accounts} || $PREF{num_pending_accounts} || $PREF{num_disabled_accounts})
	{
		($PREF{num_active_accounts}, $PREF{num_pending_accounts}, $PREF{num_disabled_accounts}) = (0, 0, 0);
		my $userids = enc_sql_select_multi("SELECT `id`,`acct_disabled` FROM `$PREF{user_table}`");
		foreach my $i (keys %$userids)
		{
			if($$userids{$i}{acct_disabled})		{ $PREF{num_disabled_accounts}++;	}
			elsif(account_is_pending($$userids{$i}{id}))	{ $PREF{num_pending_accounts}++;	}
			else						{ $PREF{num_active_accounts}++;		}
		}
	}
	return ($PREF{num_active_accounts}, $PREF{num_pending_accounts}, $PREF{num_disabled_accounts});
}


# new group-management sub:
sub show_groups_table
{
	my $tableprefname	= 'group_table';
	my $viewerprefname	= 'group';
	my $allowed_to_view	= user_is_allowed_to('view_all_groups');
	my $allowed_to_create	= user_is_allowed_to('create_groups');
	my $allowed_to_edit	= user_is_allowed_to('edit_group_info');
	my $allowed_to_delete	= user_is_allowed_to('delete_groups');




	$PREF{"${viewerprefname}_viewer_title"}					= 'Manage Groups';
	$PREF{"${viewerprefname}_viewer_item_name"}				= 'group';
	$PREF{"${viewerprefname}_viewer_header_note"}				= qq`<p>
		If you want to offer paid accounts, first <a href="$PREF{here_qsready}action=webconfig">enter
		your PayPal email address</a>.&nbsp; Next, create a new group below (e.g. named "paidaccounts")
		with a non-zero price, and enable its "Show on signup page" option.&nbsp; Then you can use
		<a href="$PREF{here_qsready}action=managepagelock">PageLock</a> and
		<a href="$PREF{here_qsready}action=dirlock">DirLock</a> to lock your pages and folders so that
		only paid members can access them.
	</p>`;

	$PREF{"${viewerprefname}_viewer_hidden_columns"}			= 'id,members,force_new_admincreated_accounts_to_join,force_new_subadmincreated_accounts_to_join,desc,managers,mainmenu_title,mainmenu_position,label_for_signup_page';
	$PREF{"${viewerprefname}_viewer_disabled_columns"}			= '';
	$PREF{"${viewerprefname}_viewer_uneditable_columns"}			= 'group,members';
	$PREF{"${viewerprefname}_viewer_uncreatable_columns"}			= 'members';
	$PREF{"${viewerprefname}_viewer_max_display_length"}			= 500;
	$PREF{"${viewerprefname}_viewer_itemsperpage"}				= 25;



	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{member_count}	= qq`to choose which members belong to which groups, go to your <a href="$PREF{login_url}?action=showusers">Manage Users page</a> and click the "edit" link for the user in question, then check the boxes for the appropriate groups`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{managers}	= qq`Managers (optional) receive email notifications whenever a user is added to or removed from the group`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{mainmenu_position} = qq`controls the order that multiple mainmenus are displayed in (on the <a href="$PREF{login_url}">Account Center</a> page), when the logged-in user belongs to multiple groups.&nbsp; Set to 0 to hide this menu.`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{type}		= qq`accounts in a temporary group are automatically removed from the group after the specified number of days; accounts in subscription groups are automatically re-billed after the specified number of days.&nbsp; Changing this setting does <strong>not</strong> affect any existing accounts.`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{price}		= 'optional: require payment for membership in this group';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{price_is_variable} = 'so users can enter their own prices, e.g. for donations.&nbsp; you still must enter a non-zero price in the price field, which will be the default price.';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{daily_access_limit} = "optional: limit each user to a certain number of minutes per day, starting from their first visit that day, after which they'll receive an access-denied error until the next day (0 to disable)";
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{ip_address_limit} = "optional: limit the number of times the same IP address can join this group, e.g. to prevent a user from re-joining a 'free trial' group. does not apply to admins adding users to groups. (0 to disable)";
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{code}		= 'item code, used only for paid accounts (and required in that case); e.g. ACCT001';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{length_in_days}	= '<strong>deprecated; use length_in_hours instead.</strong> optional: how long the group membership lasts. only used for temporary and subscription group types';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{length_in_hours}	= 'optional: how long the group membership lasts. only used for temporary and subscription group types. you can enter any number, or if you want to make them nice round values, then <br />enter 24 for 1 day,<br />or 168 for 1 week,<br />or 720 for 30 days,<br />or 8760 for 1 year.';
	$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{type}		= 'permanent|||temporary|||subscription';



	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			= qq`text-align: left;`;
	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		= qq`text-align: left;`;

	$PREF{"${viewerprefname}_viewer_extra_columns"}{edit_mainmenu}		= { position => 11, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{all_user_actions}	= { position => '', value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{member_count}		= { position => 6, value => '' };

	$PREF{"${viewerprefname}_creation_default_value"}{active}		= 1;
	$PREF{"${viewerprefname}_creation_default_value"}{mainmenu_title}	= '%%group%% Links:';
	$PREF{"${viewerprefname}_creation_default_value"}{mainmenu_position}	= 1;

	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{public_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{member_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{admin_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{expired_group_name}}	= 1;

	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{public_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{member_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{admin_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{expired_group_name}}	= 1;

	$PREF{"${viewerprefname}_viewer_unique_values"}{group}{ignorecase}			= 1;
	$PREF{"${viewerprefname}_viewer_unique_values"}{code}{ignorecase}			= 1;
	$PREF{"${viewerprefname}_viewer_unique_values"}{code}{ignorenull}			= 1;

	$PREF{"${viewerprefname}_viewer_column_is_toggle"}{show_on_signup_page}			= 1;

	# TODO: in the future we'll probably want to give the client (i.e. the webmaster)
	# the option to specify non-admins as managers for groups, possibly even somehow
	# using this as a replacement for / better implementation of the subgroup_manager
	# stuff?
	#
	my $admins = get_users_belonging_to_group({ group=>'admin', exclude_pending=>1 });
	foreach my $uid (sort { lc($$admins{$a}{username}) cmp lc($$admins{$b}{username}) } keys %$admins)
	{
		$PREF{"${viewerprefname}_viewer_column_is_multibox"}{managers}			.= $uid . '///' . qq`<a href="$PREF{login_url}?action=edituser&amp;id=$uid">` . $$admins{$uid}{username} . qq`</a>` . '|||';
	}
	$PREF{"${viewerprefname}_viewer_column_is_multibox"}{managers} =~ s!\|\|\|$!!; # strip the trailing '|||'.

	$PREF{"${viewerprefname}_viewer_display_value_if_null"}{members}			= '(none)';

	$PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{label_for_signup_page}	= 1;
	$PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{mainmenu_title}		= 1;
	$PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{mainmenu_position}		= 1;

	$PREF{"${viewerprefname}_viewer_title_transforms"}{desc}		= 'Description';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{ip_address_limit}	= 'IP address limit';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{force_new_admincreated_accounts_to_join}	= 'Force new admin-created accounts to join';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{force_new_subadmincreated_accounts_to_join}	= 'Force new subadmin-created accounts to join';

	$PREF{"${viewerprefname}_viewer_value_transforms"}{group}		= qq`%%variable%% = is_builtin_group(%%variable%%) ? '<strong>'.%%variable%%.'</strong>' : %%variable%%;`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{active}		= qq`%%variable%% = is_builtin_group('%%group___raw%%') ? "yes" : %%variable%%;`;

	$PREF{"${viewerprefname}_viewer_value_transforms"}{members}		= qq`

		if('%%group___raw%%' =~ /^($PREF{public_group_name}|$PREF{member_group_name})\$/i)
		{
			%%variable%% = '(all)';
		}
		else
		{
			my \$output = '';
			for(split(/,/,%%variable%%))
			{
				if(get_user_name(\$_))
				{
					\$output .= '<a href="$PREF{login_url}?action=edituser&amp;id=' . \$_ . '">' . get_user_name(\$_) . '</a><br />';
				}
			}
			%%variable%% = \$output;
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{member_count}		= qq`

		if('%%group___raw%%' =~ /^$PREF{public_group_name}\$/i)
		{
			%%variable%% = 'N/A';
		}
		elsif('%%group___raw%%' =~ /^$PREF{member_group_name}\$/i)
		{
			(%%variable%%,undef,undef) = get_num_accounts();
		}
		else
		{
			%%variable%% = '%%members___raw%%' ? ('%%members___raw%%' =~ tr/,//) + 1 : 0;
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{show_on_signup_page}	= qq`

		if(is_builtin_group('%%group___raw%%'))
		{
			%%variable%% = 'N/A';
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{label_for_signup_page}	= qq`

		if(is_builtin_group('%%group___raw%%'))
		{
			%%variable%% = 'N/A';
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{mainmenu_title}		= qq`

		if('%%group___raw%%' eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{mainmenu_position}		= qq`

		if('%%group___raw%%' eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
	`;



	$PREF{"${viewerprefname}_viewer_value_transforms"}{edit_mainmenu}		= qq`

		if('%%group___raw%%' eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
		else
		{
			#%%variable%% = '<a href="' . "$PREF{login_url}" . '?action=editmainmenu&amp;gid=%%id%%">' . "$TEXT{Edit_mainmenu}" . '</a>';

			%%variable%% = '<a href="$PREF{login_url}?action=editmainmenu&amp;gid=%%id%%">$TEXT{Edit_mainmenu}</a>'
		}

	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{all_user_actions}		= qq`

		if('%%group___raw%%' eq "$PREF{public_group_name}"   ||   '%%group___raw%%' eq "$PREF{member_group_name}")
		{
			%%variable%% = 'N/A';
		}
		else
		{
			%%variable%% = '<a class="addalluserstogroup" href="$PREF{login_url}?action=addallusers&amp;gid=%%id%%">$TEXT{Add_all_users_to_group}</a><br /><br /><a class="remallusersfromgroup" href="$PREF{login_url}?action=remallusers&amp;gid=%%id%%">$TEXT{Remove_all_users_from_group}</a>'
		}

	`;


	$PREF{"${viewerprefname}_viewer_value_verifications"}{group}{'01'}		= '

		unless(groupname_is_valid(%%variable%%))
		{
			%%variable%% = qq`die_from_eval:$PREF{invalid_groupname_message}`;
		}

	';

	$PREF{"${viewerprefname}_viewer_value_verifications"}{code}{'01'}		= '

		if("%%price%%" > 0 && !"%%code%%") { %%variable%% = qq`die_from_eval:smsg_e_missingcode`; }

	';


	$PREF{"${viewerprefname}_creation_oncomplete_code"}			= qq`create_mainmenu_table_for_group('%%group%%');`;
	$PREF{"${viewerprefname}_deletion_oncomplete_code"}			= qq`

		delete_mainmenu_table_for_group('%%group%%');
		remove_deleted_groupid_from_other_table_fields(%%id%%);
	
	`;


# This is from a custom client site (ronb); it's probably generally safe and a
# good idea, but may not be necessary in the general case, because the symptom
# here may have been caused by the custom import setup on that install.
#
#=item
# 20111002: making this live in dev.

	# Clean up any duplicate entries that occur in the members column.  These don't
	# really cause any problems, but they do artificially inflate the group member
	# counts, and can make the groups page load slowly.
	#
	if($allowed_to_create && $allowed_to_delete)
	{
		my $records = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}`");
		foreach my $j (sort { $a <=> $b } keys %$records)
		{
			my $members_list = $$records{$j}{members};
			my @new_members = ();
			my %members_done = ();
			foreach my $member_id (split(/,/, $members_list))
			{
				push (@new_members, $member_id) unless $members_done{$member_id};
				$members_done{$member_id} = 1;
			}
			my $new_members_list = join ",", @new_members;
			#encdebug "$$records{$j}{group}: old list: $members_list";
			#encdebug "$$records{$j}{group}: new list: $new_members_list";
			if($new_members_list ne $members_list)
			{
				enc_sql_update("UPDATE `$PREF{group_table}` SET `members`='$new_members_list' WHERE `id` = $$records{$j}{id}");
			}
		}
	}

#=cut



	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub remove_deleted_groupid_from_other_table_fields($)
{
	# For any tables containing fields which are comma-separated lists of group IDs, we need
	# to go through those fields and remove any instances of the deleted group's ID.

	my $id = shift;
	die_unless_numeric($id, "database record ID");

	my %fields_to_prune = ();
	#
	# TODO: anytime we add functionality that requires a new field containing group IDs, 
	# we need to add a line for that table and field to the %fields_to_prune hash here:
	#
	$fields_to_prune{ $PREF{custom_field_list_table} }{groups_allowed_to_view} = 1;
	$fields_to_prune{ $PREF{custom_field_list_table} }{groups_allowed_to_edit} = 1;

	foreach my $table (sort keys %fields_to_prune)
	{
		foreach my $field (sort keys %{$fields_to_prune{$table}})
		{
			my $records = enc_sql_select_multi("SELECT `$field` FROM `$table`");
			foreach my $j (keys %$records)
			{
				my $old_value = $$records{$j}{$field};
				if($old_value =~ /(^|,)$id(,|$)/)
				{
					my $new_value = $old_value;
					$new_value =~ s/(^|,)$id(,|$)/$1$2/g while $new_value =~ /(^|,)$id(,|$)/; # The ///g alone won't work when there are duplicates in sequence: it'll work on N,M,N but not N,N.
					decommaify($new_value);
					#print STDERR "remove_deleted_groupid_from_other_table_fields: about to do: UPDATE `$table` SET `$field`='$new_value' WHERE `id`=$$records{$j}{id}   (old value: $old_value)\n";
					enc_sql_update("UPDATE `$table` SET `$field`='$new_value' WHERE `id`=$$records{$j}{id}");
				}
			}
		}
	}
}


sub create_random_salt()
{
	my $salt = generate_nonce();
	$salt = substr($salt, 0, $PREF{peraccount_salt_length});
	die_nice "no salt?\n" unless $salt;
	return $salt;
}


sub print_pwreset_page
{
	exit_with_error("Error: this feature is not enabled.") unless $PREF{enable_password_reset} =~ /yes/i;

	start_html_output("Password Reset");
	print qq`\n<p>If you have forgotten your password, you <br /> can reset it here.&nbsp; Enter your username <br /> or your email address:</p>`;
	print qq`\n<form accept-charset="UTF-8" action="$ENV{SCRIPT_NAME}?action=pwreset2" method="post">`;
	print qq`\n<input type="text" name="username" />`;
	print qq`\n<br /><br /><input type="submit" value="Request Password Reset" />`;
	print qq`\n</form>`;
	finish_html_output();
}


sub send_pwreset_email
{
	exit_with_error("Error: this feature is not enabled.") unless $PREF{enable_password_reset} =~ /yes/i;

	my $input = enc_param('username'); exit_with_error qq`You must enter your username.` unless $input;
	my $recipient = my $username = '';

	if(is_valid_email_address($input))
	{
		$recipient = $input;
		if($PREF{usernames_must_be_email_addresses} =~ /yes/i)
		{
			$username = $recipient;
		}
		else
		{
			$username = enc_sql_select("SELECT `username` FROM `$PREF{user_table}` WHERE LOWER(`email`) = LOWER('$recipient');");
		}
	}
	else
	{
		$username = $input;
		check_username_for_sql_safeness($username);
		$recipient = enc_sql_select("SELECT `email` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");
	}

	my $username_urlencoded = $username; enc_urlencode($username_urlencoded);
	my $account_exists = enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");

	# Sleep for a few seconds.  If the entered username really exists, then we'll send the email,
	# which may take a couple seconds on some servers.  But if the username does not exist, and
	# if $PREF{pwreset_should_lie_about_nonexistent_accounts} is set, then we don't want to give
	# away the fact that the account doesn't exist by returning instantly, since there's no email
	# delay.  So in both cases, sleep for a few seconds beforehand to obfuscate things.
	#
	sleep (int(rand(3)) + 2);

	if($account_exists   &&   is_valid_email_address($recipient))
	{
		my $requestdate = offsettime();
		my $token = generate_nonce();

		die_unless_numeric($requestdate, 'requestdate');
		exit_with_error("Invalid token '$token'.") unless $token =~ /^\w+$/;
		my $sth = $PREF{dbh}->prepare("INSERT INTO `$PREF{pwreset_table}` (`username`, `token`, `requestdate`) VALUES('$username', '$token', '$requestdate');");
		$sth->execute() or die "$0: Error: send_pwreset_email(): could not insert new pwreset request into database: $DBI::errstr\n";

		my $email_msg =	  qq`Hello,\n\nSomeone (hopefully you) has requested a password reset for your account on the '$ENV{HTTP_HOST}' website.  To confirm this request, visit the following URL:`
				. qq`\n\n$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=pwreset3&t=$token&u=$username_urlencoded`
				. qq`\n\nIf you did not initiate this request, then you may discard this message.  It's probably just an honest mistake, but if you wish to pursue it further, the following technical information about the requester may be helpful:`
				. qq`\n\nIP Address: $PREF{ip}`
				. qq`\n\nHostname: $PREF{host}`
				. qq`\n\nUser-Agent: $ENV{HTTP_USER_AGENT}`
				. $PREF{password_reset_email_footer};

		send_email(	$recipient,
				$PREF{app_email_address},
				"Please confirm your password reset request",
				$email_msg,
				($PREF{pwreset_email_format} || $PREF{global_email_format}),
				'die_on_email_error'
			);

		enc_redirect("$PREF{login_url}?phase=spwrst2");
	}
	else
	{
		if($PREF{pwreset_should_lie_about_nonexistent_accounts} =~ /yes/i)
		{
			enc_redirect("$PREF{login_url}?phase=spwrst2");
		}
		else
		{
			if($account_exists)
			{
				enc_redirect("$PREF{login_url}?phase=epwrst2");
			}
			else
			{
				enc_redirect("$PREF{login_url}?phase=epwrst3");
			}
		}
	}
}


sub process_pwreset
{
	exit_with_error("Error: this feature is not enabled.") unless $PREF{enable_password_reset} =~ /yes/i;

	my ($token,$username) = ($qs =~ /&t=(\w+?)&u=(.+?)(?:&|$)/);
	enc_urldecode($username);

	exit_with_error("Invalid token '$token'.") unless $token =~ /^\w+$/;
	check_username_for_sql_safeness($username);

	sleep $PREF{password_reset_delay} || 10;   # this with $PREF{password_reset_timeout} protects against brute-force attacks.

	start_html_output("Password Reset");

	my $requestdate = enc_sql_select("SELECT `requestdate` FROM `$PREF{pwreset_table}` WHERE `token` = '$token' AND LOWER(`username`) = LOWER('$username');");
	if($requestdate =~ /^\d+$/   &&   $requestdate > 0)
	{
		my $pwreset_timeout = $PREF{password_reset_timeout} =~ /^(\d+)$/ ? $1 : 60 * 60;
		exit_with_error("Error: request date was too long ago; please submit a new password-reset request.") if (offsettime() - $requestdate) > $pwreset_timeout;

		my ($userid,$recipient) = enc_sql_select("SELECT `id`,`email` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");
		$recipient = $username if $PREF{usernames_must_be_email_addresses} =~ /yes/i;

		if($userid   &&   $recipient =~ /.+\@.+\..+/)
		{
			my $password = (); $password .= join('', (0..9, 'A'..'Z', 'a'..'z')[rand 62]) while length($password) < 12;
			my ($new_crypted_password, $salt) = create_new_password_hash($password);

			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `password` = '$new_crypted_password', `salt` = '$salt' WHERE `id` = '$userid';");
			die_nice("Error: process_pwreset(): SQL returned '$success' instead of '1' while resetting password (username='$username', new_crypted_password='$new_crypted_password').") unless $success == 1;

			update_password_activity_table($userid,$new_crypted_password,$salt,0);

			if($PREF{enable_forced_password_change} =~ /yes/i   &&   $PREF{force_pw_chng_after_password_reset} =~ /yes/i)
			{
				if(!enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';"))
				{
					my $statement = "UPDATE `$PREF{user_table}` SET `forcepwchng` = 1 WHERE `id` = '$userid';";
					my $success = enc_sql_update($statement);
					die_nice("Error: process_pwreset(username='$username'): SQL returned '$success' instead of '1' while enabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
				}
			}

			my $email_msg =	  qq`Hello,\n\nThe new temporary password for your "$username" account on the $ENV{HTTP_HOST} website is "$password" (without the quotes).  You should now log in to your account and change the password.`
					. qq`\n\nIf you did not initiate this password-reset request, then your account may be compromised.  Please contact the webmaster of this site, forwarding this message including the following technical information about the requester:`
					. qq`\n\nIP Address: $PREF{ip}`
					. qq`\n\nHostname: $PREF{host}`
					. qq`\n\nUser-Agent: $ENV{HTTP_USER_AGENT}`
					. $PREF{password_reset_email_footer};

			send_email(	$recipient,
					$PREF{app_email_address},
					"Your new temporary password",
					$email_msg,
					($PREF{pwreset_email_format} || $PREF{global_email_format}),
					'die_on_email_error'
				);

			my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{pwreset_table}` WHERE `token` = '$token' AND `requestdate` = '$requestdate';");
			$sth->execute() or die "$0: Error: process_pwreset(): could not delete pwreset request from database after resetting password: $DBI::errstr\n";

			# Clean up any stale requests while we're here...
			my $one_week_ago = offsettime() - (60 * 60 * 24 * 7);
			$sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{pwreset_table}` WHERE `requestdate` < '$one_week_ago';");
			$sth->execute() or die "$0: Error: process_pwreset(): could not delete stale pwreset requests from database: $DBI::errstr\n";

			print qq`<p>Your password was successfully reset.&nbsp; The new temporary password has been sent to you via email.</p>\n`;
		}
		else
		{
			print qq`<p>Error: could not find a valid email address on file for this account.</p>\n`;
		}
	}
	else
	{
		print qq`<p>Error: request date invalid or not found.&nbsp; If you still cannot access your account, please submit another password reset request.</p>\n`;
	}

	finish_html_output();
}


sub is_builtin_fieldname($)
{
	return 1 if $_[0] =~ /^(id|username|realname|name|email|password|oldpw|pw1|pw2|salt|cdate|loggedin|numusers|mrsession|lastactive|first_visit_today|failed_logins|ip|account_locked|account_disabled|forcepwchng|agreetoterms|group-.*|acct_locked|acct_disabled|pending_email_verification|completed_email_verification|pending_admin_approval|completed_admin_approval|pending_payment|email_verification_token|autogroup)$/i;
}


sub show_custom_fields_manager()
{
	#my $table_to_modify = $PREF{user_table};  ## note: we're using '$PREF{user_table}' itself throughout this func, for scoping reasons.
	#my $custom_field_list_table = $PREF{custom_field_list_table};

	my $tableprefname	= 'custom_field_list_table';
	my $viewerprefname	= 'custom_fields';
	my $allowed_to_view	= user_is_allowed_to('manage_custom_fields');
	my $allowed_to_create	= user_is_allowed_to('manage_custom_fields');
	my $allowed_to_edit	= user_is_allowed_to('manage_custom_fields');
	my $allowed_to_delete	= user_is_allowed_to('manage_custom_fields');


	$PREF{"${viewerprefname}_viewer_title"}					= 'Custom Fields Manager';

	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{fieldposition}	= 'sort order relative to other custom fields, e.g. 1, 2, 3... leave blank to use the next open spot';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{section}		= 'optional; see the <a href="' . $PREF{here_qsready} . 'action=fieldsections">Sections Manager</a>';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{fieldname}	= 'database column name, for example "address" or "phone_number" (no spaces)';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{fieldlabel}	= 'brief label, such as "Your Address" (spaces allowed)';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{fieldmax}	= 'this max length is a value from 1 to 255; it\'s only used if the data type is "varchar"';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{mandatory}	= 'means that your users must select or fill in some value';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{limitallowedchars} = 'only used for free-form fields; strongly recommended';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{listitems}	= 'only used for dropdown and radio fields; enter one per line';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{defaultvalue}	= 'Can include variables from various sources: %URL{foo}, %COOKIE{foo}, %SQL{select_statement}, %PREF{foo}, %DATE{datestring_format}';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{groups_allowed_to_edit}	= qq`Checking the $PREF{public_group_name} box automatically gives permission to all other groups (no need to check their boxes too).&nbsp; Checking the $PREF{member_group_name} box automatically gives permissions to all other groups except $PREF{public_group_name}.<br /><br />To give edit permissions to a group, you must also give view permissions to that group (above).`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{groups_allowed_to_view}	= qq`Checking the $PREF{public_group_name} box automatically gives permission to all other groups (no need to check their boxes too).&nbsp; Checking the $PREF{member_group_name} box automatically gives permissions to all other groups except $PREF{public_group_name}.`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{field_actions}	= qq`

		<strong>Field actions</strong> (optional) allow you to change the form as the user adjusts field values.&nbsp;
		The format is <strong>trigger: actiontype fieldname if self == "somevalue"</strong>
		where trigger can be onchange, onclick, onfocus, or onblur;
		actiontype can be either show or hide;
		fieldname can be any field name (preceded with "cust_field_", e.g. cust_field_phone),
		CSS ID, or <a href="$PREF{login_url}?action=fieldsections">field section</a>
		(preceded with "section_", e.g. section_personal_info);
		self can be literally "self" or a field name or CSS ID;
		and finally, the part after self can be any valid Javascript test.&nbsp;
		Putting it all together for a complete example:
		<strong>onclick: hide section_personal_info if self == "company"</strong>.&nbsp;
		You can specify multiple actions by putting a blank line between them (i.e. 2 newlines).
		<br /><br />Alternate format: you can replace <strong>self/CSS_ID == "somevalue"</strong>
		with <strong>self/CSS_ID custcode: if(foo bar baz...)</strong> where the
		"if(foo bar baz...)" can be whatever JS code you want for the test.
		<br /><br />Note that this code will also be executed once at the page's
		onload, in addition to your specified onchange/onclick/etc.


	`;


	$PREF{"${viewerprefname}_viewer_item_name"}				= 'field';
	$PREF{"${viewerprefname}_record_deletion_warning"}			= qq`Check this box to confirm that you want to delete the field <b>and all user data in this field!</b>`;
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id';
	$PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 30;

	$PREF{"${viewerprefname}_viewer_extra_columns"}{status}			= { position => 5, value => '' };
	$PREF{"${viewerprefname}_viewer_value_transforms"}{status}		= qq`%%variable%% = db_column_exists("%%fieldname%%", "$PREF{user_table}") ? '$TEXT{custom_field_OK_msg}' : '$TEXT{custom_field_DNE_msg}';`;
	#$PREF{"${viewerprefname}_viewer_value_transforms"}{date}		= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;




	$PREF{"${viewerprefname}_viewer_title_transforms"}{fieldmax}		= "Field max length";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{fieldposition}	= "Field position";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{limitallowedchars}	= "Limit allowed chars";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{allowedchars}	= "Allowed chars";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{allowedcharsmsg}	= "Allowed chars message";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{listitems}		= "List items";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{defaultvalue}	= "Default value";

	$PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'fieldposition';

	$PREF{"${viewerprefname}_viewer_force_textarea"}{allowedchars}		= 1;
	$PREF{"${viewerprefname}_viewer_force_textarea"}{listitems}		= 1;
	$PREF{"${viewerprefname}_viewer_force_textarea"}{defaultvalue}		= 1;
	$PREF{"${viewerprefname}_viewer_force_textarea"}{field_actions}		= 1;

	$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{datatype}	= "text///text|||"
										. "vrchr///short text (up to 255 characters) [varchar]|||"
										. "int///whole number [int]|||"
										. "uint///whole number, non-negative [unsigned int]|||"
										. "float///fractional number [float]|||"
										. "ufloat///fractional number, non-negative [unsigned float]|||"
										. "bool///true/false value [bool]";

	$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{fieldtype}	= "freeformsingle///free-form text entry, single line|||"
										. "freeformmulti///free-form text entry, multi line|||"
										. "dropdown///drop-down list|||"
										. "checkbox///checkbox|||"
										. "radio///radio buttons";


	my $groups = get_groups_hash();
	foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
	{
		my $gid = $$groups{$group}{id};
		$PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_view} .= $gid . '///' . qq`<a href="$PREF{login_url_qsready}action=groups&amp;editmode=true&amp;editid=$gid&amp;dbview=vert">$group</a>` . '|||';
		$PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_edit} .= $gid . '///' . qq`<a href="$PREF{login_url_qsready}action=groups&amp;editmode=true&amp;editid=$gid&amp;dbview=vert">$group</a>` . '|||';
	}
	$PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_view} =~ s!\|\|\|$!!; # strip the trailing '|||'.
	$PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_edit} =~ s!\|\|\|$!!; # strip the trailing '|||'.


	$PREF{"${viewerprefname}_viewer_value_transforms"}{section}		= '

		my $name = "N/A";
		if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`"))
		{
			my $section = "%%section%%";   # must be quoted (even though it is a number) because when no sections exist, %%section%% gets replaced with null before this code is eval{}d, resulting in the cryptic error "syntax error at (eval 12) line 6, at EOF".
			die_unless_numeric($section, "section in show_custom_fields_manager()");
			$name = enc_sql_select("SELECT `name` FROM `$PREF{field_sections_table}` WHERE `id` = $section");
		}
		$name = qq`[No name, or section deleted.]` if !$name;

		%%variable%% = "<a href=\"$PREF{login_url}?action=fieldsections\">$name</a>";

	';

	$PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{section}		= qq`SELECT id,name FROM $PREF{field_sections_table}`;
	$PREF{"${viewerprefname}_editmode_dropdown_from_SQL"}{section}		= qq`SELECT id,name FROM $PREF{field_sections_table}`;



	$PREF{"${viewerprefname}_creation_default_value"}{enabled}		= 1;
	$PREF{"${viewerprefname}_creation_default_value"}{fieldmax}		= 255;
	$PREF{"${viewerprefname}_creation_default_value"}{allowedchars}		= $PREF{list_of_sql_safe_characters};
	$PREF{"${viewerprefname}_creation_default_value"}{allowedcharsmsg}	= qq`Error: illegal character(s) in %%fieldname%% field; please go back and try again.`;







	$PREF{"${viewerprefname}_viewer_value_verifications"}{fieldmax}{'01'}		= 'preset:numeric,minvalue=0,maxvalue=255,nonnull';
	$PREF{"${viewerprefname}_viewer_value_verifications"}{datatype}{'01'}		= 'preset:word,maxlength=100,nonnull';
	$PREF{"${viewerprefname}_viewer_value_verifications"}{fieldtype}{'01'}		= 'preset:word,maxlength=100,nonnull';
	$PREF{"${viewerprefname}_viewer_value_verifications"}{allowedcharsmsg}{'01'}	= 'preset:maxlength=255';
	$PREF{"${viewerprefname}_viewer_value_verifications"}{fieldname}{'01'}		= 'preset:word,maxlength=100,nonnull';

	$PREF{"${viewerprefname}_viewer_value_verifications"}{fieldname}{'02'}		= '

		if(is_builtin_fieldname(%%variable%%))
		{
			%%variable%% = qq`die_from_eval:smsg_e_bltfld`;
		}

		if($PREF{db_editor_mode} eq "create"   &&   db_column_exists(%%variable%%, $PREF{user_table}))
		{
			%%variable%% = qq`die_from_eval:smsg_e_fldexist`;
		}

	';

	$PREF{"${viewerprefname}_viewer_value_verifications"}{fieldtype}{'02'}		= '

		if("%%fieldtype%%" =~ /^(dropdown|radio)$/ && !"%%listitems%%")	{ %%variable%% = qq`die_from_eval:smsg_e_listitems`; }

	';

	$PREF{"${viewerprefname}_viewer_value_verifications"}{fieldposition}{'01'}	= '

		if(%%variable%%   &&   %%variable%% !~ /^\d+$/)	{ %%variable%% = qq`die_from_eval:smsg_e_fieldpos`; }

	';










	# Make this one last because get_next_available_fieldpos_in_custom_fields_table()
	# does database updates, which won't hurt anything, but we'd rather not do them
	# if we're just going to error out on an invalid value in some other field.
	#
	#$PREF{"${viewerprefname}_POST_value_transforms"}{fieldposition}			= '
	#
	#	%%variable%% = get_next_available_fieldpos_in_custom_fields_table(%%variable%%) if !%%variable%%;
	#
	#';
	#
	$PREF{"${viewerprefname}_POST_value_transforms"}{fieldposition}			= 'preset:next_int_if_null_or_zero';







	$PREF{"${viewerprefname}_creation_oncomplete_code"} = '

		my $fieldname		= "%%fieldname%%";
		my $datatype		= "%%datatype%%";
		my $fieldmax		= "%%fieldmax%%";

		if(!db_column_exists($fieldname, $PREF{user_table}))
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` ADD `$fieldname` " . expand_abbreviated_datatype($datatype,$fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}

	';








	$PREF{"${viewerprefname}_editmode_oncomplete_code"} = '

		my $fieldname		= "%%fieldname%%";
		my $datatype		= "%%datatype%%";
		my $fieldmax		= "%%fieldmax%%";

		my $prev_fieldname	= "%%fieldname___old%%";
		my $prev_datatype	= "%%datatype___old%%";
		my $prev_fieldmax	= "%%fieldmax___old%%";

		if($fieldname ne $prev_fieldname)
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` CHANGE `$prev_fieldname` `$fieldname` " . expand_abbreviated_datatype($prev_datatype,$prev_fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}
		if($datatype ne $prev_datatype   ||   $fieldmax ne $prev_fieldmax)
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` MODIFY `$fieldname` " . expand_abbreviated_datatype($datatype,$fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}

		if(!db_column_exists($fieldname, $PREF{user_table})) # in case our listing somehow got out of sync with the actual db structure.
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` ADD `$fieldname` " . expand_abbreviated_datatype($datatype,$fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}

	';




	$PREF{"${viewerprefname}_deletion_oncomplete_code"} = '

		my $id = %%id%%;
		die_unless_numeric($id, "database record ID");
		my $fieldname = "%%fieldname%%";

		die_nice(qq`id=$id: cannot delete field "$fieldname" because it is one of our built-in fields.`) if is_builtin_fieldname($fieldname);
		die_nice(qq`id=$id: cannot delete field "$fieldname" because it contains illegal characters.`) if $fieldname !~ /^\w+$/;

		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` DROP COLUMN `$fieldname`");
		$sth->execute() or die_nice(qq`could not drop column "$fieldname" from user table ($PREF{user_table}): $DBI::errstr\n`);

	';






	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub expand_abbreviated_datatype($$)
{
	my ($datatype,$fieldmax) = @_;
	# 201608: changed our fieldname from 'varchar' to 'vrchr' because stupid GoDaddy apparently now blocks all
	# POSTs containing the string 'varchar'; they return a '406 Not Acceptable' error on the POST.
	return ($datatype =~ /vrchr|varchar/) ? "varchar($fieldmax)" : $datatype eq "uint" ? "INT UNSIGNED" : $datatype eq "ufloat" ? "FLOAT UNSIGNED" : $datatype;
}


sub get_next_available_fieldpos_in_custom_fields_table($)
{
	my $fieldposition = shift;
	my $max_position = enc_sql_select("SELECT MAX(`fieldposition`) FROM `$PREF{custom_field_list_table}`");
	$max_position = 0 unless $max_position =~ /^\d+$/;
	my $next_position = $max_position + 1;
	$fieldposition = $next_position unless $fieldposition =~ /^\d+$/;
	my $pos_is_taken = enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}` WHERE `fieldposition` = $fieldposition");
	if(($fieldposition < $next_position)   &&   $pos_is_taken)
	{
		my $current_position = $max_position;
		while($current_position >= $fieldposition)
		{
			enc_sql_update("UPDATE `$PREF{custom_field_list_table}` SET `fieldposition` = $current_position + 1 WHERE `fieldposition` = $current_position");
			$current_position--;
		}
		# now every field has been shifted up (increased fieldposition value) by 1 position,
		# and there is no field whose position is $fieldposition.
	}
	return $fieldposition;
}


sub show_field_sections_manager()
{
	my $tableprefname	= $PREF{field_sections_table};
	my $viewerprefname	= 'field_sections';
	my $allowed_to_view	= user_is_allowed_to('manage_field_sections');
	my $allowed_to_create	= user_is_allowed_to('manage_field_sections');
	my $allowed_to_edit	= user_is_allowed_to('manage_field_sections');
	my $allowed_to_delete	= user_is_allowed_to('manage_field_sections');


	$PREF{"${viewerprefname}_viewer_title"}					= 'Sections Manager';
	$PREF{"${viewerprefname}_viewer_header_note"}				= qq`<p>
		The Sections Manager allows you to display your user data fields in different sections,
		for visual/organizational purposes.&nbsp; If you don't create any sections here, then all
		your fields will be displayed in a single list.&nbsp; If you do create sections, then the
		built-in fields (username, email, password, etc) will be displayed within the section with
		the lowest Section Position value.&nbsp; <strong>Note:</strong> if you create
		any <a href="$PREF{login_url}?action=customfields">Custom Fields</a> before creating any
		sections here -- or if you delete all your sections -- then when you do (re)create your first
		section, all existing custom fields will have their section automatically set to that first section.
	</p>`;

	$PREF{"${viewerprefname}_viewer_footer_note"}				= qq`<p><em>
		<strong>Name:</strong> a short name without spaces, to identify the section.&nbsp; 
		<strong>Label:</strong> the user-visible title/label for the section; can be longer (up to 255 characters).
	</em></p>`;

	$PREF{"${viewerprefname}_viewer_item_name"}				= 'section';
	#$PREF{"${viewerprefname}_viewer_forced_mode"}				= 'horiz';
	$PREF{"${viewerprefname}_viewer_hide_column_toggles"}			= 'yes';
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			= 'id';
	$PREF{"${viewerprefname}_viewer_disabled_columns"}			= '';
	$PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'section_position';


	$PREF{"${viewerprefname}_viewer_value_verifications"}{name}{01}		= 'preset:word,nonnull';
	$PREF{"${viewerprefname}_POST_value_transforms"}{name}			= 'preset:make_lowercase';
	$PREF{"${viewerprefname}_POST_value_transforms"}{section_position}	= 'preset:next_int_if_null_or_zero';


	$PREF{"${viewerprefname}_creation_oncomplete_code"} = '

		my $id = %%id%%;
		my $num_sections = enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`");
		#if($id == 1 && $num_sections == 1)
		if($num_sections == 1)
		{
			# This is the first section created in this installation, so if there
			# are any existing custom fields, set their section to this new section.
			if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
			{
				my $success = enc_sql_update("UPDATE `$PREF{custom_field_list_table}` SET `section` = $id");
				die_nice(qq`SQL returned "$success" (instead of at least 1) while updating "section" to $id for all records.`) unless $success > 0;
			}
		}

	';


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub manage_promos()
{
	my $tableprefname	= 'promo_table';
	my $viewerprefname	= 'promo';
	my $allowed_to_view	= user_is_allowed_to('view_promo_db');
	my $allowed_to_create	= user_is_allowed_to('create_promos');
	my $allowed_to_edit	= user_is_allowed_to('edit_promo_db');
	my $allowed_to_delete	= user_is_allowed_to('delete_promos');



	$PREF{"${viewerprefname}_viewer_title"}						= 'Promo Codes';
	$PREF{"${viewerprefname}_viewer_item_name"}					= 'promo code';
	$PREF{"${viewerprefname}_viewer_header_note"}					= qq`<p>For use with any <a href="$PREF{login_url}?action=groups">paid accounts</a> that you have enabled.&nbsp; You must also create a <a href="$PREF{login_url}?action=customfields">custom field</a> with the fieldname "promo_code" to enable the promo codes feature.</p>\n`;

	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{promo_code}	= 'e.g. FIVEOFF, SAVEBIG, etc';
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{value}		= qq`the amount of the discount, either in dollars (or whichever currency you're using), or percent.&nbsp; enter only numbers (and optionally a dot); don't include currency signs nor percent signs.`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{activation_date}	= qq`(optional) a date in YYYYMMDD format on which this promo code will automatically be activated, if it was inactive before`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{expiration_date}	= qq`(optional) a date in YYYYMMDD format after which this promo code will automatically be deactivated`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{redemption_limit}= qq`(optional) limit the number of times this promo code can be used. when the limit is reached, this promo code will automatically be deactivated`;
	$PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{redemption_count}= qq`Number of times this promo code has been used.&nbsp; UserBase will update this automatically, so you don't need to set or adjust it, but you can reset it to zero if you've set a limit and it's been reached.`;

	$PREF{"${viewerprefname}_creation_autoset_columns"}{timestamp_created}		= qq`%%variable%% = offsettime();`;

	$PREF{"${viewerprefname}_viewer_hidden_columns"}				||= qq`id,timestamp_created,date_created`;
	$PREF{"${viewerprefname}_viewer_uneditable_columns"}				||= qq`timestamp_created`;

	$PREF{"${viewerprefname}_viewer_extra_columns"}{date_created}			= { position => 'default', value => '' };

	$PREF{"${viewerprefname}_viewer_value_transforms"}{date_created}		= qq`%%variable%% = strftime("%Y%m%d-%H:%M",localtime(%%timestamp_created%%));`;

	$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{type}		= qq`Percentage Discount|||Flat Discount`;

	$PREF{"${viewerprefname}_viewer_column_is_toggle"}{active}			= 1;
	$PREF{"${viewerprefname}_viewer_unique_values"}{promo_code}{ignorecase}		= 1;

	$PREF{"${viewerprefname}_viewer_column_is_multibox"}{valid_for_groups} = get_grouplist_multibox({ only_paid_groups=>1 });




	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"}, 'css', 'js');
	print $output;
	finish_html_output();
}


sub activate_and_deactivate_promo_codes
{
	my $promos = enc_sql_select_multi("SELECT * from `$PREF{promo_table}`");
	foreach my $j (keys %$promos)
	{
		# Check for expired ones:
		if(	($$promos{$j}{redemption_limit}   &&   ($$promos{$j}{redemption_count} >= $$promos{$j}{redemption_limit}))
		||	($$promos{$j}{expiration_date}   &&   ($PREF{date8} >= $$promos{$j}{expiration_date}))
		)
		{
			encdebug qq`promo code expired: $$promos{$j}{promo_code} - deactivating...`;
			enc_sql_update("UPDATE `$PREF{promo_table}` SET `active` = 0 WHERE `id` = '$$promos{$j}{id}'");
		}

		# Check for ones that need to be activated:
		if(   $$promos{$j}{activation_date}   &&   ($$promos{$j}{activation_date} == $PREF{date8})   )
		{
			encdebug qq`promo code activation_date is today: $$promos{$j}{promo_code} - activating...`;
			enc_sql_update("UPDATE `$PREF{promo_table}` SET `active` = 1 WHERE `id` = '$$promos{$j}{id}'");
		}
	}
}


#
# Precondition: check_username_for_sql_safeness($input_username).
#
sub account_exceeds_failed_login_limit
{
	my $input_username = $_[0];
	my $increment_failure_count = $_[1] eq 'increment' ? 1 : 0;

	my $failed_login_limit_exceeded = 0;

	if($PREF{lock_account_after_N_failed_logins} =~ /^\d+$/)
	{
		return unless enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$input_username';"); # account DNE.

		my ($recent_failed_attempts, $recent_failure_count) = ();

		if($increment_failure_count)
		{
			$recent_failed_attempts	= offsettime() . ',';
			$recent_failure_count	= 1;
		}

		my $failed_attempts = enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");

		foreach my $failure_time (split(/,/, $failed_attempts))
		{
			if($PREF{failed_logins_within_N_secs_count_towards_lock} =~ /^\d+$/)
			{
				if(offsettime() - $failure_time < $PREF{failed_logins_within_N_secs_count_towards_lock})
				{
					$recent_failed_attempts .= $failure_time . ',';
					$recent_failure_count++;
				}
			}
			else # all failures are "recent", i.e. we don't care how long ago they occurred.
			{
				$recent_failed_attempts .= $failure_time . ',';
				$recent_failure_count++;
			}
		}

		decommaify($recent_failed_attempts);
		sql_untaint($recent_failed_attempts);
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `failed_logins` = '$recent_failed_attempts' WHERE `username` = '$input_username';");
		die_nice("Error: account_exceeds_failed_login_limit(input_username='$input_username'): SQL returned '$success' instead of '1' while updating failed_logins.") unless $success == 1;

		if($recent_failure_count >= $PREF{lock_account_after_N_failed_logins})
		{
			$failed_login_limit_exceeded = 1;
		}
	}

	return $failed_login_limit_exceeded;
}


sub redirect_to_payment_page()
{
	my $uid = get_qs_var('uid');
	exit_with_error qq`Missing/invalid user ID.` unless $uid =~ /^\d+$/;
	enc_redirect("$PREF{login_url}?action=joinpaidgroup&uid=$uid");
}


sub join_paid_group
{
	exit_with_error(qq`This feature is disabled in the trial version of UserBase. <a href="http://encodable.com/userbase/">Get the full version!</a>`);
}


sub join_paid_group_for_subusers
{
	exit_with_error(qq`This feature is disabled in the trial version of UserBase. <a href="http://encodable.com/userbase/">Get the full version!</a>`);
}


sub print_paid_group_payment_confirmation_page
{
	my $template = $PREF{join_paid_group_confirmation_page_template};
	$template =~ s!%PREF{(\w+)}!$PREF{$1}!gis;
	start_html_output($PREF{join_paid_group_confirmation_page_title});
	print $template;
	finish_html_output();
}


sub get_paid_group_price_label($$)
{
	my ($grouptype, $period_in_hours) = @_;
	my $price_label = '';

	my $period = get_paid_group_period_label($grouptype, $period_in_hours);

	if($grouptype eq 'permanent')
	{
		$price_label = $PREF{join_paid_group_price_label___permanent};
	}
	elsif($grouptype eq 'temporary')
	{
		$price_label = ' for ' . $PREF{join_paid_group_price_label___temporary};
		$price_label =~ s!%%period%%!$period!g;
	}
	elsif($grouptype eq 'subscription')
	{
		$price_label = ' per ' . $PREF{join_paid_group_price_label___subscription};
		$price_label =~ s!%%period%%!$period!g;
	}
	else
	{
		$price_label = 'error: invalid group type';
	}
	return $price_label;
}


sub get_paid_group_period_label($$)
{
	my ($grouptype, $period_in_hours) = @_;
	my $period_in_days = int($period_in_hours / 24);

	# Start by setting the label to "N days".
	my $period_with_unit = $period_in_days . ' days';

	# But if it's some unusual number of hours <72, display it in hours instead:
	$period_with_unit = $period_in_hours . ' hours' if $period_in_hours < 72 && $period_in_hours !~ /^(24|48)$/;

	# And if it's exactly 1 hour/day/year/month/etc, then show that instead of "N days":
	$period_with_unit = 'hour'	if $period_in_hours == 1;
	$period_with_unit = 'day'	if $period_in_hours == 24;
	$period_with_unit = 'year'	if $period_in_days == 365;
	$period_with_unit = 'month'	if $period_in_days == 30 || $period_in_days == 31;
	$period_with_unit = 'week'	if $period_in_days == 7;
	$period_with_unit = 'quarter'	if $period_in_days == 90;

	if($grouptype eq 'permanent')
	{
		$period_with_unit = 'lifetime access';
	}
	elsif($grouptype eq 'temporary')
	{
		$period_with_unit = "1 $period_with_unit" unless $period_with_unit =~ /^\d+ /;
	}

	return $period_with_unit;
}


sub paid_groups_enabled
{
	if(!exists $MISC{paid_groups_enabled})
	{
		$MISC{paid_groups_enabled} = enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `price` > 0 AND `active` = 1");
	}
	return $MISC{paid_groups_enabled};
}


sub get_promo_price
{
	my $promocode = shift;
	my $price = shift;
	my $groupid = shift;
	sql_untaint($promocode); die_unless_sqlsafe($promocode);
	my ($promo_value, $promo_type, $list_of_valid_groupids) = enc_sql_select("SELECT `value`,`type`,`valid_for_groups` FROM `$PREF{promo_table}` WHERE `active` = 1 AND `promo_code` = '$promocode'");
	return $price unless $list_of_valid_groupids =~ /(^|\|\|\|)$groupid(\|\|\||$)/;
	if($promo_value)
	{
		if($promo_type =~ /percent/i)
		{
			$price *= ((100 - $promo_value) / 100);
		}
		else
		{
			$price -= $promo_value;
		}
		$price = 0 if $price < 0;
		$price = sprintf("%.2f", $price);
	}
	return $price;
}


sub get_promo_code_for_user
{
	my $uid = shift;
	die_unless_numeric($uid, 'userid');
	if(db_column_exists("promo_code", $PREF{user_table}))
	{
		# can't just use $PREF{ub_var_promo_code}, because users who've just signed up can access this page before they're logged in.
		return enc_sql_select("SELECT `promo_code` FROM `$PREF{user_table}` WHERE `id` = $uid");
	}
}


sub view_payment_summary()
{
	exit_with_needprivs() unless user_is_allowed_to('view_all_payments');

	my $thisyear = strftime("%Y", localtime(offsettime()));
	my $thismonth = strftime("%m", localtime(offsettime()));
	my $startyear = enc_sql_select("SELECT MIN(date8) FROM $PREF{payments_table}") || $thisyear;
	$startyear =~ s/(\d{4})\d{4}/$1/;

	my (%yearly,%monthly) = ();

	my $year = $startyear;
	while($year <= $thisyear)
	{
		my $days_this_year = 365;
		$days_this_year = strftime("%j", localtime(offsettime())) if $year == $thisyear;

		$yearly{$year}{sales}		= enc_sql_select("SELECT COUNT(*) FROM $PREF{payments_table} WHERE date8 LIKE '$year%'") || 0;
		$yearly{$year}{sales_per_day}	= sprintf("%.1f", $yearly{$year}{sales} / $days_this_year);
		$yearly{$year}{item_cost_sum}	= enc_sql_select("SELECT SUM(item_cost) FROM $PREF{payments_table} WHERE date8 LIKE '$year%'") || '0.00';
		$yearly{$year}{txn_cost_sum}	= enc_sql_select("SELECT SUM(transaction_cost) FROM $PREF{payments_table} WHERE date8 LIKE '$year%'") || '0.00';

		for(1..12)
		{
			my $i = $_ < 10 ? "0$_" : $_;
			my $month = $year . $i;
			my $days_this_month = $i =~ /^(04|06|09|11)$/ ? 30 : $i eq '02' ? 28 : 31;
			$days_this_month = strftime("%d", localtime(offsettime())) if $year == $thisyear && $i == $thismonth;

			$monthly{$month}{sales}		= enc_sql_select("SELECT COUNT(*) FROM $PREF{payments_table} WHERE date8 LIKE '$month%'") || 0;
			$monthly{$month}{sales_per_day}	= sprintf("%.1f", $monthly{$month}{sales} / $days_this_month);
			$monthly{$month}{item_cost_sum}	= enc_sql_select("SELECT SUM(item_cost) FROM $PREF{payments_table} WHERE date8 LIKE '$month%'") || '0.00';
			$monthly{$month}{txn_cost_sum}	= enc_sql_select("SELECT SUM(transaction_cost) FROM $PREF{payments_table} WHERE date8 LIKE '$month%'") || '0.00';
		}

		$year++;
	}

	my $output = '';
	foreach my $year (sort { $b <=> $a } keys %yearly)
	{
		$output .= qq`<div class="paysum ` . oddeven($year,'dont_inc') . qq`">
				<h1 class="year-title">${year} Payments:</h1>
				<table class="yearly">
				<tr><td class="label">$year Sales Count:</td><td>$yearly{$year}{sales}</td></tr>
				<tr><td class="label">$year Sales/Day:</td><td>$yearly{$year}{sales_per_day}</td></tr>
				<tr><td class="label">$year Item Total:</td><td>$PREF{paid_group_currency_symbol}$yearly{$year}{item_cost_sum}</td></tr>
				<tr><td class="label">$year Transaction Total:</td><td>$PREF{paid_group_currency_symbol}$yearly{$year}{txn_cost_sum}</td></tr>
				</table>

				<table class="monthly">
				<tr><th>Month</th><th>Sales</th><th>Sales/Day</th><th>Item Total</th><th>Transaction Total</th></tr>
		`;

		for(1..12)
		{
			my $i = $_ < 10 ? "0$_" : $_;
			my $month = $year . $i;
			my $month_nice = $year . '-' . $i;
			$output .= qq`<tr class="` . oddeven($month,'dont_inc') . qq`">
					<td>$month_nice</td>
					<td>$monthly{$month}{sales}</td>
					<td>$monthly{$month}{sales_per_day}</td>
					<td>$PREF{paid_group_currency_symbol}$monthly{$month}{item_cost_sum}</td>
					<td>$PREF{paid_group_currency_symbol}$monthly{$month}{txn_cost_sum}</td></tr>
			`;
		}

		$output .= qq`</table>\n</div>\n`;
	}

	start_html_output($TEXT{payment_summary_title});
	print $output;
	finish_html_output();
}


sub view_payments
{
	my $tableprefname	= 'payments_table';
	my $viewerprefname	= 'payments';
	my $allowed_to_view	= user_is_allowed_to('view_own_payments') || user_is_allowed_to('view_all_payments');
	my $allowed_to_create	= user_is_allowed_to('create_payments');
	my $allowed_to_edit	= user_is_allowed_to('edit_payments');
	my $allowed_to_delete	= user_is_allowed_to('delete_payments');


	if(user_is_allowed_to('view_all_payments'))
	{
		$PREF{"${viewerprefname}_viewer_title"}				= $PREF{all_payments_page_title};

		$PREF{"${viewerprefname}_viewer_hidden_columns"}		= 'id, txn_id, date, paypal_date, paypal_date8, quantity, userid, group_name, group_id, buyer_firstname, buyer_lastname, buyer_email, item_number, promo_code';
		$PREF{"${viewerprefname}_viewer_disabled_columns"}		= '';
	}
	else
	{
		exit_with_needprivs() unless $PREF{member_is_logged_in};
		$PREF{"${viewerprefname}_viewer_selection_restrictions"}	= "WHERE `userid` = $PREF{logged_in_userid}";

		$PREF{"${viewerprefname}_viewer_title"}				= $PREF{my_payments_page_title};

		$PREF{"${viewerprefname}_viewer_hidden_columns"}		= 'quantity, buyer_firstname, buyer_lastname, userid, username, group_name, buyer_email, item_number, promo_code';
		$PREF{"${viewerprefname}_viewer_disabled_columns"}		= 'id, txn_id, date, paypal_date, paypal_date8, group_id';
	}

	$PREF{"${viewerprefname}_viewer_item_name"}				= "payment";
	$PREF{"${viewerprefname}_viewer_item_name_plural"}			= "payments";
	$PREF{"${viewerprefname}_viewer_default_sort_is_reversed"}		= 1;

	$PREF{"${viewerprefname}_viewer_title_transforms"}{date}		= 'Timestamp';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{date8}		= 'Date';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{transaction_cost}	= 'Txn Cost';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{userid}		= 'Buyer UserId';

	$PREF{"${viewerprefname}_viewer_extra_columns"}{username}		= { position => 15, value => '' };
	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}		= qq`%%variable%% = get_user_name(%%userid%%) || '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_title_transforms"}{username}		= 'Buyer Username';

	$PREF{"${viewerprefname}_viewer_extra_columns"}{period_purchased}	= { position => 16, value => '' };
	$PREF{"${viewerprefname}_viewer_title_transforms"}{period_purchased}	= 'Period Purchased';
	$PREF{"${viewerprefname}_viewer_value_transforms"}{period_purchased}	= qq`
		my \$grouptype = enc_sql_select("SELECT type FROM $PREF{group_table} WHERE id = %%group_id%%");
		my \$hours_purchased = '%%hours_purchased%%' || ('%%days_purchased%%' ? '%%days_purchased%%' * 24 : 0);
		%%variable%% = get_paid_group_period_label(\$grouptype, \$hours_purchased);
	`;

	$PREF{"${viewerprefname}_viewer_value_transforms"}{days_purchased}	= qq`%%variable%% = 'N/A' if '%%transaction_type%%' =~ /subscr/ && '%%transaction_type%%' !~ /payment/;`;   # leaving here to support old installation that still have a days_purchased field.
	$PREF{"${viewerprefname}_viewer_value_transforms"}{hours_purchased}	= qq`%%variable%% = 'N/A' if '%%transaction_type%%' =~ /subscr/ && '%%transaction_type%%' !~ /payment/;`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{quantity}		= qq`%%variable%% = 'N/A' if '%%transaction_type%%' =~ /subscr/;`;

	$PREF{"${viewerprefname}_viewer_value_transforms"}{item_cost}		= qq`%%variable%% = '%%transaction_type%%' =~ /subscr/ && '%%transaction_type%%' !~ /payment/ && (!"%%variable%%" || "%%variable%%" eq '0.00') ? 'N/A' : '$PREF{paid_group_currency_symbol}' . %%variable%%;`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{transaction_cost}	= qq`%%variable%% = '%%transaction_type%%' =~ /subscr/ && '%%transaction_type%%' !~ /payment/ && (!"%%variable%%" || "%%variable%%" eq '0.00') ? 'N/A' : '$PREF{paid_group_currency_symbol}' . %%variable%%;`;

	$PREF{"${viewerprefname}_viewer_summable_columns"}{item_cost}{enabled}	= 1;
	$PREF{"${viewerprefname}_viewer_summable_columns"}{transaction_cost}{enabled}	= 1;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub check_for_expired_group_memberships
{
	encdebuglog qq`starting...`;
	my $tempgroups = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}` WHERE `type` = 'temporary' OR `type` = 'subscription'");	
	my $current_timestamp = offsettime();
	my $temp_membership_count = 0;
	my $expired_count = 0;
	foreach my $j (sort keys %$tempgroups)
	{
		foreach my $uid (split(/,/, $$tempgroups{$j}{members}))
		{
			$temp_membership_count++;

			# Old day-based approach:
			#my $date8_group_membership_started = enc_sql_select("SELECT `date8` FROM `$PREF{group_log_table}` WHERE `group_id` = $$tempgroups{$j}{id} AND `userid` = $uid AND `event` = 1 ORDER BY `date8` DESC LIMIT 1");
			## If there is no record in the group log, use their signup date instead:
			#my $account_creation_timestamp = enc_sql_select("SELECT `cdate` FROM `$PREF{user_table}` WHERE `id` = $uid");
			#$date8_group_membership_started ||= strftime("%Y%m%d",localtime($account_creation_timestamp));
			#my $group_membership_expired = increment_datestring_8($date8_group_membership_started, $$tempgroups{$j}{length_in_days}) < $PREF{date8};

			# New hour-based approach:
			my $timestamp_group_membership_started = enc_sql_select("SELECT `timestamp` FROM `$PREF{group_log_table}` WHERE `group_id` = $$tempgroups{$j}{id} AND `userid` = $uid AND `event` = 1 ORDER BY `timestamp` DESC LIMIT 1");
			# If there is no record in the group log, use their signup date instead:
			my $account_creation_timestamp = enc_sql_select("SELECT `cdate` FROM `$PREF{user_table}` WHERE `id` = $uid");
			$timestamp_group_membership_started ||= $account_creation_timestamp;
			my $membership_length_in_seconds = $$tempgroups{$j}{length_in_hours} ? $$tempgroups{$j}{length_in_hours} * 60*60 : $$tempgroups{$j}{length_in_days} ? $$tempgroups{$j}{length_in_days} * 60*60*24 : 0;
			my $group_membership_expired = ($timestamp_group_membership_started + $membership_length_in_seconds) < $current_timestamp;

			if(!$timestamp_group_membership_started || !$membership_length_in_seconds || !$current_timestamp)
			{
				encdebuglog qq`Error: something went wrong -- not expiring this membership. [\$uid='$uid', \$current_timestamp='$current_timestamp', \$membership_length_in_seconds='$membership_length_in_seconds', \$timestamp_group_membership_started='$timestamp_group_membership_started']`;
			}
			elsif($group_membership_expired)
			{
				$expired_count++;
				encdebuglog "Expired membership: (\$timestamp_group_membership_started + \$membership_length_in_seconds) is less than \$current_timestamp.  [That is: ($timestamp_group_membership_started + $membership_length_in_seconds) is less than $current_timestamp.]";
				remove_user_from_group($uid, $$tempgroups{$j}{group}, 'membership expired');
				add_user_to_group(get_user_name($uid),$PREF{expired_group_name}, 'membership expired');
				send_group_membership_expiration_emailalert($uid, $$tempgroups{$j}{group});
			}
		}
	}
	encdebuglog qq`done: expired $expired_count out of $temp_membership_count temporary memberships.`;
}


sub send_group_membership_expiration_emailalert
{
	my ($uid, $group) = @_;
	return unless $PREF{send_group_membership_expiration_emailalerts} =~ /yes/i;

	my $recipient = get_email_address($uid);

	my $subject = $PREF{group_membership_expiration_emailalert_subject};
	my $message = $PREF{group_membership_expiration_emailalert_template};

	for($subject, $message)
	{
		s/%%group%%/$group/g;
		s/%%join_paid_group_link%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url_qsready}action=joinpaidgroup/g;
	}

	send_email(	$recipient,
			$PREF{group_membership_expiration_emailalert_sender},
			$subject,
			$message,
			($PREF{group_membership_expiration_emailalert_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub show_ipn_data
{
	exit_with_needprivs() unless $PREF{admin_is_logged_in};

	my $tableprefname	= 'paypal_ipn_table';
	my $viewerprefname	= 'paypal_ipn';
	my $allowed_to_view	= $PREF{admin_is_logged_in};
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= $PREF{admin_is_logged_in};
	my $allowed_to_delete	= $PREF{admin_is_logged_in};

	$PREF{"${viewerprefname}_viewer_max_display_length"}		= 2000;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{allvars}	= qq`%%variable%% =~ s!\n_SPTR_\n!, !g;`;
	$PREF{"${viewerprefname}_viewer_extra_columns"}{reprocess}	= { position => 5, value => '' };
	$PREF{"${viewerprefname}_viewer_value_transforms"}{reprocess}	= qq`%%variable%% = '<a href="$PREF{login_url}?action=reprocessipn&amp;id=%%id%%">Reprocess</a>';`;

	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


# A "free paid group" is a paid group with a promo code that brings its price to zero.
sub ajax_join_free_paid_group
{
	$MISC{ajax_mode} = 1;

	my $item_number = get_qs_var({ var=>'itemnum', notnull=>1, maxlength=>150, allowedchars=>'\w-' });
	my $userid = get_qs_var({ var=>'uid', notnull=>1, maxlength=>10, allowedchars=>'\d' });
	my $username = get_user_name($userid);

	exit_with_error qq`Access denied for userid.` unless (
		   $PREF{admin_is_logged_in}
		|| ($userid eq $PREF{logged_in_userid})
		|| ($userid && !$PREF{member_is_logged_in})
		|| (logged_in_user_is_subgroup_manager() && logged_in_subgroup_manager_owns_this_user($userid))
	);

	my ($group_type, $paid_account_cost, $paid_account_groupname, $paid_account_groupid, $hours_purchased) = enc_sql_select("SELECT `type`,`price`,`group`,`id`,`length_in_hours` FROM `$PREF{group_table}` WHERE `code` = '$item_number'");
	output_and_exit({ error=>1, item_number=>$item_number, msg=>"Error: invalid item number." }) unless $paid_account_cost && $paid_account_groupname && $paid_account_groupid;
	my $period = $hours_purchased;
	$hours_purchased = 'lifetime' if $group_type eq 'permanent';

	my $this_users_promo_code = get_promo_code_for_user($userid) or output_and_exit({ error=>1, item_number=>$item_number, msg=>"Error: missing promo code." });
	my $promo_price = get_promo_price($this_users_promo_code, $paid_account_cost, $paid_account_groupid);
	output_and_exit({ error=>1, item_number=>$item_number, msg=>"Error: price is not zero; it's '$promo_price'." }) unless $promo_price =~ /^0(\.0+)?$/;


	activate_and_deactivate_promo_codes();

	my $date = offsettime();
	my $date8 = strftime("%Y%m%d",localtime($date));
	my $date17 = strftime("%Y%m%d-%H:%M:%S",localtime($date));
	my $txn_type_nice = 'free with promo code';
	my $transaction_cost = 0;

	my $buyer_email = get_email_address($userid);						sql_untaint($buyer_email);	log_order_processing_error_and_die("not_sqlsafe(): \$buyer_email value '$buyer_email'.") if not_sqlsafe($buyer_email);
	my $buyer_firstname = get_real_name($userid); $buyer_firstname =~ s!^(\S+).+!$1!;	sql_untaint($buyer_firstname);	log_order_processing_error_and_die("not_sqlsafe(): \$buyer_firstname value '$buyer_firstname'.") if not_sqlsafe($buyer_firstname);
	my $buyer_lastname = get_real_name($userid); $buyer_lastname =~ s!^.+?(\S+)$!$1!;	sql_untaint($buyer_lastname);	log_order_processing_error_and_die("not_sqlsafe(): \$buyer_lastname value '$buyer_lastname'.") if not_sqlsafe($buyer_lastname);


	my $item_cost	= $paid_account_cost;
	my $item_name	= $PREF{join_paid_group_name_template};
	$item_name =~ s!%%group%%!$paid_account_groupname!g;
	#$item_name =~ s#%%period%%#!$period ? "lifetime access" : is_numeric($period) ? "$period hours" : "1 $period"#eg;
	$item_name =~ s#%%period%%#!$period ? "lifetime access" : get_paid_group_period_label($group_type, $period)#eg;


	sql_untaint($item_number);   # verified numeric above.
	sql_untaint($item_name);
	log_order_processing_error_and_die("not_sqlsafe(): \$item_name value '$item_name'.") if not_sqlsafe($item_name);



	# Log the sale in the payments table:
	#
	my $statement =   "INSERT INTO `$PREF{payments_table}` "
			. 		"(`date`, `date8`, `item_number`, `item_name`, `quantity`, `item_cost`, `transaction_cost`, `promo_code`, `transaction_type`, `userid`, `buyer_email`, `buyer_firstname`, `buyer_lastname`, `hours_purchased`, `group_name`, `group_id`) "
			. "VALUES('$date', '$date8', '$item_number', '$item_name', '1', '$item_cost', '$transaction_cost', '$this_users_promo_code', '$txn_type_nice', '$userid', '$buyer_email', '$buyer_firstname', '$buyer_lastname', '$hours_purchased', '$paid_account_groupname', $paid_account_groupid)";

	enc_sql_insert($statement);


	enc_sql_update("UPDATE `$PREF{promo_table}` set `redemption_count` = `redemption_count` + 1 WHERE `promo_code` = '$this_users_promo_code';");
	activate_and_deactivate_promo_codes();


	if($PREF{send_payment_notification_emails} =~ /yes/i)
	{
		my ($email_subject, $email_message, $recipients, $format, $action, $action_full) = ();
		$email_subject	= $PREF{payment_notification_email_subject};
		$email_message	= $PREF{payment_notification_email_template};
		$recipients	= $PREF{payment_notification_email_recipients};
		$format		= $PREF{payment_notification_email_format};

		for($email_subject, $email_message)
		{
			s!%%action%%!$action!g;
			s!%%action_full%%!$action_full!g;
			s!%%date%%!$date!g;
			s!%%date8%%!$date8!g;
			s!%%date17%%!$date17!g;
			s!%%paypal_date\d*%%!!g;
			s!%%item_number%%!$item_number!g;
			s!%%item_name%%!$item_name!g;
			s!%%quantity%%!1!g;
			s!%%item_cost%%!$item_cost!g;
			s!%%transaction_cost%%!$transaction_cost!g;
			s!%%promo_code%%!$this_users_promo_code!g;
			s!%%txn_type_nice%%!$txn_type_nice!g;
			s!%%txn_id%%!!g;
			s!%%paypal_email%%!$buyer_email!g;
			s!%%buyer_firstname%%!$buyer_firstname!g;
			s!%%buyer_lastname%%!$buyer_lastname!g;

			s!%%userid%%!$userid ? $userid : 'unknown'!eg;
			s!%%username%%!$userid ? get_user_name($userid) : 'unknown'!eg;
			s!%%email%%!$userid ? get_email_address($userid) : 'unknown'!eg;
			s!%%view_account_link%%!$userid ? "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=edituser&id=$userid" : '(user ID unknown)'!eg;
			s!%%view_payments_link%%!$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url_qsready}action=viewpayments!g;
		}
		foreach my $email_recipient (split(/\s*,\s*/, $recipients))
		{
			send_email($email_recipient, $PREF{app_email_address}, $email_subject, $email_message, $format, '');
		}
	}


	# Mark the account as paid by adding it to the appropriate group:
	#
	encdebuglog("About to add_user_to_group(): username=$username, userid=$userid, paid_account_groupname=$paid_account_groupname\n");
	add_user_to_group($username, $paid_account_groupname, 'paid account sign-up, free with promo');

	# Disable the pending_payment flag for the account:
	#
	if(account_is_pending_payment($userid))
	{
		enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $userid") == 1 or log_order_processing_error_and_die("SQL returned something other than 1 while trying to set pending_payment to 0.");
	}

	output_and_exit({ success=>1, item_number=>$item_number, msg=>"User '$username' added to group '$paid_account_groupname' successfully." });
}


sub log_order_processing_debug_message
{
	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: process ID=$$ \n$caller(): $msg`;

	my $subject = "Store order processing debug message (PID=$$)";

	foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients}))
	{
		send_email($to, $PREF{app_email_address}, $subject, $msg, 'text/plain', '');
	}
}


sub log_order_processing_error
{
	my $msg = shift;
	my $payer_email = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;

	my $subject = "Error during store order processing ($payer_email)";

	foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients}))
	{
		send_email($to, $PREF{app_email_address}, $subject, $msg, 'text/plain', '');
	}
}


sub log_order_processing_error_and_die
{
	my $msg = shift;
	my $payer_email = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;

	add_text_to_file("In log_order_processing_error_and_die(); about to die because of error: $msg\n", $PREF{ipn_debugfile}, 'end') if $PREF{ipn_debugfile};

	my $subject = "Error during store order processing ($payer_email)";

	foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients}))
	{
		send_email($to, $PREF{app_email_address}, $subject, $msg, 'text/plain', '');
	}

	enc_warn "$subject - $msg";

	$msg =~ s!<!&lt;!g;
	$msg =~ s!>!&gt;!g;
	$msg =~ s!\n!<br />\n!g;
	exit_with_error "$subject - $msg";
}


# WARNING: This should not be used in 99% of UserBase installations.  This is
# NOT a secure login/protection method; to truly protect a site's content, you
# must install UserBase on the same site with the protected content.  See the
# ubviid.js file for how to implement this.
#
sub make_token_for_remote_login
{
	my $token = md5_hex($ENV{REMOTE_ADDR} . $$ . $ENV{HTTP_USER_AGENT} . gettimeofday() . $ENV{REMOTE_PORT} . time() . rand());
	my $day = strftime("%d", gmtime);
	$day =~ s!^0!!;
	$token .= "ea${day}bf31";
	my $ua = $ENV{HTTP_USER_AGENT};
	if($ua =~ /Windows NT [\d\.]+/   &&   $ua =~ /Trident\/[\d\.]+/   &&   $ua =~ /rv:[\d\.]+/)
	{
		# IE, being a giant pile of crap, sends a different UA to the server than the one it
		# reports to the browser via navigator.userAgent.  So we can't just hash the whole
		# thing; instead we must pick out the "standard" parts (in the same way on both client
		# and server) and hash them.
		$ua  = ($ENV{HTTP_USER_AGENT} =~ /(Windows NT [\d\.]+)/)[0] . ' ';
		$ua .= ($ENV{HTTP_USER_AGENT} =~ /(Trident\/[\d\.]+)/)[0] . ' ';
		$ua .= ($ENV{HTTP_USER_AGENT} =~ /(rv:[\d\.]+)/)[0];
	}
	$token .= sha1_hex($ua);
	encdebuglog "ua=$ua; token=$token";
	return $token;
}


sub interpolate_userbase_variables
{
	my $string = shift; # required.
	my $userid = shift; # optional; if present, return info for this user, rather than the logged-in user.
	printd "interpolate_userbase_variables('$string')";

	if($PREF{member_is_logged_in})
	{
		$string =~ s!%%uidtoken%%!make_token_for_remote_login()!eg;
	}

	if($userid && check_id_for_sql_safeness($userid))
	{
		$string =~ s/(%%(\w+?)%%)/db_column_exists($2,$PREF{user_table}) ? enc_sql_select("SELECT `$2` FROM `$PREF{user_table}` WHERE `id` = $userid") : $1/eg;
	}
	else
	{
		$string =~ s/%%username%%/$PREF{logged_in_username}/g;
		$string =~ s/%%userid%%/$PREF{logged_in_userid}/g;
		$string =~ s/%PREF{(\w+)}/$PREF{$1}/g;
		$string =~ s/%%(\w+?)%%/enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $PREF{logged_in_userid}")/eg;
	}
	return $string;
}


sub create_filechucker_userdir($$$$)
{
	return unless $PREF{create_filechucker_userdir_on_account_creation} =~ /yes/i;
	my ($uid,$username,$realname,$email) = @_;
	
	my $userdir		= $PREF{filechucker_userdir_template};
	my $using_username	= $userdir =~ /%%username%%/	&& $username;
	my $using_uid		= $userdir =~ /%%userid%%/	&& $uid;
	my $using_email		= $userdir =~ /%%email%%/	&& $email;
	exit_with_error qq`Your setting for \$PREF{filechucker_userdir_template} must contain at least one of: %%username%%, %%userid%%, or %%email%% (and the corresponding field must be a required field [i.e., never null]) in order to ensure that each userdir is unique.` if !$using_username && !$using_uid && !$using_email;

	$realname =~ s!\W!_!g; # mainly for spaces, but also for dashes, parens, etc, that might appear in the realname field values.
	$userdir =~ s/%%username%%/$username/g;
	$userdir =~ s/%%userid%%/$uid/g;
	$userdir =~ s/%%email%%/$email/g;
	$userdir =~ s/%%realname%%/$realname/g;

	my $dir = $PREF{filechucker_userdir_folder};
	my $slash =   $PREF{DOCROOT} !~ m![/\\]$! && $dir !~ m!^[/\\]!   ? '/' : '';
	$dir = $PREF{DOCROOT} . $slash . $dir if $PREF{filechucker_userdir_folder_is_in_docroot};

	$slash =   $dir !~ m![/\\]$! && $userdir !~ m!^[/\\]!   ? '/' : '';
	$dir = $dir . $slash . $userdir;

	create_dir_if_DNE($dir,$PREF{writable_dir_perms},'make_parents');
}


# BasicLock is not recommended.
# DirLock (or FileChucker) should be used instead.
#
# Note: this function's error messages should be written so that they
# don't display the name of the protected pages directory unless the
# visitor is an administrator.
#
# This was formerly called "display_protected_page".
#
sub display_basiclock_protected_page($)
{
	my $page_to_display = shift;
	enc_urldecode($page_to_display);
	$page_to_display = enc_untaint($page_to_display,'keep_path');
	my ($page_to_display_base, $page_to_display_ext) = ($page_to_display =~ /(.+)\.(.+)/);
	my $page_full = $PREF{protected_pages_directory} . '/' . $page_to_display;

	# Allow pages to be found regardless of file extension or case.
	#
	opendir(my $dirh, $PREF{protected_pages_directory}) or $PREF{admin_is_logged_in}
		? die_nice(qq`error: could not open directory \$PREF{protected_pages_directory} ("$PREF{protected_pages_directory}"): $!`)
		: die_nice(qq`error: could not open directory \$PREF{protected_pages_directory}: $!`);
	my @protectedpages = grep { -f "$PREF{protected_pages_directory}/$_" && !/^\./ } readdir $dirh;
	closedir $dirh or die_nice(qq`error: could not close directory \$PREF{protected_pages_directory}: $!`);
	foreach my $protectedpage (@protectedpages)
	{
		my ($protectedpage_base,$protectedpage_ext) = ($protectedpage =~ /(.+)\.(.+)/);
		if($protectedpage_base   &&   $page_to_display_base   &&   lc($protectedpage_base) eq lc($page_to_display_base))
		{
			$page_full = $PREF{protected_pages_directory} . '/' . $protectedpage_base . '.' . $protectedpage_ext;
			last;
		}
	}

	if(! -e $page_full)
	{
		if($PREF{admin_is_logged_in})	{ die_nice(qq`error: file does not exist: "$page_full"`);	}
		else				{ die_nice(qq`error: file does not exist: "$page_to_display"`);	}
	}

	my $allowed = 0;
	my $page_content = '';

	open(my $infh, $page_full) or die_nice(qq`error: could not open file "$page_to_display" for reading: $!`);
	flock $infh, 1;
	seek $infh, 0, 0;
	while(<$infh>)
	{
		if(/<!-- allowed_usernames=(.*?) -->/)
		{
			my $allowed_users = $1;
			$allowed_users =~ s!\s*,\s*!,!g; # in case they put any spaces around their commas.
			my %allowed_users = map { $_ => 1 } split(/,/, $allowed_users);
			$allowed = 1 if $allowed_users{$PREF{logged_in_username}};
		}
		elsif(/<!-- allowed_groups=(.*?) -->/)
		{
			my $allowed_groups = $1;
			$allowed_groups =~ s!\s*,\s*!,!g; # in case they put any spaces around their commas.
			foreach my $allowed_group (split(/,/, $allowed_groups))
			{
				$allowed = 1 if user_is_member_of_group($PREF{logged_in_userid},$allowed_group);
			}
		}
		else
		{
			$page_content .= $_;
		}
	}
	close($infh) or die_nice(qq`error: could not close file "$page_to_display" after reading: $!`);

	if($allowed)
	{
		print_http_headers();
		print $page_content;
	}
	else
	{
		if($PREF{member_is_logged_in})	{ exit_with_needprivs(); }
		else				{ enc_redirect("$PREF{login_url_qsready}phasemsg=elfirst&whence=" . $ENV{REQUEST_URI});	}
	}
}


# Note: this function's error messages should be written so that they
# don't display the name of the protected pages directory unless the
# visitor is an administrator.
#
# This was formerly called "display_protected_page_simple".
#
sub display_dirlock_protected_page($$)
{
	my $pdir_num = shift;
	my $page_to_display = shift || $PREF{"protected_directory_${pdir_num}_index_filename"} || $PREF{protected_directory_default_index_filename} || 'index.html';
	enc_urldecode($page_to_display);
	$page_to_display = enc_untaint($page_to_display,'keep_path');
	my ($page_to_display_base, $page_to_display_ext) = ($page_to_display =~ /(.+)\.(.+)/);
	my $pdir = $PREF{"protected_directory_${pdir_num}"};
	my $page_full = $pdir . '/' . $page_to_display;
	
	die_nice qq`error: the setting \$PREF{"protected_directory_${pdir_num}"} does not exist.` unless $PREF{"protected_directory_${pdir_num}"};

	unless(
		user_is_allowed_to("access_protected_directory_${pdir_num}")
		||
		($PREF{member_is_logged_in}   &&   $PREF{"users_allowed_to_access_protected_directory_${pdir_num}"} =~ /(^|,)\s*$PREF{logged_in_username}\s*(,|$)/)
	)
	{
		if($PREF{member_is_logged_in})	{ exit_with_needprivs(); }
		else				{ enc_redirect("$PREF{login_url_qsready}phasemsg=elfirst&whence=" . $ENV{REQUEST_URI});	}
	}

	if($PREF{"protected_directory_${pdir_num}_ignore_file_extensions"} =~ /yes/i)
	{
		# Allow pages to be found regardless of file extension or case.  But first, check if a page
		# matching the requested extension does exist -- if so, then just use that one, and skip
		# the unnecessary directory scan.
		#
		$page_full = $pdir . '/' . $page_to_display;
		if(! -e $page_full)
		{
			opendir(my $dirh, $pdir) or $PREF{admin_is_logged_in} ? die_nice(qq`error: could not open directory \$pdir ("$pdir"): $!`) : die_nice(qq`error: could not open directory \$PREF{protected_directory_${pdir_num}}: $!`);
			my @protectedpages = grep { -f "$pdir/$_" && !/^\./ } readdir $dirh;
			closedir $dirh or die_nice(qq`error: could not close directory \$PREF{protected_directory_${pdir_num}}: $!`);
			foreach my $protectedpage (@protectedpages)
			{
				my ($protectedpage_base,$protectedpage_ext) = ($protectedpage =~ /(.+)\.(.+)/);
				if($protectedpage_base   &&   $page_to_display_base   &&   lc($protectedpage_base) eq lc($page_to_display_base))
				{
					$page_full = $pdir . '/' . $protectedpage_base . '.' . $protectedpage_ext;
					last;
				}
			}
		}
	}
	else
	{
		$page_full = $pdir . '/' . $page_to_display;
	}

	if(! -e $page_full)
	{
		if($PREF{admin_is_logged_in})	{ die_nice(qq`error: file does not exist: "$page_full"`);	}
		else				{ die_nice(qq`error: file does not exist: "$page_to_display"`);	}
	}

	# If we've made it this far, then access is granted, and the requested page exists.

	print_and_exit("ub_dirlock_access_granted=yes") if $QS{dirlockphp} eq 'yes';

	select STDOUT;
	$| = 1;
	my ($read,$buf) = ();
	my $ext = lc(($page_full =~ /\.([^\.]+)$/)[0]);
	my $content_type = get_content_type_from_ext($ext);

	my $disposition = $PREF{"protected_directory_${pdir_num}_disposition_for_${ext}"} || $PREF{"disposition_for_${ext}"} || ($content_type ne 'application/octet-stream' ? 'inline' : 'attachment');
	my (undef,$page_base) = split_path_and_filename($page_full);

	print	  qq`Content-Type: $content_type\n`
		. qq`Content-Disposition: $disposition; filename="$page_base"\n`;

	if($PREF{"protected_directory_${pdir_num}_filetypes_to_parse"} =~ /(^|,)\s*$ext\s*(,|$)/i)
	{
		my $content = cat($page_full);
		$content = interpolate_userbase_variables($content);
		do_standard_template_vars_processing('include_undefined', $content);

		print "Content-Length: " . length($content) . "\n\n";
		print $content;
	}
	else
	{
		print "Content-Length: " . (stat $page_full)[7] . "\n\n";

		open(DOWNLOADFILEFH, $page_full) or die "$0: couldn't open file '$page_full' for reading: $!\n";
		my $infh = \*DOWNLOADFILEFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		binmode $infh;
		my $blocksize = (stat $infh)[11] ? (stat $infh)[11] : 16384;
		while($read = sysread($infh, $buf, $blocksize))
		{
			unless(defined($read))
			{
				next if $! =~ /^Interrupted/;
				die_nice "read error: $!\n";
			}

			my ($written,$offset) = (0,0);
			while($read)
			{
				$written = syswrite(STDOUT, $buf, $read, $offset);
				unless(defined($written))
				{
					die_nice "write error: $!\n";
				}

				$read -= $written;
				$offset += $written;
			}
		}
		close $infh or die "$0: couldn't close file '$page_full' after reading: $!\n";
	}
}


sub get_lockgroups_field()
{
	my @allgroups = ();
	my $allgroups = get_groups_hash();
	foreach my $group (sort keys %$allgroups)
	{
		next if $group =~ /^$PREF{public_group_name}$/i;
		push(@allgroups, $group);
	}
	return qq`<input type="hidden" name="lockgroups" id="lockgroups" value="` . join(',', sort { lc($a) cmp lc($b) } @allgroups) . qq`" />\n`;
}


sub manage_pagelock_pages
{
	exit_with_needprivs() unless user_is_allowed_to('manage_pagelock_pages');

	my @files = find_files({ dir=>$PREF{DOCROOT}, hide_base_dir=>1, regex1=>'\.php$', neg_regex1=>'(\w\wtestexec|\w\wtestvirtual|call_\w\w(_embed)?|ubinfo|ublock|ubtest|ubvars)\.php$' });
	start_html_output($TEXT{pagelock_page_title});

	print qq`<div class="intro-left">PageLock lets you lock your pages, so that only members can access them.&nbsp; 
		Simply click on the "lock" links in the table below.&nbsp; Don't see those links?&nbsp; 
		Only writable .php pages can be locked.&nbsp; If you have .html pages, or if your pages are not writable,
		then first you'll need to log into your server via FTP/SSH, and then rename them to a .php extension,
		and/or chmod them (change their permissions) to make them writable.&nbsp; That usually means world-writable,
		which is "0666", or -rw-rw-rw.&nbsp; From then on, you can use this page to lock/unlock them.</div>\n`;
	print get_lockgroups_field();
	print qq`<div class="enc_tbl" id="managepagelock"><table id="managepagelock_tbl" class="enc_sortable"><tr class="headers">\n<th class="page">Page</th><th>Writable/Lockable?</th><th>Status</th><th>Actions</th></tr>\n`;
	foreach my $file (@files)
	{
		next if $file =~ m!login/index\.php!;

		my $file_full = $PREF{DOCROOT}.$file;
		my $writable = -w $file_full;

		my $locked = 0;
		my ($groups_allowed, $users_allowed) = ();
		my $contents = enc_head($file_full);
		if($contents =~ m!(<\?(?:PHP|php)\s+
				(\$groups_allowed\s*=\s*"([\w,]*)";)?\s*
				(\$users_allowed\s*=\s*"([\w,]*)";)?\s*
				require\(\$_SERVER\['DOCUMENT_ROOT'\]\s*\.\s*"(/(?:[\w\./-]+)ublock\.php)"\);\s*
				\?>)
				!xs)
		{
			my ($wholething, $groups_rule, $users_rule, $ublock_path) = ();
			($wholething, $groups_rule, $groups_allowed, $users_rule, $users_allowed, $ublock_path) = ($1, $2, $3, $4, $5, $6);
			$locked = 1;
		}
		$groups_allowed ||= 'none';
		$users_allowed ||= 'none';

		my @actions = ();
		if($writable)
		{
			push(@actions, qq`<a href="#" onclick="pagelock_popup('$file', '$groups_allowed');return false">lock</a>`);
			if($locked)
			{
				push(@actions, qq`<a href="$ENV{SCRIPT_NAME}?action=unpagelock&amp;file=$file">unlock</a>`);
			}
		}

		print '<tr>';
		print qq`<td class="page"><a href="$file">$file</a></td>`;
		print '<td>' . ($writable ? 'yes' : 'no') . '</td>';
		#print "<td>" . ($locked ? "Locked: groups-allowed=$groups_allowed; users-allowed=$users_allowed" : 'Unlocked') . "</td>";
		print "<td>" . ($locked ? $TEXT{Locked}."Groups allowed: $groups_allowed" : $TEXT{Unlocked}) . "</td>";
		print "<td>" . (join(' &bull; ', @actions)) . "</td>";
		print '</tr>';
	}
	print qq`</table></div>\n`;
	finish_html_output();
}


sub pagelock_page
{
	exit_with_needprivs() unless user_is_allowed_to('manage_pagelock_pages');

	my $file = get_qs_var({ var=>'file', maxlength=>'500', allowedchars=>'/\w\.% -', notnull=>1 });
	my $groups = get_qs_var({ var=>'groupsallowed', maxlength=>'500', allowedchars=>' \w\.,-' });

	my $file_full = $PREF{DOCROOT}.$file;
	output_and_exit({ msg=>qq`Error: the specified file does not exist.` }) unless -f $file_full;
	output_and_exit({ msg=>qq`Error: the specified file is not writable.` }) unless -w $file_full;

	foreach my $group (split(/,/, $groups))
	{
		output_and_exit({ msg=>qq`Error: the specified group does not exist.` }) unless group_exists($group);
	}

	my $contents = cat($file_full);

	# Remove any existing protection:
	$contents =~ s!(<\?(?:PHP|php)\s+
			(\$groups_allowed\s*=\s*"([\w,]*)";)?\s*
			(\$users_allowed\s*=\s*"([\w,]*)";)?\s*
			require\(\$_SERVER\['DOCUMENT_ROOT'\]\s*\.\s*"(/(?:[\w\./-]+)ublock\.php)"\);\s*
			\?>\n?)
			!!gxs;

	$PREF{path_to_ublock} ||= "$PREF{app_base_folder}/ublock.php";
	my $new_protection = qq`<?PHP \$groups_allowed = "$groups"; require(\$_SERVER['DOCUMENT_ROOT'] . "$PREF{path_to_ublock}"); ?>\n`;
	add_text_to_file($new_protection.$contents, $file_full, 'clobber');
	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=managepagelock");
}


sub unpagelock_page
{
	exit_with_needprivs() unless user_is_allowed_to('manage_pagelock_pages');

	my $file = get_qs_var({ var=>'file', maxlength=>'500', allowedchars=>'/\w\.% -', notnull=>1 });
	my $file_full = $PREF{DOCROOT}.$file;
	output_and_exit({ msg=>qq`Error: the specified file does not exist.` }) unless -f $file_full;
	output_and_exit({ msg=>qq`Error: the specified file is not writable.` }) unless -w $file_full;

	my $contents = cat($file_full);
	$contents =~ s!(<\?(?:PHP|php)\s+
			(\$groups_allowed\s*=\s*"([\w,]*)";)?\s*
			(\$users_allowed\s*=\s*"([\w,]*)";)?\s*
			require\(\$_SERVER\['DOCUMENT_ROOT'\]\s*\.\s*"(/(?:[\w\./-]+)ublock\.php)"\);\s*
			\?>\n?)
			!!gxs;

	add_text_to_file($contents, $file_full, 'clobber');
	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=managepagelock");
}


sub manage_dirlock_dirs
{
	exit_with_needprivs() unless user_is_allowed_to('manage_dirlock_dirs');
	exit_with_error(qq`DirLock requires an Apache or LiteSpeed server, but you're running different server software ($ENV{SERVER_SOFTWARE}).&nbsp; Please <a href="http://httpd.apache.org/" target="_blank">install Apache</a> on your server if you'd like to use DirLock.&nbsp; Or you can use <a href="$PREF{here_qsready}action=managepagelock">PageLock</a> instead, if your server supports PHP.`) unless $ENV{SERVER_SOFTWARE} =~ /Apache|LiteSpeed/i;

	my @dirs = get_all_subdirs($PREF{DOCROOT});
	start_html_output($TEXT{dirlock_page_title});
	print qq`<div class="intro-left">DirLock lets you lock your directories (folders), so that only members can access them.&nbsp; 
		Simply click on the "lock" links in the table below.&nbsp; Don't see those links?&nbsp; In order to be locked,
		directories must be writable, or contain an existing .htaccess file that is writable.&nbsp;
		If your dirs are not writable, you'll need to log into your server via FTP or SSH and chmod/change their permissions to make them 
		writable, which usually means world-writable: that's "0777", or -rwxrwxrw.&nbsp; From then on, you can use this page to lock/unlock
		them.&nbsp; Once you've locked one or more dirs, you can <a href="$PREF{here_qsready}action=webconfig&which=wc&filter=protected_directory">manage
		related settings here</a>.
	</div>\n`;
	print get_lockgroups_field();
	print qq`<div class="enc_tbl" id="managedirlock"><table id="managedirlock_tbl" class="enc_sortable"><tr class="headers">\n<th class="dir">Directory</th><th>Writable/Lockable?</th><th>Status</th><th>Actions</th></tr>\n`;
	foreach my $dir (@dirs)
	{
		next if "/$dir" =~ m!^$PREF{app_base_folder}(/|$)!i;
		next if "/$dir" =~ m!^/cgi!i;

		my $dir_full		= $PREF{DOCROOT}.'/'.$dir;
		my $htaccess_full	= $dir_full.'/.htaccess';
		my $htaccess_exists	= -f $htaccess_full;
		my $htaccess_writable	= -w $htaccess_full;
		my $dir_writable	= -w $dir_full;
		my $lockable		= $htaccess_writable || ($dir_writable && !$htaccess_exists);

		my $locked = 0;
		my ($exclusions_disabled, $excluded_extensions, $dir_num) = ();
		if(-f $htaccess_full)
		{
			my $htcontents = cat($htaccess_full);
			if($htcontents =~ m!^RewriteEngine On$!smi)
			{
				($exclusions_disabled, $excluded_extensions, $dir_num) = dirlock_pattern({ action=>'match', input=>$htcontents });
				# If the .htaccess file contains "RewriteEngine On", and it also contains our DirLock lines
				# (which it does if $dir_num came back non-null), then this directory is locked:
				$locked = 1 if $dir_num;
			}
		}

		if(!$locked)
		{
			# If this directory isn't currently locked, then use default values in the DirLock popup:
			$dir_num = 50; $dir_num++ while exists $PREF{"protected_directory_$dir_num"};
			$excluded_extensions = 'jpg|jpeg|png|gif|css|js|swf';
		}

		my $groups_allowed = $PREF{"groups_allowed_to_access_protected_directory_$dir_num"} || 'none';
		my @actions = ();
		if($lockable)
		{
			push(@actions, qq`<a href="#" onclick="dirlock_popup('$dir', '$dir_num', '$groups_allowed', '$excluded_extensions');return false">lock</a>`);
			if($locked)
			{
				push(@actions, qq`<a href="$ENV{SCRIPT_NAME}?action=dirlock_unlock&amp;dir=$dir&amp;dir_num=$dir_num">unlock</a>`);
			}
		}

		print '<tr>';
		print qq`<td class="dir"><a href="/$dir/" target="_blank">/$dir/</a></td>`;
		print '<td>' . ($lockable ? 'yes' : 'no') . '</td>';
		#print "<td>" . ($locked ? "Locked: groups-allowed=$groups_allowed; users-allowed=$users_allowed" : 'Unlocked') . "</td>";
		print "<td>" . ($locked ? $TEXT{Locked}."Groups allowed: $groups_allowed" : $TEXT{Unlocked}) . "</td>";
		print "<td>" . (join(' &bull; ', @actions)) . "</td>";
		print '</tr>';
	}
	print qq`</table></div>\n`;
	finish_html_output();
}


sub dirlock_page
{
	exit_with_needprivs() unless user_is_allowed_to('manage_dirlock_dirs');

	my $dir = get_qs_var({ var=>'dir', maxlength=>'500', allowedchars=>'/\w\.% -', notnull=>1 });
	my $dir_num = get_qs_var({ var=>'dir_num', maxlength=>'10', allowedchars=>'\d', notnull=>1 });
	my $groups = get_qs_var({ var=>'groupsallowed', maxlength=>'500', allowedchars=>' @\w\.,-' });
	my $excl_exts = get_qs_var({ var=>'excl_exts', maxlength=>'200', allowedchars=>'\w\.\|-' }) || 'all_file_types_protected';

	die_nice qq`Illegal chars in dir` if $dir =~ /\.\./;

	my $htaccess_file = $PREF{DOCROOT} . '/' . $dir . '/.htaccess';
	create_file_if_DNE($htaccess_file, $PREF{writable_file_perms});
	my $contents = cat($htaccess_file);

	# Remove any existing DirLock:
	$contents = dirlock_pattern({ action=>'remove', input=>$contents });

	unless($contents =~ m!^RewriteEngine On!sm) { $contents = "RewriteEngine On\n\n" . $contents; }

	# Add DirLock:
	my $spacer = $contents =~ /\n\n$/s ? '' : $contents =~ /\n$/s ? "\n" : "\n\n";
	$contents .= qq`${spacer}# The next 2 lines enable UserBase DirLock protection. Do not edit these lines; use the DirLock Manager within UserBase instead.\n`
		   . qq`RewriteCond %{REQUEST_URI} !\\.($excl_exts)\$ [NC]\n`
		   . qq`RewriteRule (.*) $ENV{SCRIPT_NAME}?pdir=$dir_num&ppge=\$1 [L]\n`;
	add_text_to_file($contents, $htaccess_file, 'clobber');

	# Set DirLock prefs for this dir in WebConfig:
	my $pref = 'protected_directory_' . $dir_num;
	save_webconfig_pref($pref, '%PREF{DOCROOT}/' . $dir);
	save_webconfig_pref($pref . '_ignore_file_extensions', 'yes');
	save_webconfig_pref($pref . '_filetypes_to_parse', 'htm,html');
	save_webconfig_pref($pref . '_index_filename', 'index.html');
	save_webconfig_pref('groups_allowed_to_access_' . $pref, $groups);

	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=dirlock");
}


sub undirlock_page
{
	exit_with_needprivs() unless user_is_allowed_to('manage_dirlock_dirs');

	my $dir = get_qs_var({ var=>'dir', maxlength=>'500', allowedchars=>'/\w\.% -', notnull=>1 });
	my $dir_num = get_qs_var({ var=>'dir_num', maxlength=>'10', allowedchars=>'\d', notnull=>1 });

	die_nice qq`Illegal chars in dir` if $dir =~ /\.\./;

	my $htaccess_file = $PREF{DOCROOT} . '/' . $dir . '/.htaccess';
	my $contents = cat($htaccess_file);

	# Remove any existing DirLock:
	$contents = dirlock_pattern({ action=>'remove', input=>$contents });
	add_text_to_file($contents, $htaccess_file, 'clobber');

	# Remove DirLock prefs for this dir from WebConfig:
	my $pref = 'protected_directory_' . $dir_num;
	delete_webconfig_pref($pref, 0);
	delete_webconfig_pref($pref . '_ignore_file_extensions', 0);
	delete_webconfig_pref($pref . '_filetypes_to_parse', 0);
	delete_webconfig_pref($pref . '_index_filename', 0);
	delete_webconfig_pref('groups_allowed_to_access_' . $pref, 0);

	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=dirlock");
}


sub dirlock_pattern($)
{
	# This sub is a single location to put all instances of this long regex, so we can keep them all in sync if/when any changes are made to them.
	my $optsref = shift; my %opts = %$optsref;
	if($opts{action} eq 'remove') {
		$opts{input} =~ s!^(# The next 2 lines enable UserBase DirLock protection. Do not edit these lines; use the DirLock Manager within UserBase instead.\n)?^(#)?RewriteCond %\{REQUEST_URI\} \!\\\.\(([\w\|]+)\)\$ \[NC\]\n*^RewriteRule \(\.\*\) $ENV{SCRIPT_NAME}\?pdir=(\d+)&ppge=\$1 \[L\]\n?$!!gsm;
		return $opts{input};
	}
	elsif($opts{action} eq 'match') {
		$opts{input} =~ m!^(# The next 2 lines enable UserBase DirLock protection. Do not edit these lines; use the DirLock Manager within UserBase instead.\n)?^(#)?RewriteCond %\{REQUEST_URI\} \!\\\.\(([\w\|]+)\)\$ \[NC\]\n*^RewriteRule \(\.\*\) $ENV{SCRIPT_NAME}\?pdir=(\d+)&ppge=\$1 \[L\]\n?$!sm;
		my ($comment, $exclusions_disabled, $excluded_extensions, $dir_num) = ($1, $2, $3, $4);
		return ($exclusions_disabled, $excluded_extensions, $dir_num);
	}
}


sub check_login()
{
	sleep $PREF{num_seconds_to_sleep_on_failed_login} unless $PREF{member_is_logged_in};
	my $group_memberships = '';
	my (@custom_fields, @custom_field_values) = ();

	if($PREF{member_is_logged_in})
	{
		my $groups = get_groups_hash($PREF{logged_in_userid});
		foreach my $group (sort keys %$groups)
		{
			$group_memberships .= $group . ',' if $$groups{$group}{is_member};
		}
		$group_memberships =~ s/,+$//;

		@custom_fields = get_custom_userbase_field_names($PREF{user_table});
		foreach my $customfield (@custom_fields)
		{
			my $value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}'");
			push @custom_field_values, $value;
		}
	}

	my $output = "admin=$PREF{admin_is_logged_in}:::::member=$PREF{member_is_logged_in}:::::username=$PREF{logged_in_username}:::::userid=$PREF{logged_in_userid}:::::group_memberships=${group_memberships}:::::realname=$PREF{logged_in_realname}:::::email=$PREF{logged_in_email}:::::";

	if($PREF{include_subadmin_details_in_chklogin_output} =~ /yes/i)
	{
		if(logged_in_user_is_part_of_a_subgroup())
		{
			$output .= "subadmin_id=$PREF{subgroup_manager_userid}:::::subadmin_username=$PREF{subgroup_manager_username}:::::subadmin_email=$PREF{subgroup_manager_email}:::::";
		}
		if(logged_in_user_is_subgroup_manager())
		{
			my $i = 1;
			my $subusers = get_users_belonging_to_group({ groups=>"$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}" });
			foreach my $uid (sort { $$subusers{$a}{username} cmp $$subusers{$b}{username} } keys %$subusers)
			{
				$output .= qq`subuser${i}_info=username: $$subusers{$uid}{username}///uid: ${uid}`;
				for(@custom_fields) { $output .= qq`///$_: $$subusers{$uid}{$_}`; }
				$output .= ':::::';
				$i++;
			}
		}
	}

	my $i = 0;
	foreach my $field (@custom_fields)
	{
		$output .= "${field}=$custom_field_values[$i]:::::";
		$i++;
	}

	$output .= "\n";

	if($qs =~ /print=false/)
	{
		return $output;
	}
	else
	{
		print_http_headers();
		print $output;
	}
}


sub show_logins
{
	my $tableprefname	= 'logins_table';
	my $viewerprefname	= 'logins';
	my $allowed_to_view	= user_is_allowed_to('view_logins_log');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('edit_logins_log');
	my $allowed_to_delete	= user_is_allowed_to('delete_logins_log_records');


	$PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 2, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 4, value => '' };

	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}	= qq`%%variable%% = get_user_name(%%user_id%%) || '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_failed_logins
{
	my $tableprefname	= 'failed_logins_table';
	my $viewerprefname	= 'failed_logins';
	my $allowed_to_view	= user_is_allowed_to('view_failed_logins_log');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('edit_failed_logins_log');
	my $allowed_to_delete	= user_is_allowed_to('delete_failed_logins_log_records');


	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 4, value => '' };

	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_group_log
{
	my $tableprefname	= 'group_log_table';
	my $viewerprefname	= 'group_log';
	my $allowed_to_view	= user_is_allowed_to('manage_group_log');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('manage_group_log');
	my $allowed_to_delete	= user_is_allowed_to('manage_group_log');


	$PREF{"${viewerprefname}_viewer_title"}				= 'Group Log';
	$PREF{"${viewerprefname}_viewer_header_note"}			= qq`<p>
		This log shows every time a user is added to a group or removed from a group,
		along with the username of the person who made the change.&nbsp; In some cases,
		for example when a user joins a paid group, the changer username will be blank,
		because it was actually UserBase/PayPal who made the change, not for example an
		administrator.
	</p>`;

	$PREF{"${viewerprefname}_viewer_hidden_columns"}		||= 'id, changer_userid, userid, group_id, timestamp, date8, ip_address';

	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 3, value => '' };

	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{event}	= qq`%%variable%% = %%variable%% ? 'added' : 'removed';`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_password_activity
{
	my $tableprefname	= 'password_activity_table';
	my $viewerprefname	= 'password_activity';
	my $allowed_to_view	= user_is_allowed_to('view_password_activity_log');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('edit_password_activity_log');
	my $allowed_to_delete	= user_is_allowed_to('delete_password_activity_log_records');


	$PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 3, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{updater}	= { position => 8, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 6, value => '' };

	$PREF{"${viewerprefname}_viewer_title_transforms"}{updater}	= 'Updated by';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{ip_address}	= "Updater's IP";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{hostname}	= "Updater's hostname";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{browser}	= "Updater's browser";

	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}	= qq`%%variable%% = get_user_name(%%user_id%%) || '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{updater}	= qq`%%variable%% = %%user_who_did_update%% ? get_user_name(%%user_who_did_update%%) : "$TEXT{password_updater_special_cases}";`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{salt}	= qq`%%variable%% =~ s/</&lt;/g; %%variable%% =~ s/>/&gt;/g;`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_userinfo_updates
{
	my $tableprefname	= 'userinfo_updates_table';
	my $viewerprefname	= 'userinfo_updates';
	my $allowed_to_view	= user_is_allowed_to('view_userinfo_updates');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('edit_userinfo_updates');
	my $allowed_to_delete	= user_is_allowed_to('delete_userinfo_updates_records');


	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}			= { position => 3, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{account_changed}	= { position => 4, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{changed_by}		= { position => 5, value => '' };

	$PREF{"${viewerprefname}_viewer_title_transforms"}{updater}		= 'Updated by';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{ip_address}		= "Changer's IP";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{hostname}		= "Changer's hostname";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{browser}		= "Changer's browser";

	$PREF{"${viewerprefname}_viewer_value_transforms"}{account_changed}	= qq`%%variable%% = get_user_name(%%changee_id%%) ? '<a href="$PREF{login_url}?action=edituser&amp;id=%%changee_id%%">' . get_user_name(%%changee_id%%) . '</a>' : '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{changed_by}		= qq`%%variable%% = %%changer_id%% ? '<a href="$PREF{login_url}?action=edituser&amp;id=%%changer_id%%">' . get_user_name(%%changer_id%%) . '</a>' : "$TEXT{userinfo_updates_special_cases}";`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}		= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_event_calendar
{
	my $tableprefname	= 'event_calendar_table';
	my $viewerprefname	= 'event_calendar';
	my $allowed_to_view	= user_is_allowed_to('view_event_calendar');
	my $allowed_to_create	= user_is_allowed_to('edit_event_calendar');
	my $allowed_to_edit	= user_is_allowed_to('edit_event_calendar');
	my $allowed_to_delete	= user_is_allowed_to('edit_event_calendar');


	$PREF{"${viewerprefname}_viewer_item_name"}				= 'event';
	$PREF{"${viewerprefname}_viewer_default_sort_field"}			||= 'date';

	if(user_is_allowed_to('view_all_user_event_calendars') && $qs !~ /calview=justme/)
	{
		$PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 2, value => '' };
		$PREF{"${viewerprefname}_viewer_hidden_columns"}		||= 'id,userid';
		$PREF{"${viewerprefname}_viewer_footer_note"}			= qq`\n<p><em>Administrators, you can also <a href="$PREF{login_url}?action=calendar&amp;calview=justme">view just your own events</a>.</em></p>\n`;
	}
	else
	{
		$PREF{"${viewerprefname}_viewer_disabled_columns"}		||= 'id,userid';
		$PREF{"${viewerprefname}_viewer_selection_restrictions"}	= "WHERE `userid` = $PREF{logged_in_userid}";
	}

	$PREF{"${viewerprefname}_viewer_disabled_columns"}			= $PREF{"${viewerprefname}_viewer_disabled_columns"} ? $PREF{"${viewerprefname}_viewer_disabled_columns"} . ',time' : 'time';


	$PREF{"${viewerprefname}_viewer_title_transforms"}{reminder1}		||= 'Reminder';
	$PREF{"${viewerprefname}_creation_title_transforms"}{date}		||= 'Date (YYYY-MM-DD)';
	$PREF{"${viewerprefname}_editmode_title_transforms"}{date}		||= 'Date (YYYY-MM-DD)';

	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}		= qq`%%variable%% = get_user_name(%%userid%%) ? '<a href="$PREF{login_url}?action=edituser&amp;id=%%userid%%">' . get_user_name(%%userid%%) . '</a>' : '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}		= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)/$1-$2-$3/;';
	$PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{date}	= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)/$1-$2-$3/;';

	$PREF{"${viewerprefname}_viewer_force_textarea"}{description}		= 1;

	$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{reminder1}	= 30*1440 . "///30 days prior|||"
										. 10*1440 . "///10 days prior|||"
										. "0///On date of event";

	$PREF{"${viewerprefname}_creation_autoset_columns"}{userid}		= qq`%%variable%% = $PREF{logged_in_userid};`;
	$PREF{"${viewerprefname}_POST_value_transforms"}{date}			= qq`%%variable%% =~ s/\\D//g;`;



	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_event_calendar_reminderlog
{
	my $tableprefname	= 'event_calendar_reminderlog_table';
	my $viewerprefname	= 'event_calendar_reminderlog';
	my $allowed_to_view	= user_is_allowed_to('view_all_user_event_calendars');
	my $allowed_to_create	= '';
	my $allowed_to_edit	= '';
	my $allowed_to_delete	= user_is_allowed_to('view_all_user_event_calendars');


	$PREF{"${viewerprefname}_viewer_item_name"}				= 'event reminder';
	$PREF{"${viewerprefname}_viewer_default_sort_field"}			||= 'date12';

	#$PREF{"${viewerprefname}_viewer_extra_columns"}{username}		= { position => 4, value => '' };
	#$PREF{"${viewerprefname}_viewer_extra_columns"}{event}			= { position => 5, value => '' };
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id,userid,eventid';


	$PREF{"${viewerprefname}_viewer_title_transforms"}{recipient}		||= 'Reminder Recipient';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{eventname}		||= 'Event Name';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{date12}		||= 'Reminder Date';
	#$PREF{"${viewerprefname}_editmode_title_transforms"}{date12}		||= 'Datestamp (YYYY-MM-DD)';

	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}		= qq`%%variable%% = get_user_id('%%username%%') ? '<a href="$PREF{login_url}?action=edituser&amp;id=' . get_user_id('%%username%%') . '">%%username%%</a>' : '(deleted)';`;
	#$PREF{"${viewerprefname}_viewer_value_transforms"}{event}		= qq`%%variable%% = enc_sql_select("SELECT name FROM $PREF{event_calendar_table} WHERE id = %%eventid%%");`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date12}		= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/$1-$2-$3 $4:$5/;';

	#$PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{date12}	= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/$1-$2-$3 $4:$5/;';

	#$PREF{"${viewerprefname}_POST_value_transforms"}{date12}		= qq`%%variable%% =~ s/\\D//g;`;



	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub send_event_calendar_reminders
{
	return unless $PREF{enable_event_calendar} =~ /yes/i;

	my $today = strftime("%Y%m%d",localtime(time + $PREF{time_offset}));
	my $events = enc_sql_select_multi("SELECT * FROM `$PREF{event_calendar_table}`");
	foreach my $k (keys %$events)
	{
		my $eventid = $$events{$k}{id};
		my $userid = $$events{$k}{userid};

		my $eventdate = $$events{$k}{date};
		my $reminder_time_in_mins = $$events{$k}{reminder1}; # number of minutes before the event date.
		my $reminder_time_in_days = $reminder_time_in_mins / 1440;
		my $reminder_date = decrement_datestring_8($eventdate, $reminder_time_in_days);

		if($today >= $reminder_date)
		{
			# we're not currently using the time field for our events, but we are using
			# a date12 in the reminderlog table for the reminder timestamp, so for now
			# just set all times to 0000.
			#
			my $reminder_date12 = $reminder_date . '0000';

			my $recipient_username = get_user_name($userid);
			my $recipient_email = get_email_address($userid);

			my $already_sent_reminder = enc_sql_select("SELECT COUNT(*) FROM `$PREF{event_calendar_reminderlog_table}` WHERE `date12` = $reminder_date12 AND `recipient` = '$recipient_email' AND `eventname` = '$$events{$k}{name}'");
			if(!$already_sent_reminder)
			{
				my $subject = $PREF{event_calendar_reminder_email_subject};
				my $message = $PREF{event_calendar_reminder_email_template};
				#encdebug qq`sending event reminder to $recipient_email for event $$events{$k}{name} dated $$events{$k}{date}`;
				for($subject,$message)
				{
					s!%%eventname%%!$$events{$k}{name}!g;
					s!%%eventdate%%!$$events{$k}{date}!g;
					s!%%eventdescription%%!$$events{$k}{description}!g;
					s!%%eventid%%!$eventid!g;
					s!%%userid%%!$userid!g;
					interpolate_userbase_variables($_, $userid);
				}
				send_email($recipient_email, $PREF{event_calendar_reminder_email_sender}, $subject, $message, $PREF{event_calendar_reminder_email_format}, 'die_on_email_error');

				enc_sql_insert("INSERT INTO `$PREF{event_calendar_reminderlog_table}` (`username`, `recipient`, `eventname`, `date12`) VALUES('$recipient_username', '$recipient_email', '$$events{$k}{name}', '$reminder_date12')");
			}
			else
			{
				#encdebug qq`NOT sending event reminder (already sent it) to $recipient_email for event $$events{$k}{name} dated $$events{$k}{date}`;
			}
		}
	}
}


sub delete_old_files
{
	return unless
	(
		($PREF{max_age_for_humantest_images} =~ /^\d+(\.\d+)?$/ && $PREF{max_age_for_humantest_images} > 0)
	);

	my $current_hour = strftime("%H",localtime(offsettime()));
	my $current_minute = strftime("%M",localtime(offsettime()));
	for($current_hour, $current_minute)
	{
		s/^0// unless /^0$/; # because sftftime outputs leading zeros, but the user probably won't enter them that way.
	}

	my %hours_at_which_to_check = map { $_ => 1 } split(/[,\s]+/, $PREF{hours_at_which_to_check_for_old_files});
	my %minutes_at_which_to_check = map { $_ => 1 } split(/[,\s]+/, $PREF{minutes_at_which_to_check_for_old_files});

	if(($PREF{check_daily_for_old_files} =~ /yes/i && $hours_at_which_to_check{$current_hour})   ||   ($PREF{check_hourly_for_old_files} =~ /yes/i && $minutes_at_which_to_check{$current_minute}))
	{
		if($PREF{automatically_delete_old_humantest_images} =~ /yes/i)
		{
			delete_files_and_folders_older_than($PREF{max_age_for_humantest_images}, "$PREF{human_test_image_directory___real}");
		}
	}
}


sub setup_profile_image_thumbnail_prefs
{
	my $j = 0;
	$PREF{smallest_thumbnail_size_for_profile_images} = '';
	$PREF{create_resized_copies_of_uploaded_images} = 'yes';
	foreach my $size (split(/\s*,\s*/, $PREF{profile_image_sizes_to_create}))
	{
		next unless $size =~ /^\d+$/;
		$j++;
		$PREF{smallest_thumbnail_size_for_profile_images} = $size if ($size < $PREF{smallest_thumbnail_size_for_profile_images}) || $PREF{smallest_thumbnail_size_for_profile_images} eq '';
		$PREF{"create_resized_copies_0${j}__imagemagick_size"}		= $size . 'x' . $size;
		$PREF{"create_resized_copies_0${j}__gd_size"}			= $size;
		$PREF{"create_resized_copies_0${j}__location_type"}		= 'relative';
		$PREF{"create_resized_copies_0${j}__folder_name"}		= $size . 'px';
		$PREF{"create_resized_copies_0${j}__new_filename"}		= '%%orig%%.%%ext%%';
		$PREF{"create_resized_copies_0${j}__skip_if_bigger_than"}	= 1024*1024*20; # in bytes, so "1024*1024*5" is 5 MB, etc.
		$PREF{"create_resized_copies_0${j}__serialize_or_overwrite"}	= 'overwrite';
	}
}


sub change_profile_image()
{
	exit_with_needprivs() unless user_is_allowed_to('change_profile_image');
	$PREF{on_page} = 'profileimage';

	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		my $upload_field_name = "image_filenames";
		my $query = new CGI;
		my $num_files_uploaded = 0;
		my %uploadedfiles = ();
		foreach my $tmpfile ($query->upload($upload_field_name)) # what upload() returns is apparently both a handle and a filename?
		{
			$num_files_uploaded++;
			$uploadedfiles{$num_files_uploaded}{param}	= enc_param($upload_field_name, $query);
			$uploadedfiles{$num_files_uploaded}{handle}	= $tmpfile;
			$uploadedfiles{$num_files_uploaded}{filename}	= $tmpfile;
		}

		foreach my $i (sort keys %uploadedfiles)
		{
			my $filename = $uploadedfiles{$i}{filename};
			$filename = lc($filename) unless $PREF{dont_convert_upload_filenames_to_lowercase} =~ /yes/i;
			$filename =~ s!.*?([^/\\]+)$!$1!;	# remove any path.
			$filename =~ s!\.{2,}!.!g;		# condense any multi-dots.
			$filename =~ s![^\w\.-]!_!g;		# remove any unusual stuff including spaces.

			my ($file_base,$file_ext) = ($filename =~ /(.+)\.(.+)/);
			die_nice qq`File base name must not be null.` unless $file_base;
			die_nice qq`File extension must be one of ($PREF{profile_image_supported_extensions}) but it's "$file_ext".` unless is_image($filename);

			my $path = $PREF{profile_images_folder_real}; $path .= '/' unless $path =~ m!/$!;
			my $output_file_full = $path . get_profile_image_basename() . '.' . lc($file_ext);
			#$output_file_full = serialize_filename_if_file_exists($output_file_full);
			$uploadedfiles{$i}{output_file_full} = $output_file_full;

			my $upload_filehandle = $uploadedfiles{$i}{handle};
			open(UPLOADFILE,">$output_file_full") or die_nice "couldn't create file '$output_file_full': $!\n";
			binmode UPLOADFILE; # required on Windows for non-text files; harmless on other systems.
			while(<$upload_filehandle>)
			{
				print UPLOADFILE;
			}
			close UPLOADFILE or die_nice "couldn't close file '$output_file_full': $!\n";
			chmod $PREF{writable_file_perms}, $output_file_full;
		}

		# Do the thumbnail-creation in a separate loop, so any errors here don't
		# prevent the upload itself from succeeding.  And note that the reason we're
		# creating thumbnails here in the first place is in case the user doesn't
		# visit the Manage Item Images page after the upload (it does auto-redirect
		# there after the upload, but due to pagination, the newly-uploaded image
		# might not be on the page the user ends up at).
		#
		foreach my $i (sort keys %uploadedfiles)
		{
			my ($path,$file) = split_path_and_filename($uploadedfiles{$i}{output_file_full});

			my $resize_details = join "\n<br />", do_automatic_resizing( {
				01 => { name => $file, realpath => $PREF{profile_images_folder_real}, force_overwrite => 1 }
			} );
		}

		enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=changeimage");
	}
	elsif(get_qs_var('subact') eq 'delete_image')
	{
		my $file = enc_untaint(get_qs_var('file'));
		foreach my $size (split(/\s*,\s*/, $PREF{profile_image_sizes_to_create}))
		{
			next unless $size =~ /^\d+$/;
			my $thumbnail_realpath = $PREF{profile_images_folder_real} . '/' . $size . 'px/' . $file;
			if(-e $thumbnail_realpath)
			{
				unlink($thumbnail_realpath) or die_nice qq`Couldn't delete profile image resized copy '$thumbnail_realpath': $!\n`;
			}
		}
		my $image_realpath = $PREF{profile_images_folder_real} . '/' . $file;
		if(-e $image_realpath)
		{
			unlink($image_realpath) or die_nice qq`Couldn't delete profile image '$image_realpath': $!\n`;
		}
		enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=changeimage");
	}
	else
	{
		start_html_output("Profile Image Manager");

		print qq`
		<form accept-charset="UTF-8" name="upload_profile_image_form" id="upload_profile_image_form" method="post" enctype="multipart/form-data"
		 action="$ENV{SCRIPT_NAME}?action=changeimage" onsubmit="var btn = gebi('upload_profile_image_submit'); btn.value='Uploading; please wait...'; btn.disabled='disabled'">
		<div id="form_controls">
		<input type="file" name="image_filenames" id="image_filenames" /><br /><br />
		<input type="submit" name="upload_profile_image_submit" id="upload_profile_image_submit" value="Upload Image" />
		</div>
		<div id="form_intro">Upload new profile image here.</div>
		</form>
		`;

		print qq`<table class="profile_image">\n`;
		if(my $file = get_current_profile_image_filename())
		{
			my $thumbnail_url = $PREF{profile_images_folder_url} . '/' . $PREF{smallest_thumbnail_size_for_profile_images} . 'px/' . $file;
			my $fullsize_url = $PREF{profile_images_folder_url} . '/' . $file;

			my $resize_details = join "\n<br />", do_automatic_resizing( {
				01 => { name => $file, realpath => $PREF{profile_images_folder_real} }
			} );

			print qq`
				<tr>
					<td class="thumbnail"><a href="$fullsize_url"><img src="$thumbnail_url" alt="[thumbnail for $file]" /></a></td>
					<td class="filename">$file</td>
					<td class="resizedetails">$resize_details</td>
					<td class="deletelink"><a href="$PREF{here_qsready}action=changeimage&amp;subact=delete_image&amp;file=$file">Delete image</a></td>
				</tr>
			`;
		}
		else
		{
			print qq`<tr>\n<td class="noimage">$TEXT{no_profile_image_msg}</td>\n</tr>\n`;
		}
		print qq`</table>\n`;

		finish_html_output();
	}
}


sub is_image
{
	return $_[0] =~ /\.($PREF{profile_image_supported_extensions})$/i;
}


sub get_profile_image_basename
{
	my $userid = shift || $PREF{logged_in_userid}; die_unless_numeric($userid,'userid');
	return get_user_name($userid);
}


sub get_current_profile_image_filename
{
	my $userid = shift || $PREF{logged_in_userid}; die_unless_numeric($userid,'userid');
	my $basename = get_profile_image_basename($userid);
	foreach my $ext (split(/\s*\|\s*/, $PREF{profile_image_supported_extensions}))
	{
		my $filename = $basename . '.' . lc($ext);
		return $filename if -e $PREF{profile_images_folder_real} . "/" . $filename;
	}
	if(-e $PREF{default_profile_image})
	{
		my $ext = ($PREF{default_profile_image} =~ /.+\.(.+)/)[0];
		my $filename = $basename . '.' . lc($ext);
		my $filename_real = $PREF{profile_images_folder_real} . "/" . $filename;
		copy($PREF{default_profile_image}, $filename_real) or die_nice qq`Couldn't copy default profile image file: $!`;
		chmod($PREF{writable_file_perms}, $filename_real) or die_nice qq`Couldn't chmod default profile image file with mode '$PREF{writable_file_perms}': $!`;
		return $filename if -e $filename_real;
	}
}


sub get_profile_image
{
	return undef unless $PREF{enable_profile_images} =~ /yes/i;

	my $optsref = shift; my %opts = %$optsref if $optsref;
	my $userid = $opts{userid} || $PREF{logged_in_userid}; die_unless_numeric($userid,'userid');
	my $size = $opts{size} || $PREF{smallest_thumbnail_size_for_profile_images};

	my %profile_image = ();
	if(my $file = get_current_profile_image_filename($userid))
	{
		my $thumbnail_url = $PREF{profile_images_folder_url} . '/' . $size . 'px/' . $file;
		my $fullsize_url = $PREF{profile_images_folder_url} . '/' . $file;

		my $imagehash = {   01 => { name => $file, realpath => $PREF{profile_images_folder_real} }   };
		my $resize_details = join "\n<br />", do_automatic_resizing($imagehash);

		$profile_image{filename} = $file;
		$profile_image{thumbnail_url} = $thumbnail_url;
		$profile_image{fullsize_url} = $fullsize_url;
		$profile_image{thumbnail_html} = qq`<a href="$fullsize_url" class="thumb_link_to_full"><img src="$thumbnail_url" alt="[thumbnail for $file]" /></a>`;
		return \%profile_image;
	}
	else
	{
		return '';
	}
}


sub show_user_profile
{
	$PREF{on_page} = 'profile';
	my $uid = get_qs_var('uid') || $PREF{logged_in_userid};
	exit_with_error("Missing or invalid user ID ('$uid').") unless $uid =~ /^\d+$/;
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'view_profile_pages', get_user_name($uid));

	for($PREF{user_profile_page_title}, $PREF{user_profile_page_template})
	{
		s!(%%(\w+)%%)!db_column_exists($2,$PREF{user_table}) ? enc_sql_select("SELECT `$2` FROM `$PREF{user_table}` WHERE `id` = $uid") : $1!eg;
	}




	my $default_fields_block = '';
	my $sections = enc_sql_select_multi("SELECT * FROM `$PREF{field_sections_table}` ORDER BY `section_position`");

	# If there are no sections defined, or just one, then we'll display everything in a single section.
	#%$sections = ();
	my $just_one_section = 0;
	#
	#if(!%$sections || !$$sections{1}{id} || (enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`") == 1))
	#
	# 20120412: if the COUNT(*) == 1 then %$sections is already set up properly, isn't it?  There's no way
	# that $$sections{1}{id} could be unset in that case.  And there's no way that $$sections{1}{id} could
	# be unset without %$sections also being undef, so the "|| !$$sections{1}{id}" is redundant.
	# Update: this fixes a bug where, if exactly 1 section was created, then the user profile
	# pages would display the generic "Additional Details" label above any custom fields, instead of the
	# configured label for that particular section.
	#
	if(!%$sections)
	{
		$just_one_section = 1;
		%$sections = ();
		$$sections{1}{id} = enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}`") || 1; # there's only one id (or none) to return.
	}

	foreach my $j (sort { $$sections{$a}{section_position} <=> $$sections{$b}{section_position} } keys %$sections)
	{
		my $section_id = $$sections{$j}{id};

		my $template			= $PREF{user_profile_page_default_fields_block_template};
		#my $section_header_template	= $PREF{user_profile_section_header_template};

		my $allfields = '';
		my ($field_template) = ($template =~ m!%%%template:field%%%(.+?)%%%end-template:field%%%!gs);
		if($PREF{show_builtin_fields_with_custom_fields_in_profile} =~ /yes/i)
		{
			foreach my $builtin_field ('username', 'name', 'email')
			{
				next unless ($section_id eq $PREF{show_builtin_fields_in_this_section_id}) || $just_one_section;
				#next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_view});
				next if $builtin_field eq 'name' && $PREF{use_builtin_realname_field} !~ /yes/i;
				next if $builtin_field eq 'email' && $PREF{use_builtin_email_field} !~ /yes/i;

				my $f_template = $field_template;

				$f_template =~ s!%%fieldname%%!$builtin_field!g;
				$f_template =~ s!%%fieldlabel%%!$PREF{"${builtin_field}_label"}!g;
				$f_template =~ s!%%fieldvalue%%!enc_sql_select("SELECT `$builtin_field` FROM `$PREF{user_table}` WHERE `id` = $uid")!eg;

				$allfields .= $f_template;
			}
		}
		if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
		{
			my $fields = enc_sql_select_multi("SELECT * FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
			foreach my $k (sort { $a <=> $b } keys %$fields)
			{
				next unless ($$fields{$k}{enabled} && db_column_exists($$fields{$k}{fieldname}, $PREF{user_table}));
				next unless ($section_id eq $$fields{$k}{section}) || $just_one_section;
				next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$k}{groups_allowed_to_view});

				my $value = enc_sql_select("SELECT `$$fields{$k}{fieldname}` FROM `$PREF{user_table}` WHERE `id` = $uid");
				sql_un_untaint($value);

				my $f_template = $field_template;

				$f_template =~ s!%%fieldname%%!$$fields{$k}{fieldname}!gs;
				$f_template =~ s!%%fieldlabel%%!$$fields{$k}{fieldlabel}!gs;
				$f_template =~ s!%%fieldvalue%%!$value!gs;

				$allfields .= $f_template;
			}
		}
		$template =~ s!%%%template:field%%%(.+?)%%%end-template:field%%%!$allfields!gs;


		my $show_builtin_fields		= $section_id eq $PREF{show_builtin_fields_in_this_section_id};
		#my $show_customfields		= $customfields && $display_custom_fields;
		next if !$allfields; # no output in this section.

		$template =~ s!%%section_label%%!$$sections{$j}{label} || $PREF{section_label_for_sections_without_labels}!eg;

		$template =~ s!%%section_css_id%%!'section_' . ($$sections{$j}{name} || $j)!eg;

		$template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
		$template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
		#$template =~ s!%%%if-show_grouplist%%%(.*?)%%%end-show_grouplist%%%!$grouplist ? $1 : ''!egs;
		$template =~ s!%%%if-show_builtin_fields%%%(.*?)%%%end-show_builtin_fields%%%!$show_builtin_fields ? $1 : ''!egs;
		#$template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$show_customfields ? $1 : ''!egs;

		#$template =~ s!%%user_profile_section_header%%!$section_header_template!g;

		$template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

		#$template =~ s!%%(\w+)%%!$vars{$1}!g;
		$template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;

		$default_fields_block .= $template;
	}

	$PREF{user_profile_page_template} =~ s!%%default_fields_block%%!$default_fields_block!g;

	my $profile_image_ref = get_profile_image({userid=>$uid}); my %profile_image = %$profile_image_ref if $profile_image_ref;
	$PREF{user_profile_page_template} =~ s!%%smallest_profile_image_html%%!$profile_image{thumbnail_html}!g;





	start_html_output($PREF{user_profile_page_title});
	print $PREF{user_profile_page_template};
	finish_html_output();
}


sub show_member_directory
{
	$PREF{on_page} = 'memberdirectory';
	exit_with_needprivs() unless user_is_allowed_to('view_member_directory');
	
	my $member_directory_list = '';

	my $i = 0;
	my ($range_start,$range_end) = get_pagination_range($PREF{num_members_per_page_on_member_directory});

	my $users = get_users_belonging_to_group({ group=>'member', exclude_pending=>1, exclude_admins=>$PREF{exclude_admins_from_member_directory}=~/yes/i });
	foreach my $uid (sort { $$users{$a}{username} cmp $$users{$b}{username} } keys %$users)
	{
		$i++; next unless $range_start <= $i && $i <= $range_end;

		my $list_template = $PREF{member_directory_list_template};
		$list_template =~ s!(%%(\w+)%%)!db_column_exists($2,$PREF{user_table}) ? enc_sql_select("SELECT `$2` FROM `$PREF{user_table}` WHERE `id` = $uid") : $1!eg;

		my $default_fields_block = '';
		my $sections = enc_sql_select_multi("SELECT * FROM `$PREF{field_sections_table}` ORDER BY `section_position`");

		# If there are no sections defined, or just one, then we'll display everything in a single section.
		#%$sections = ();
		my $just_one_section = 0;
		#
		#if(!%$sections || !$$sections{1}{id} || (enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`") == 1))
		#
		if(!%$sections)
		{
			$just_one_section = 1;
			%$sections = ();
			$$sections{1}{id} = enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}`") || 1; # there's only one id (or none) to return.
		}

		foreach my $j (sort { $$sections{$a}{section_position} <=> $$sections{$b}{section_position} } keys %$sections)
		{
			my $section_id = $$sections{$j}{id};

			my $template			= $PREF{member_directory_page_default_fields_block_template};
			#my $section_header_template	= $PREF{member_directory_section_header_template};

			my $allfields = '';
			my ($field_template) = ($template =~ m!%%%template:field%%%(.+?)%%%end-template:field%%%!gs);
			if($PREF{show_builtin_fields_with_custom_fields_in_directory} =~ /yes/i)
			{
				foreach my $builtin_field ('username', 'name', 'email')
				{
					next unless ($section_id eq $PREF{show_builtin_fields_in_this_section_id}) || $just_one_section;
					#next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_view});
					next if $builtin_field eq 'name' && $PREF{use_builtin_realname_field} !~ /yes/i;
					next if $builtin_field eq 'email' && $PREF{use_builtin_email_field} !~ /yes/i;

					my $f_template = $field_template;

					$f_template =~ s!%%fieldname%%!$builtin_field!g;
					$f_template =~ s!%%fieldlabel%%!$PREF{"${builtin_field}_label"}!g;
					$f_template =~ s!%%fieldvalue%%!enc_sql_select("SELECT `$builtin_field` FROM `$PREF{user_table}` WHERE `id` = $uid")!eg;

					$allfields .= $f_template;
				}
			}
			if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
			{
				my $fields = enc_sql_select_multi("SELECT * FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
				foreach my $k (sort { $a <=> $b } keys %$fields)
				{
					next unless ($$fields{$k}{enabled} && db_column_exists($$fields{$k}{fieldname}, $PREF{user_table}));
					next unless ($section_id eq $$fields{$k}{section}) || $just_one_section;
					next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$k}{groups_allowed_to_view});

					my $value = enc_sql_select("SELECT `$$fields{$k}{fieldname}` FROM `$PREF{user_table}` WHERE `id` = $uid");
					sql_un_untaint($value);   # For changelog: this new line is a bugfix to properly display HTML in custom fields.

					my $f_template = $field_template;

					$f_template =~ s!%%fieldname%%!$$fields{$k}{fieldname}!gs;
					$f_template =~ s!%%fieldlabel%%!$$fields{$k}{fieldlabel}!gs;
					$f_template =~ s!%%fieldvalue%%!$value!gs;

					$allfields .= $f_template;
				}
			}
			$template =~ s!%%%template:field%%%(.+?)%%%end-template:field%%%!$allfields!gs;


			my $show_builtin_fields		= $section_id eq $PREF{show_builtin_fields_in_this_section_id};
			#my $show_customfields		= $customfields && $display_custom_fields;
			#my $no_output_in_this_section	= !($show_builtin_fields || $show_customfields);

			$template =~ s!%%section_label%%!$$sections{$j}{label} || $PREF{section_label_for_sections_without_labels}!eg;

			$template =~ s!%%section_css_id%%!'section_' . ($$sections{$j}{name} || $j)!eg;

			$template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
			$template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
			#$template =~ s!%%%if-show_grouplist%%%(.*?)%%%end-show_grouplist%%%!$grouplist ? $1 : ''!egs;
			$template =~ s!%%%if-show_builtin_fields%%%(.*?)%%%end-show_builtin_fields%%%!$show_builtin_fields ? $1 : ''!egs;
			#$template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$show_customfields ? $1 : ''!egs;

			#$template =~ s!%%member_directory_section_header%%!$section_header_template!g;

			$template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

			#$template =~ s!%%(\w+)%%!$vars{$1}!g;
			$template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;

			$default_fields_block .= $template; # unless $no_output_in_this_section;
		}

		$list_template =~ s!%%default_fields_block%%!$default_fields_block!g;

		my $profile_image_ref = get_profile_image({userid=>$uid}); my %profile_image = %$profile_image_ref if $profile_image_ref;
		$list_template =~ s!%%smallest_profile_image_html%%!$profile_image{thumbnail_html}!g;
		$list_template =~ s!%%profile_link%%!$PREF{here_qsready}action=viewuser&amp;uid=$uid!g;
		$member_directory_list .= $list_template;
	}

	my $pagelinks = get_pagination_links_mark2( {
			range_start => $range_start, range_end => $range_end,
			num_items => $i, items_per_page => $PREF{num_members_per_page_on_member_directory},
			itemname_singular => 'member',
			itemname_plural => 'members',
			#template => $PREF{filelist_pagination_links_template},
			hide_sort_links => 1,
			hide_when_single_page => 1
	} );


	start_html_output($PREF{member_directory_page_title});
	print $member_directory_list;
	print $pagelinks;
	finish_html_output();
}


sub check_for_admin_alerts()
{
	return unless $PREF{admin_is_logged_in};

	my $md5_pws  = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE CHAR_LENGTH(`password`) = 32");
	my $sha1_pws = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE CHAR_LENGTH(`password`) = 40");
	log_admin_alert({ msg => qq`You have %%count%% accounts whose password hashes are stored in the  MD5 format.&nbsp; This older hash function has become less secure over time, so your accounts will automatically be upgraded to newer, stronger hashes on the next login for each account.&nbsp; Or, you can <a href="$PREF{here_qsready}action=bulkuser">reset all passwords in your system</a> to do it now.`, count =>  $md5_pws }) if $md5_pws;
	log_admin_alert({ msg => qq`You have %%count%% accounts whose password hashes are stored in the SHA1 format.&nbsp; This older hash function has become less secure over time, so your accounts will automatically be upgraded to newer, stronger hashes on the next login for each account.&nbsp; Or, you can <a href="$PREF{here_qsready}action=bulkuser">reset all passwords in your system</a> to do it now.`, count => $sha1_pws }) if $sha1_pws;

	log_admin_alert({ msg => qq`Your \$PREF{min_password_length} setting is %%min%%, which is not secure; it should be at least 10.`, min => $PREF{min_password_length} }) if $PREF{min_password_length} < 10;
}


sub create_initial_admin_account()
{
	if($qs =~ /(?:^|&)$PREF{twochar_app_id}smsg=firstadmindone(?:&|$)/)
	{
		# we need to intercept this one particular ?smsg case in early dispatch.
		exit_with_output($TEXT{first_admin_created});
	}

	my $user_accounts_exist = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}`");

	# If they asked for ?makefirstadmin then obviously we want this sub to run; but also if they didn't,
	# yet no user accounts exist, we should still run this sub, to catch anyone who gets stuck in the
	# setup process but somehow loses the ?makefirstadmin link.  (Which may happen anytime someone sets
	# the DB prefs via the main prefs file rather than via WebConfig...?)
	#
	return unless ($QS{action} eq 'makefirstadmin') || !$user_accounts_exist;

	# TODO: maybe we don't want to return just because an account already exists?  Maybe we should
	# let the bootstrap-password system be used to create an admin account even after the initial
	# setup (e.g. if the user forgets his admin user/pass)?  Then again, at that point (once an
	# installation has already been used and populated with potentially-sensitive user data), 
	# maybe the security of the existing installation should trump this convenience, and we should
	# require the use of the $PREF{allow_random_admin_account_creation} feature instead.
	#
	if($user_accounts_exist)
	{
		exit_with_error qq`User accounts already exist on this installation, so the ?makefirstadmin feature has been disabled for security purposes.&nbsp; If you've forgotten your admin password, you can <a href="$PREF{here_qsready}action=pwreset1">reset it</a>, or <a href="https://encodable.com/userbase/faq/#newadmin" target="_blank">create a new admin account</a>.`;
	}

	if(!$PREF{admin_is_logged_in})
	{
		exit_with_error qq`No user accounts exist yet; please <a href="$PREF{here_qsready}action=login&amp;whence=$PREF{REQ_URI_SANS_QS}_THEQS_action=makefirstadmin">login with your bootstrap password</a> to create your initial admin account.`;
	}

	$PREF{csswrapperclass} = 'encnarrow';   # must come after the return.

	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		# Note: we can't exit via anything that uses kmsg here, because this sub gets
		# called from do_app_init before the dispatch chain that would show the kmsg.

		my $user = enc_param('ubuser');
		my $pass = enc_param('ubpw1');
		my $email = enc_param('ubemail');

		my ($crypted_pass, $salt) = create_new_password_hash($pass);

		if(!emailaddr_is_valid($email) && $email)	{ print_and_exit($TEXT{messages}{einvlde});	}
		elsif(!password_is_valid($pass))		{ print_and_exit($TEXT{messages}{einvldp});	}
		elsif(!hashedpw_is_valid($crypted_pass))	{ print_and_exit($TEXT{messages}{einvldh});	}
		elsif(!username_is_valid($user))		{ print_and_exit($TEXT{messages}{ebadname});	}
		elsif($pass ne enc_param('ubpw2'))		{ print_and_exit($TEXT{messages}{epwmismatch});	}

		add_new_user($user, $crypted_pass, $salt, '', $email);
		add_user_to_group($user,$PREF{admin_group_name});

		delete_encauth_login_cookie();
		smsg_redirect('firstadmindone');
	}
	else
	{
		start_html_output('Create Admin Account');
		print qq`<p>Setup Step #3 of 3: Please create your administrator account now.</p>
			<form accept-charset="UTF-8" method="post" action="$ENV{SCRIPT_NAME}?action=makefirstadmin" id="firstadmin">Username:
			<br /><input type="text" name="ubuser" id="ubuser" maxlength="4" class="default text required" />
			<br />Password:
			<br /><input type="password" name="ubpw1" id="ubpw1" maxlength="4" class="default text required" />
			<br />Password Again:
			<br /><input type="password" name="ubpw2" id="ubpw2" maxlength="4" class="default text required" />
			<br />Email Address:
			<br /><input type="text" name="ubemail" id="ubemail" maxlength="200" class="default text required emailformat" />
			<br /><br /><input type="button" value="Create Account" class="default button submit" onclick="if(check_for_required_userbase_fields('firstadmin')   &&   check_passwords('firstadmin'))   { gebi('firstadmin').submit(); }" />
			</form>
		`;
		finish_html_output();
	}

	exit;


}


##############################################################################
### Shared-UB: ###############################################################
##############################################################################


sub load_external_prefs
{
	$PREF{script_basename} = ($ENV{SCRIPT_NAME} =~ m!.*?[/\\]?([^/\\]+)\.[^/\\\.]+!)[0];
	my ($script_dirname) = ($ENV{SCRIPT_NAME} =~ m!^(.+)/.*?$!);
	my $prefs_basename = $_[0] eq 'use_internal_filename' ? $PREF{internal_filename} : $PREF{script_basename};

	my $critical_prefs_loaded = 0;
	foreach my $prefs_file ("${prefs_basename}_prefs", "${prefs_basename}_prefs_extra")
	{
		for($prefs_file,
			"$PREF{DOCROOT}/cgi-bin/$prefs_file",		"$PREF{DOCROOT}/../cgi-bin/$prefs_file",
			"$PREF{DOCROOT}/cgi/$prefs_file",		"$PREF{DOCROOT}/../cgi/$prefs_file",
			"$PREF{DOCROOT}$script_dirname/$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/$prefs_file",

			# Also try the parent dir, mainly because it's a likely place for any shared prefs files:
			"$PREF{DOCROOT}$script_dirname/../$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/../$prefs_file", "../$prefs_file"
		)
		{
			if(my $file = -e "${_}.cgi" ? "${_}.cgi" : -e "${_}.pl" ? "${_}.pl" : '')
			{
				my $prefs_contents = ();
				open(IN,"<$file") or die_nice("couldn't open prefs file '$file': $!");
				flock IN, 1;
				seek IN, 0, 0;
				while(<IN>) { $prefs_contents .= $_; }
				close IN or die_nice("couldn't close prefs file '$file': $!");
				$prefs_contents =~ /(.*)/s;
				$prefs_contents = $1; # cheap untaint since this is our own config file.
				eval $prefs_contents; die_nice("Error processing your prefs file ('$file'): $@") if $@;
				$critical_prefs_loaded = 1 unless $file =~ /(_shared_prefs_|_prefs_extra)/;
				$PREF{loaded_prefs_files} .= "$file, ";
				last;
			}
		}
	}

	$PREF{loaded_prefs_files} =~ s!, $!!;

	if(!$critical_prefs_loaded)
	{
		if($_[0] ne 'use_internal_filename')
		{
			# First pass failed, so try again but use $PREF{internal_filename} as the prefs base.
			load_external_prefs('use_internal_filename');
		}
		else
		{
			# Second pass failed too; nothing else we can do.
			die_nice(
				"Error: couldn't find any prefs file to load.  You must put your $PREF{prefs_basename}_prefs.cgi file on the server with the $PREF{prefs_basename}.cgi file."
				. ($PREF{docroot_autodetection_error} ? qq` <br /><br />\nThis may be caused by or related to the following: $PREF{docroot_autodetection_error}` : '')
			);
		}
	}
}


sub load_userbase_prefs
{
	my $force = shift;
	if(($force   ||   userbase_available())   &&   $PREF{internal_appname} !~ /^userbase$/i)
	{
		# Try to load UserBase prefs from userbase_prefs.cgi to avoid
		# having to specify common prefs twice.

		my %ub_pref_names = (
			database_hostname				=> 1,
			database_name					=> 1,
			database_username				=> 1,
			database_password				=> 1,
			dbi_connection_string				=> 1,

			time_offset					=> 1,
			hide_poweredby					=> 1,

			site_session_cookie				=> 1,
			login_url					=> 1,

			user_table					=> 1,
			group_table					=> 1,
			custom_field_table				=> 1, # for backwards compatibility.
			custom_field_list_table				=> 1,

			max_username_length				=> 1,
			max_groupname_length				=> 1,
			max_hashedpw_length				=> 1,

			allow_spaces_in_usernames			=> 1,
			allow_atsigns_in_usernames			=> 1,
			allow_dots_in_usernames				=> 1,
			allow_dashes_in_usernames			=> 1,

			allow_spaces_in_groupnames			=> 1,
			allow_atsigns_in_groupnames			=> 1,
			allow_dots_in_groupnames			=> 1,
			allow_dashes_in_groupnames			=> 1,

			make_usernames_case_insensitive			=> 1,
			make_passwords_case_insensitive			=> 1,

			idle_timeout					=> 1,
			num_days_rememberme_cookie_lasts		=> 1,
			enable_ip_address_restriction			=> 1,
			force_ip_address_restriction			=> 1,
			disable_ip_restriction_for_AOL_users		=> 1,
			enable_forced_password_change			=> 1,
			admins_can_be_forced_to_change_their_own_pws	=> 1,
			prevent_multiple_simultaneous_logons_per_username => 1,

			subgroup_groupname_suffix			=> 1,
			groups_that_can_manage_subgroup_users		=> 1,
			subgroup_owned_users_get_disabled_when_their_manager_does => 1,

			userbase_table_name_alternative_prefix		=> 1,
		);

		my $prefs_basename = $PREF{userbase_prefs_file_basename};
		my @prefs_files = ("${prefs_basename}_prefs.cgi", "${prefs_basename}_prefs.pl", "${prefs_basename}_prefs_extra.cgi", "${prefs_basename}_prefs_extra.pl");
		push (@prefs_files, $PREF{userbase_prefs_file}) if $PREF{userbase_prefs_file}; # so we can specify it manually, including full path, if necessary.
		push (@prefs_files, $PREF{userbase_prefs_file_extra}) if $PREF{userbase_prefs_file_extra};
		my $prefs_loaded = 0;
		foreach my $prefs_file (@prefs_files)
		{
			for(get_likely_prefs_file_locations($prefs_file))
			{
				if(-e $_)
				{
					my $file = $_;
					open(IN,"<$file") or die_nice("couldn't open prefs file '$file': $!");
					flock IN, 1;
					seek IN, 0, 0;
					while(<IN>)
					{
						if(/^\$PREF{(\w+)}\s*=\s*(.+)/)
						{
							my ($pref,$value) = ($1,$2);
							if($ub_pref_names{$pref})
							{
								# For certain prefs (e.g. database connection details), we'd like to have the option
								# of overriding the UB versions and use the per-app versions instead, only falling
								# back to the UB versions if the per-app ones are null:
								#
								next if ($pref eq 'database_hostname') && $PREF{database_hostname};
								next if ($pref eq 'database_name') && $PREF{database_name};
								next if ($pref eq 'database_username') && $PREF{database_username};
								next if ($pref eq 'database_password') && $PREF{database_password};

								if($value =~ /ENV\{SCRIPT_NAME\}/)
								{
									# In userbase_prefs.cgi, any use of $ENV{SCRIPT_NAME} is intended to mean '/cgi-bin/userbase.cgi'
									# (or whatever the path to userbase.cgi is), so we can't eval that here from FileChucker etc,
									# because then it will end up being '/cgi-bin/filechucker.cgi' instead.  (This is primarily a
									# problem for the $PREF{login_url} setting.)  So we'll try to figure out what the correct path to
									# userbase.cgi is, and if we can't, then we'll just skip this line from the userbase_prefs.cgi file.

									foreach my $likely_prefs_file (get_likely_prefs_file_locations($prefs_file))
									{
										my $script_name_full = $likely_prefs_file;
										$script_name_full =~ s!_prefs(_(new|extra))?!!; # remove the _prefs/_prefs_new/_prefs_extra from the prefs filename to get the script name.

										if(-e $script_name_full)
										{
											if($script_name_full =~ m!^$PREF{DOCROOT}(.+)!) # we only want the ones including the full path (i.e. just plain "userbase_prefs.cgi" doesn't help us here).
											{
												my $script_name = $1;
												$script_name =~ s!\.\./!!g; # in case this is one of the paths containing a "../", which is OK in the filesystem but not in URLs.

												my $updated_line = '';

												if(/^\$PREF{\w+}\s*=\s*\$ENV{SCRIPT_NAME};$/)
												{
													# If it's a simple "$PREF{foo} = $ENV{SCRIPT_NAME};" line, then we know we need to
													# add quotes around the $script_name value that we interpolate back into it:
													#
													$updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!'$script_name'!g;
													eval $updated_line;
												}
												else
												{
													# Otherwise, the original line may or may not have had the ENV{SCRIPT_NAME} variable
													# within a quoted string, so we'll have to try this multiple ways:
													#
													$updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!$script_name!g;
													eval $updated_line;
													if($@)
													{
														$updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!'$script_name'!g;
														eval $updated_line;
														if($@)
														{
															$updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!"$script_name"!g;
															eval $updated_line;
															if($@)
															{
																# We tried.
																die_nice(qq`Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\n(While processing line: "$updated_line") <br /><br />\n\nYou should get UserBase running first, then return here.`);
															}
														}
													}
												}
												last;
											}
										}
									}
								}
								else
								{
									eval $_; die_nice(qq`Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\n(While processing line: "$_") <br /><br />\n\nYou should get UserBase running first, then return here.`) if $@;
								}
							}
						}
						elsif(/^\$TEXT{(\w+)}\s*=\s*/)
						{
							if($ub_pref_names{$1})
							{
								eval $_; die_nice(qq`Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\n(While processing line: "$_") <br /><br />\n\nYou should get UserBase running first, then return here.`) if $@;
							}
						}
					}
					close IN or die_nice("couldn't close prefs file '$file': $!");
					$PREF{loaded_userbase_prefs_files} .= "$file, ";
					$prefs_loaded = 1;
					last;
				}
			}
		}
		die_nice("Error: couldn't find any UserBase prefs file to load.  You must put your UserBase prefs file on the server with this script file.  This script will look in its own folder, in the cgi-bin folder, and in the login folder by default.  You can also add a new line to this script's prefs file setting \$PREF{userbase_prefs_file_extra} to the full filename (including path) of your UserBase prefs file.") unless $prefs_loaded;

		load_userbase_webconfig_prefs(\%ub_pref_names);
	}

	# As of early/mid 2013 UB's table name prefs are now internal to UB, so we can't get them
	# from the prefs file anymore, unless the user has for some reason specified them there
	# manually.  Instead we'll just set the ones we need here, the same way UB does internally.
	# 20150524: And now we need to be able to check for the existence of the UB user_table
	# before we're actually integrated with UB (via WebConfig, to check whether it's possible
	# to enable the integration in the first place), so these must be outside the if(UB) test.
	#
	my $prefix = $PREF{userbase_table_name_alternative_prefix} || 'userbase';
	$PREF{user_table}		||= $prefix . '_users';
	$PREF{group_table}		||= $prefix . '_groups';
	$PREF{custom_field_list_table}	||= $prefix . '_custom_fields';
	
	$PREF{loaded_userbase_prefs_files} =~ s!, $!!;

	$PREF{custom_field_list_table} = $PREF{custom_field_table} if $PREF{custom_field_table} && !$PREF{custom_field_list_table}; # For backwards compatibility;
	$PREF{custom_field_table} = $PREF{custom_field_list_table} if $PREF{custom_field_list_table} && !$PREF{custom_field_table}; # this was just a renamed pref.
}


sub get_likely_prefs_file_locations($)
{
	my $prefs_file = shift;
	my ($script_dirname) = ($ENV{SCRIPT_NAME} =~ m!^(.+)/.*?$!);
	return($prefs_file,
		"$PREF{DOCROOT}/cgi-bin/$prefs_file",		"$PREF{DOCROOT}/../cgi-bin/$prefs_file",
		"$PREF{DOCROOT}/cgi/$prefs_file",		"$PREF{DOCROOT}/../cgi/$prefs_file",
		"$PREF{DOCROOT}/login/$prefs_file",		"$PREF{DOCROOT}/../login/$prefs_file",
		"$PREF{DOCROOT}$script_dirname/$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/$prefs_file"
	);
}


sub load_other_prefs_files
{
	my @other_prefs_files = ();
	foreach my $num (sort keys %{$PREF{other_prefs_files}})
	{
		my $name = $PREF{other_prefs_files}{$num}{shortcut_name};
		if($qs =~ /(?:^|&)prefs=$name(?:&|$)/)
		{
			my $file = $PREF{other_prefs_files}{$num}{shortcut_target};
			if($PREF{other_prefs_files_are_in_docroot} =~ /yes/i)
			{
				$file = "$PREF{DOCROOT}/$file";
				condense_slashes('leave_leading_UNC', $file);
			}
			die_nice("prefs file '$file' does not exist.") unless -e $file;
			push @other_prefs_files, $file;
		}
	}
	if($PREF{enable_other_prefs_files_with_filename_on_URL} =~ /yes/i)
	{
		while($qs =~ /(?:^|&)prefsfile=(.+?)(?:&|$)/g)
		{
			my $file = $1;
			if($PREF{other_prefs_filenames_from_URL_can_contain_paths} =~ /yes/i)	{ $file = enc_untaint($file, 'keep_path');	}
			else									{ $file = enc_untaint($file);			}
			if($PREF{other_prefs_files_are_in_docroot} =~ /yes/i)
			{
				$file = "$PREF{DOCROOT}/$file";
				condense_slashes('leave_leading_UNC', $file);
			}
			die_nice("prefs file '$file' does not exist.") unless -e $file;
			push @other_prefs_files, $file;
		}
	}
	foreach my $prefs_file (@other_prefs_files)
	{
		my $prefs_contents = ();
		open(IN,"<$prefs_file") or die_nice("couldn't open prefs file '$prefs_file': $!");
		flock IN, 1;
		seek IN, 0, 0;
		while(<IN>) { $prefs_contents .= $_; }
		close IN or die_nice("couldn't close prefs file '$prefs_file': $!");
		$prefs_contents =~ /(.*)/s;
		$prefs_contents = $1; # cheap untaint since this is our own config file.
		eval $prefs_contents; die_nice("Error processing your prefs file: $@") if $@;
	}

	# Technically not a "file" but probably currently the best place to put this:
	if($PREF{enable_altmode_prefs} =~ /yes/i)
	{
		foreach my $pref (sort keys %PREF)
		{
			if($pref =~ /^altmode_([0-9A-Za-z]+)___(.+)/   &&   $QS{altmode} eq $1)
			{
				# Special case for $PREF{css_extra}, because we'd like to be able to set stuff in there
				# via the prefs_extra file and/or WebConfig, without one overriding (erasing) the other:
				if($2 eq 'css_extra')	{ $PREF{css_extra} .= $PREF{$pref}; }
				else			{ $PREF{$2} = $PREF{$pref}; }
			}
		}
		foreach my $text (sort keys %TEXT)
		{
			if($text =~ /^altmode_([0-9A-Za-z]+)___(.+)/   &&   $QS{altmode} eq $1)	{ $TEXT{$2} = $TEXT{$text}; }
		}
	}
}


sub do_preinit()
{
	$PREF{app_start_time} = time;
	if($ENV{QUERY_STRING} eq 'version') { print "Content-type: text/plain\n\n"; print "$version\n"; exit; }
	my ($cwd) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)/.*?$!);
	unless($cwd) { $cwd = $ENV{PATH_TRANSLATED}; $cwd =~ s![^/\\]+$!!; }
	enc_chdir($cwd);
	$PREF{initial_cwd} = $cwd;
	$PREF{on_page} = 'default';
	$qs = $ENV{QUERY_STRING};
	# Check for embed, and then remove the "encembed=yes" so it's not present on any URLs where we re-use $qs, because this should only be present when hard-coded from a php/shtml/etc page.
	$PREF{we_are_embedded} = $qs =~ /encembed=yes/ ? 1 : 0; $qs =~ s!&encembed=yes!!g; $qs =~ s!encembed=yes&!!g; $qs =~ s!encembed=yes!!g;
	populate_var_hashes();
}


sub verify_server_environment()
{
	#print STDERR dumphash(\%ENV,"\n") . "\n";
	my ($SCRIPT_var_count, $SERVER_var_count) = (0, 0);
	my @all_vars = ();
	foreach my $var (sort keys %ENV)
	{
		$SCRIPT_var_count++ if $var =~ /^SCRIPT_/;
		$SERVER_var_count++ if $var =~ /^SERVER_/;
		push @all_vars, "$var: $ENV{$var}";
	}
	unless($SCRIPT_var_count > 0 && $SERVER_var_count > 0)
	{
		die qq`Error: it seems I've been executed on a command line, but that won't work, since I'm a web application and must be executed within a server environment.\n`; # . qq`\nAll vars: ` . (join "\n", @all_vars) . qq`\n\n`;
	}
}


sub fix_server_environment()
{
	fix_remote_ip_and_host();

	# Fix the %ENV if necessary.
	#
	if(!$ENV{REQUEST_URI}) # IIS is crap.
	{
		$ENV{REQUEST_URI} = $ENV{PATH_INFO};
		$ENV{REQUEST_URI} ||= $ENV{SCRIPT_NAME};   # Because IIS doesn't always set PATH_INFO either.
		$ENV{REQUEST_URI} .= '?' . $qs if $qs;
	}

	$ENV{HTTP_HOST_WITHOUT_WWW} = $ENV{HTTP_HOST}; $ENV{HTTP_HOST_WITHOUT_WWW} =~ s!^www\.!!i;

	# On GoDaddy, for subdomains, they set DOCUMENT_ROOT incorrectly, and set SUBDOMAIN_DOCUMENT_ROOT to the real docroot.
	$ENV{DOCUMENT_ROOT} = $ENV{SUBDOMAIN_DOCUMENT_ROOT} if $ENV{SUBDOMAIN_DOCUMENT_ROOT};

	$PREF{DOCROOT} ||= $ENV{DOCUMENT_ROOT};
	if(!$PREF{DOCROOT})
	{
		($PREF{DOCROOT}) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)$ENV{SCRIPT_NAME}$!i);
		if(!$PREF{DOCROOT})
		{
			# try to fix IIS garbage.
			my $path_translated = $ENV{PATH_TRANSLATED};
			my $is_unc = $path_translated =~ m!^\\\\!;
			$path_translated =~ s!\\\\!/!g;
			$path_translated =~ s!\\!/!g;
			$path_translated =~ s!^[/\\]+!\\\\! if $is_unc;
			if($path_translated =~ m!^(.+)$ENV{PATH_INFO}$!i)
			{
				$PREF{DOCROOT} = $1;
			}
			else
			{
				$PREF{DOCROOT} = ($path_translated =~ m!(.+)/[^/]+!)[0];
			}
		}
		$PREF{docroot_autodetection_error} = "Error: couldn't set \$PREF{DOCROOT} from \$ENV{DOCUMENT_ROOT} ('$ENV{DOCUMENT_ROOT}'), \$ENV{SCRIPT_FILENAME} ('$ENV{SCRIPT_FILENAME}'), or \$ENV{PATH_TRANSLATED} ('$ENV{PATH_TRANSLATED}').\n" unless $PREF{DOCROOT};
	}
	$PREF{DOCROOT} =~ s![/\\]+$!! unless $PREF{DOCROOT} =~ m!^[/\\]+$!; # remove trailing slashes.

	# Fix another Network Solutions bug:
	if($PREF{DOCROOT} =~ m!/usr/services/vux/apache/htdocs!   &&   $ENV{SCRIPT_FILENAME} =~ m!(/data/\d+/\d+/\d+/\d+/\d+/user/\d+)/cgi-bin!)
	{
		$PREF{DOCROOT} = "$1/htdocs";
	}
	# Similar but slightly different Network Solutions path:
	if($PREF{DOCROOT} =~ m!/usr/services/vux/apache/htdocs!   &&   $ENV{SCRIPT_FILENAME} =~ m!(/data/\d+/\d+/\d+/\d+/\d+/user/\d+.*)/cgi!)
	{
		$PREF{DOCROOT} = $1;
	}

	my $default_scriptname = '/cgi-bin/' . $PREF{internal_filename} . '.cgi';
	$ENV{SCRIPT_NAME} ||= $default_scriptname;

	# Fix for broken Network Solutions servers:
	$ENV{SCRIPT_NAME} = $1 if $ENV{SCRIPT_NAME} =~ m!~\d+\.\d+/(/cgi-bin/.+)!;

	# Fix stupid servers that set our scriptname to the wrapper scriptname:
	$ENV{SCRIPT_NAME} = $default_scriptname if $ENV{SCRIPT_NAME} =~ /\.php/ && -e "$PREF{DOCROOT}/$default_scriptname";
	$ENV{SCRIPT_NAME} = $default_scriptname if $ENV{SCRIPT_NAME} =~ /\.php/ && -e "$PREF{DOCROOT}/../$default_scriptname";

	# Fix more GoDaddy nonsense:
	$ENV{SCRIPT_NAME} = ($ENV{SCRIPT_FILENAME} =~ /^$ENV{SUBDOMAIN_DOCUMENT_ROOT}(.+)/)[0] if $ENV{SUBDOMAIN_DOCUMENT_ROOT};

	# Block potential XSS attempts.
	die "Invalid query-string data\n" if xss_match($qs);

	# In the vast majority of cases (99%+?) there will never be a valid reason to have an lt or gt in a URL,
	# so in addition to our per-URL-variable checking in xss_match(), let's just block them all here.  In
	# the rare case where someone does need them, they can edit this file and disable this line:
	die "Disallowed query-string" if ($qs =~ /<|>|%3C|%3E/i) || (enc_urldecode_return($qs) =~ /<|>|%3C|%3E/i);
}


sub set_default_prefs_for_all_apps()
{
	# Prefs that are needed by all apps, and that are (at least by default) set
	# to the same values in all apps.  And we don't need any "unless exists"
	# tests here because this sub is called before loading external prefs.

	$PREF{max_tablename_length}			= 80;

	$PREF{site_session_cookie}			= 'site_session';
	$PREF{encauth_login_cookie}			= 'encauth_login_' . $PREF{twochar_app_id};   # this was formerly 'enc_non_ub_login' but must now be per-app since it's now based on the site_salt which is different for each app.
	$PREF{num_days_login_lasts}			= 14;
	$PREF{enc_visitor_id_cookie}			= 'encvisid';
	$PREF{enc_visitor_id_was_missing}		= 1 unless $COOKIE{ $PREF{enc_visitor_id_cookie} };
	$PREF{enc_visitor_id}				= $COOKIE{ $PREF{enc_visitor_id_cookie} } || generate_nonce();

	$PREF{password_hash_iterations}			= $MISC{SHA_note} =~ /^Using Digest::SHA::PurePerl/ ? 186 : 36083;   # The PurePerl version is far slower, so we can't do nearly as many iterations without a drastic performance hit.
	$PREF{max_hashedpw_length}			= 250;

	$PREF{public_group_name}			= 'public';
	$PREF{member_group_name}			= 'member';
	$PREF{admin_group_name}				= 'admin';
	$PREF{expired_group_name}			= 'expired';

	$PREF{normal_dir_perms}				= 0755;
	$PREF{writable_dir_perms}			= 0777;
	$PREF{writable_file_perms}			= 0666;
	$PREF{executable_file_perms}			= 0755;

	$PREF{here}					= $ENV{SCRIPT_NAME};
	#$PREF{here_login}				= $ENV{SCRIPT_NAME}; # deprecated by figure_out_where_here_is (?)

	$PREF{needlogin_message}			= qq`%%js_auto_redirect%%<h1 class="pagetitle">Login Required</h1><p>Login required; <a href="%%login_url%%">click here</a> to continue.</p>`;
	$PREF{needprivs_message}			= qq`%%js_auto_redirect%%<h1 class="pagetitle">Access Denied</h1><p>Access denied.&nbsp; %%%if-notloggedin%%%Perhaps you need to <a href="%%login_url%%">login</a> first?%%%end-notloggedin%%%</p>`;

	$PREF{success_message_template}			= qq`<h2>Success</h2>\n<p>%%message%%</p>\n`;
	$PREF{notice_message_template}			= qq`<h2>Notice</h2>\n<p>%%message%%</p>\n`;
	$PREF{error_message_template}			= qq`<h2>Error</h2>\n<p>%%message%%</p>\n`;

	$PREF{find_cmd}					= 'find';

	$PREF{php_session_cache_ttl}			= 60*60*24;
	$PREF{php_session_cache_file}			= '%PREF{datadir}/phpcache.txt';
	$PREF{php_session_cookie_name}			= 'PHPSESSID';

	# Set some common MIME types for when we need to send script-based downloads:
	$PREF{mimetype_for_avi}				= 'video/x-msvideo';
	$PREF{mimetype_for_bmp}				= 'image/x-bmp';
	$PREF{mimetype_for_doc}				= 'application/x-msword';
	$PREF{mimetype_for_flv}				= 'video/x-flv';
	$PREF{mimetype_for_gif}				= 'image/gif';
	$PREF{mimetype_for_htm}				= 'text/html';
	$PREF{mimetype_for_html}			= 'text/html';
	$PREF{mimetype_for_jpg}				= 'image/jpeg';
	$PREF{mimetype_for_jpeg}			= 'image/jpeg';
	$PREF{mimetype_for_mov}				= 'video/quicktime';
	$PREF{mimetype_for_mpg}				= 'video/mpeg';
	$PREF{mimetype_for_mpeg}			= 'video/mpeg';
	$PREF{mimetype_for_mp3}				= 'audio/mpeg';
	$PREF{mimetype_for_mp4}				= 'video/mp4';
	$PREF{mimetype_for_pdf}				= 'application/pdf';
	$PREF{mimetype_for_php}				= 'text/html';
	$PREF{mimetype_for_png}				= 'image/png';
	$PREF{mimetype_for_tif}				= 'image/tiff';
	$PREF{mimetype_for_tiff}			= 'image/tiff';
	$PREF{mimetype_for_txt}				= 'text/plain';
	$PREF{mimetype_for_xls}				= 'application/vnd.ms-excel';
	$PREF{mimetype_for_zip}				= 'application/zip';

	$PREF{check_daily_for_old_files}		= 'yes';
	$PREF{check_hourly_for_old_files}		= 'no';
	$PREF{minutes_at_which_to_check_for_old_files}	= '0,15,30,45'; # can be from 0 to 59.

	$PREF{human_test_folder_name}			= 'encht';
	$PREF{human_test_image_directory___url}		= '%PREF{appdir_url}/%PREF{human_test_folder_name}';
	$PREF{human_test_image_directory___real}	= '%PREF{appdir_real}/%PREF{human_test_folder_name}';
}


sub check_for_enc_visitor_id()
{
	# This check must occur before trying anything that could result in an error
	# like reading prefs files, checking whether datadirs exist, etc.  That's 
	# because in some cases, particularly when a client wants to use ENV variables
	# from PHP to set a path pref dynamically, an error due to a nonexistent path
	# would prevent us from setting the enc_visitor_id, but would also be *caused*
	# by a missing enc_visitor_id.  So, set_enc_visitor_id() is designed to not
	# depend on anything else (prefs, etc), so it can be called separately and
	# then exit, just to get the cookie in place.

	if($qs =~ /(^|&)action=set_enc_visitor_id(&|$)/) { set_enc_visitor_id(); } # exits early.
}


sub get_enc_visitor_id_iframe()
{
	return $PREF{enc_visitor_id_was_missing} ? qq`<iframe src="$ENV{SCRIPT_NAME}?action=set_enc_visitor_id&amp;newid=$PREF{enc_visitor_id}" name="enc_vis_id_setter" id="enc_vis_id_setter" width="1" height="1" style="position: absolute; left: -5000px; height: 0;"></iframe>\n` : '';
}


sub set_enc_visitor_id()
{
	set_cookie($PREF{enc_visitor_id_cookie}, get_qs_var('newid'), "+365d");
	print_http_headers({ nocache => 1, nokeepalive => 1 });
	exit;
}


sub populate_var_hashes()
{
	foreach my $cookie (split(/;\s*/, $ENV{HTTP_COOKIE}))
	{
		my ($name,$value) = split(/=/, $cookie);
		$COOKIE{$name} = enc_urldecode_return($value);
	}

	foreach my $var (split(/&+/, $ENV{QUERY_STRING}))
	{
		my ($name, $value) = split(/=/, $var);
		$QS{$name} = enc_urldecode_return($value);
	}
}


sub settle_docroot_datadir_cgimodule_etc()
{
	# DOCROOT must be one of the first things settled after loading the external prefs:
	#
	$PREF{DOCROOT} = enc_untaint($PREF{DOCROOT}, 'keep_path');
	exit_with_error("Error: you have set \$PREF{DOCROOT} to '$PREF{DOCROOT}', but that path does not exist.  You must create it now, or adjust this setting to point to the correct directory.") if ! -d $PREF{DOCROOT};


	# datadir should be settled right after DOCROOT:
	#
	$PREF{datadir} = 'encdata' unless $PREF{datadir};
	$PREF{datadir} = $PREF{DOCROOT} . $PREF{datadir} if $PREF{datadir_is_in_docroot} eq 'yes';
	create_dir_if_DNE($PREF{datadir}, $PREF{writable_dir_perms}, 'make_parents', 'ignore_errors');
	exit_with_error(qq`Error: your settings for \$PREF{datadir} and \$PREF{datadir_is_in_docroot} \nresult in \$PREF{datadir} being set to '$PREF{datadir}', \nbut that path does not exist.  You must create it, or adjust these \nsettings to point to the correct directory.`) unless -d $PREF{datadir};
	exit_with_error(qq`Error: the directory \$PREF{datadir}  ($PREF{datadir}, in cgi-bin by default)  must be readable and writable by this script (which usually means world-readable and world-writable, which is 0777, or drwxrwxrwx), but it isn't.`) unless ((-r $PREF{datadir}) && (-w $PREF{datadir}));
	#
	# Append our per-app subdir onto datadir ($PREF{datadir} should be set to just 'encdata' by default):
	#
	$PREF{datadir_subdir_name} = $PREF{internal_appname} unless $PREF{datadir_subdir_name};
	$PREF{datadir} .= $PREF{datadir} =~ m![/\\]$! ? $PREF{datadir_subdir_name} : "/$PREF{datadir_subdir_name}";
	create_dir_if_DNE($PREF{datadir}, $PREF{writable_dir_perms});


	if($PREF{debuglog} =~ /yes/i) # Note: $PREF{debuglog} can't be set via WebConfig, because this sub is called before those prefs are loaded.
	{
		$PREF{debuglogdir} = $PREF{datadir} . '/debuglogs';
		create_dir_if_DNE($PREF{debuglogdir}, $PREF{writable_dir_perms});
		$PREF{debuglogfile} = $PREF{debuglogdir} . '/' . date8() . '.cgi';
		create_file_if_DNE($PREF{debuglogfile}, $PREF{writable_file_perms});
	}


	# Once $PREF{datadir} is settled, set $ENV{TMPDIR} to that, and THEN we can
	# import the CGI module via "require CGI;" and it will use our $ENV{TMPDIR}
	# setting as its temp space during uploads.
	#
	$ENV{TMPDIR} = $PREF{datadir} unless $PREF{dont_use_datadir_as_cgi_tmpdir} =~ /yes/i;
	$CGITempFile::TMPDIRECTORY = $PREF{datadir} unless $PREF{dont_use_datadir_as_cgi_tmpdir} =~ /yes/i; # necessary on some servers?
	#
	#use CGI; # DO NOT USE THIS!
	#
	require CGI;
	#
	#use CGI qw/:standard :param/; # DO NOT USE THIS!
	#use CGI qw(param); # DO NOT USE THIS!
	#
	import CGI ':standard';
	import CGI ':param';
	#
	use CGI::Cookie; # "use" is OK for sub-modules.
	$MISC{cookies} = fetch CGI::Cookie;


	unless($PREF{app_base_folder} =~ m!^/!)
	{
		$PREF{app_base_folder} = '/login'	if $PREF{internal_appname} eq 'userbase';
		$PREF{app_base_folder} = '/upload'	if $PREF{internal_appname} eq 'filechucker';
		$PREF{app_base_folder} = '/visitors'	if $PREF{internal_appname} eq 'visitorlog';
		$PREF{app_base_folder} = '/contact'	if $PREF{internal_appname} eq 'contactform';
		$PREF{app_base_folder} = '/mailylist'	if $PREF{internal_appname} eq 'mailylist';
		$PREF{app_base_folder} = '/store'	if $PREF{internal_appname} eq 'cornerstore';
		$PREF{app_base_folder} = '/enccms'	if $PREF{internal_appname} eq 'enccms';
	}
	exit_with_error("Error: \$PREF{app_base_folder} not set; it must be set to something like '/appname'.") unless $PREF{app_base_folder};


	# appdir is like datadir except a) it's servable and b) it's per-app (within the
	# app's base folder) rather than within the shared /cgi-bin/encdata folder.
	#
	$PREF{appdir_url}	||= $PREF{app_base_folder} . ($PREF{app_base_folder} =~ m![/\\]$! ? '' : '/') . "appdata";
	$PREF{appdir_real}	||= $PREF{DOCROOT} . $PREF{appdir_url};
	exit_with_error("$PREF{internal_appname_nice}'s appdata folder ('$PREF{appdir_url}') does not exist on your website; you must create it now, or else adjust the \$PREF{app_base_folder} setting.  This must be within your \$PREF{DOCROOT}, which is currently '$PREF{DOCROOT}'.") unless -d $PREF{appdir_real};
	exit_with_error(qq`$PREF{internal_appname_nice}'s appdata folder ('$PREF{appdir_url}') must be readable and writable by this script (which usually means world-readable and world-writable, which is 0777, or drwxrwxrwx), but it isn't.`) unless ((-r $PREF{appdir_real}) && (-w $PREF{appdir_real}));

	unless($PREF{skip_appdir_permissions_checks} =~ /yes/i)
	{
		my @all_dirs = ($PREF{appdir_real}, $PREF{datadir});
		push (@all_dirs, $PREF{appdir_real} . '/' . $_) for get_all_subdirs($PREF{appdir_real});
		push (@all_dirs, $PREF{datadir} . '/' . $_) for get_all_subdirs($PREF{datadir});
		foreach my $dir (@all_dirs)
		{
			exit_with_error("The folder '$dir' must be readable and writable by this script (which usually means world-readable and world-writable, which is 0777, or drwxrwxrwx), but it isn't; you must adjust its permissions to make it so.") unless ((-r $dir) && (-w $dir));
		}
	}

	$PREF{cached_output_dir_url}  = $PREF{appdir_url}  . '/cached_output';
	$PREF{cached_output_dir_real} = $PREF{appdir_real} . '/cached_output';
	create_dir_if_DNE($PREF{cached_output_dir_real}, $PREF{writable_dir_perms});
}


sub figure_out_where_here_is
{
	$PREF{here} = $ENV{SCRIPT_NAME} unless exists $PREF{here};
	$PREF{here} = $PREF{login_url} if $PREF{login_url} && $PREF{internal_appname} eq 'userbase';
	$PREF{here} = ($ENV{REQUEST_URI} =~ m!([^\?]+)!)[0] if $ENV{REQUEST_URI} && $PREF{here} eq 'auto';
	$PREF{here} = $PREF{login_url} = $ENV{SCRIPT_NAME} if $qs =~ /forcecgi=1/;
	for('here_static', 'here_login')
	{
		$PREF{$_} = $PREF{here} unless $PREF{$_}; # ($PREF{$_} && $PREF{$_} ne $ENV{SCRIPT_NAME});
		$PREF{$_} = $ENV{SCRIPT_NAME} unless $PREF{$_} =~ /./;

		$PREF{$_ . '_qsready'} = $PREF{$_} =~ /\?/ ? "$PREF{$_}&amp;" : "$PREF{$_}?";
	}
	$PREF{here_qsready} = $PREF{here} =~ /\?/ ? "$PREF{here}&amp;" : "$PREF{here}?";
	$PREF{login_url_qsready} = $PREF{login_url} =~ /\?/ ? "$PREF{login_url}&amp;" : "$PREF{login_url}?";
}


sub set_protoprefix_www_https_etc()
{
	$PREF{REQ_URI_SANS_QS} = ($ENV{REQUEST_URI} =~ /^([^\?]+)/)[0];
	$PREF{we_are_virtual} = $PREF{REQ_URI_SANS_QS} ne $ENV{SCRIPT_NAME};
	$PREF{REQ_URI_WITH_QS} = $PREF{REQ_URI_SANS_QS} . ($qs ? "?$qs" : '');

	$PREF{protoprefix} = $PREF{protoprefix} ? $PREF{protoprefix} : ($ENV{SERVER_PORT} =~ /443/ || $ENV{HTTPS} =~ /on/i) ? 'https://' : 'http://';

	$PREF{default_url_vars} = "&forcefullhtml=yes" if $qs =~ /forcefullhtml=yes/i;
	$PREF{default_url_vars} .= "&$1" if $qs =~ /(?:^|&)(prefs=[^&]+)/;
	$PREF{default_url_vars} .= "&$1" if $qs =~ /(?:^|&)(prefsfile=[^&]+)/;

	if($PREF{add_www_to_hostname} =~ /yes/i && $ENV{HTTP_HOST} !~ /^www\./i)
	{
		my $go = "$PREF{protoprefix}www.$ENV{HTTP_HOST}$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
		enc_redirect($go);
	}
	elsif($PREF{add_www_to_hostname} !~ /yes/i && $PREF{remove_www_from_hostname} =~ /yes/i && $ENV{HTTP_HOST} =~ /^www\.(.+)/i)
	{
		my $host = $1;
		my $go = "$PREF{protoprefix}$host$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
		enc_redirect($go);
	}

	if($PREF{force_https} =~ /yes/i && $ENV{HTTPS} !~ /^(on|yes|enabled|true|1)$/i)
	{
		my $go = "https://$ENV{HTTP_HOST}$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
		enc_redirect($go);
	}

	if($PREF{prevent_direct_cgi_access} =~ /yes/i   &&   !$PREF{we_are_virtual}   &&   $ENV{REQUEST_METHOD} !~ /post/i   &&   !$qs)
	{
		print_http_headers();
		print $PREF{direct_cgi_access_error};
		exit;
	}

	$PREF{time_offset}			= $PREF{time_offset} * 3600			if $PREF{time_offset} =~ /^-?\d+$/;
}


sub do_postpref_processing()
{
	# Use this spot for any code that must run immediately after prefs are loaded.
	#
	if($PREF{internal_appname} eq 'visitorlog')
	{
		$PREF{print_full_html_tags} = 'no' if $qs =~ /(^|&)(justsummary|mode=hitsgraph)(&|$)/;
	}

	# These are postpref so they can use offsettime():
	#
	my $start	= offsettime();
	$PREF{date6}	= date6($start);
	$PREF{date8}	= date8($start);
	$PREF{date14}	= date14($start);

	$PREF{today}		= $PREF{date8};
	$PREF{yesterday}	= decrement_datestring_8($PREF{today}, 1);
	$PREF{'2_days_ago'}	= decrement_datestring_8($PREF{today}, 2);

	# In case someone manually edits their webconfig_prefs file and screws up the line endings.
	# Other prefs may also be affected, but these are mission-critical, so auto-fix them:
	for($PREF{site_salt}, $PREF{admin_password_hash_01}, $PREF{database_name}, $PREF{database_hostname}, $PREF{database_username}, $PREF{database_password})
	{
		s!^[\r\n\s]+!!g;
		 s![\r\n\s]+$!!g;
	}
}


sub do_blacklisting_and_whitelisting()
{
	do_group_based_blacklisting_and_whitelisting();

	my $blocked = 0;

	my $ip_whitelisting_enabled = 0;
	my $user_matches_ip_whitelist = 0;
	foreach my $rule (sort keys %{$PREF{forced_whitelist_ip_addresses}})
	{
		if(my $allowed_ip = $PREF{forced_whitelist_ip_addresses}{$rule})
		{
			$ip_whitelisting_enabled = 1;
			$user_matches_ip_whitelist = 1 if $PREF{ip} =~ /$allowed_ip/;
		}
	}
	$blocked = 1 if $ip_whitelisting_enabled && !$user_matches_ip_whitelist;

	my $host_whitelisting_enabled = 0;
	my $user_matches_host_whitelist = 0;
	foreach my $rule (sort keys %{$PREF{forced_whitelist_hostnames}})
	{
		if(my $allowed_host = $PREF{forced_whitelist_hostnames}{$rule})
		{
			$host_whitelisting_enabled = 1;
			$user_matches_host_whitelist = 1 if $PREF{host} =~ /$allowed_host/i;
		}
	}
	$blocked = 1 if $host_whitelisting_enabled && !$user_matches_host_whitelist;

	foreach my $rule (sort keys %{$PREF{forced_blacklist_ip_addresses}})
	{
		if(my $blocked_ip = $PREF{forced_blacklist_ip_addresses}{$rule})
		{
			$blocked = 1 if $PREF{ip} =~ /$blocked_ip/;
		}
	}

	foreach my $rule (sort keys %{$PREF{forced_blacklist_hostnames}})
	{
		if(my $blocked_host = $PREF{forced_blacklist_hostnames}{$rule})
		{
			$blocked = 1 if $PREF{host} =~ /$blocked_host/;
		}
	}

	exit_with_error($TEXT{failed_black_or_white_list}) if $blocked;
}


sub do_group_based_blacklisting_and_whitelisting()
{
	foreach my $rule (sort keys %{$PREF{grouped_whitelist_ip_addresses}})
	{
		if(my $allowed_ip = $PREF{grouped_whitelist_ip_addresses}{$rule})
		{
			$PREF{user_is_encwhitelisted} = 1 if $PREF{ip} =~ /$allowed_ip/;
		}
	}

	foreach my $rule (sort keys %{$PREF{grouped_whitelist_hostnames}})
	{
		if(my $allowed_host = $PREF{grouped_whitelist_hostnames}{$rule})
		{
			$PREF{user_is_encwhitelisted} = 1 if $PREF{host} =~ /$allowed_host/i;
		}
	}

	foreach my $rule (sort keys %{$PREF{grouped_blacklist_ip_addresses}})
	{
		if(my $blocked_ip = $PREF{grouped_blacklist_ip_addresses}{$rule})
		{
			$PREF{user_is_encblacklisted} = 1 if $PREF{ip} =~ /$blocked_ip/;
		}
	}

	foreach my $rule (sort keys %{$PREF{grouped_blacklist_hostnames}})
	{
		if(my $blocked_host = $PREF{grouped_blacklist_hostnames}{$rule})
		{
			$PREF{user_is_encblacklisted} = 1 if $PREF{host} =~ /$blocked_host/;
		}
	}
}


sub do_setup_and_dispatch_for_encauth_and_db()
{
	setup_admin_password();

	# The encauth login and login-check need to happen before the database connection,
	# so that the user can set his db prefs via webconfig if necessary.
	#
	if($qs =~ /(?:^login$|action=login(&|$))/)
	{
		expand_custom_vars_in_prefs('include_undefined');
		do_encauth_login(); exit;
	}
	elsif($qs eq 'logout' || get_qs_var('action') eq 'logout')
	{
		expand_custom_vars_in_prefs('include_undefined');
		do_encauth_logout(); exit;
	}
	elsif($qs =~ /(?:^|&)$PREF{twochar_app_id}smsg=encauthfailedlogin(?:&|$)/)
	{
		# we need to intercept this one particular ?smsg case in early dispatch.
		exit_with_error($TEXT{The_password_you_entered_is_incorrect___});
	}
	else
	{
		check_if_logged_in_with_encauth();
	}

	# Early dispatch: these need to be here rather than in the main dispatch chain
	# so that setup_database_prefs() can use them.  But, in UserBase, eventually
	# check_if_logged_in_with_encauth() will be false (once the real admin account
	# is set up), so we can't ONLY test for these here; we also need to test for
	# them in each app's main dispatch chain (not just UB), and then be sure to
	# skip them here if there's no valid encauth login (which makes both of these
	# illegal anyway).
	#
	if($PREF{admin_is_logged_in})
	{
		if(get_qs_var('action') eq 'savewebconfigprefajax') { save_webconfig_pref_ajax(); }
		if(get_qs_var('action') eq 'testdbconnajax') { test_database_connection_ajax(); }
	}
}


sub get_cookies()
{
	my %cookies = fetch CGI::Cookie;
	return %cookies;
}


sub get_cookie($)
{
	my $which = shift;
	my %jar = $MISC{cookies} ? %{$MISC{cookies}} : ();
	my $value = '';

	if(exists $jar{$which})
	{
		$value = $jar{$which}->value;
	}
	elsif($which eq $PREF{site_session_cookie})
	{
		if($qs =~ /(?:^|&)ubsessioncode=(\w+)(?:&|$)/)
		{
			my $code = $1;

			# Accepting the session code from the URL should only be allowed as a last resort.
			# On decent servers this shouldn't be necessary because we can call UserBase
			# from PHP using virtual() and/or exec() both of which pass the cookies.  Even
			# on sub-par servers where we have to use include() with the full http:// URL,
			# we can reduce the security risk by requiring the remote IP to match the server
			# IP, i.e. ONLY allow the include(http://...) method to work: don't accept URL-
			# based session codes from any other IP.  As a last resort on totally sucky
			# servers where PHP is crippled and $ENV{SERVER_ADDR} DNE or is variable or
			# otherwise useless, proceed only by setting a PREF that indicates what a bad
			# idea it is.

			if($PREF{ip} eq $ENV{SERVER_ADDR})
			{
				$value = $code;
			}
			elsif($PREF{my_server_sucks_so_use_less_secure_mode} =~ /yes/i)
			{
				sleep $PREF{sleeptime_for_less_secure_mode} || 3;
				$value = $code;
			}
		}
	}

	return $value;
}


sub set_cookie
{
	my $name = shift;
	my $value = shift;
	my $expiry = shift;
	my $secure = shift;
	my $httponly = shift;

	my $cookie = undef;

	# The if/else for expiry is because setting "expires" to "" isn't
	# the same as not setting it.  Setting it to "" is the same as 
	# setting it to zero, which expires the cookie immediately
	# (i.e., deletes it).  But explicitly *not* setting the expiry
	# causes the cookie to persist until the end of the session.

	if($PREF{cookie_domain})
	{
		if($expiry eq "")	{ $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -secure => $secure, -httponly => $httponly, -domain => $PREF{cookie_domain}); }
		else			{ $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -secure => $secure, -httponly => $httponly, -domain => $PREF{cookie_domain}, -expires => $expiry); }
	}
	else
	{
		if($expiry eq "")	{ $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -secure => $secure, -httponly => $httponly,); }
		else			{ $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -secure => $secure, -httponly => $httponly, -expires => $expiry); }
	}

	if($PREF{output_started})
	{
		print "<p>$PREF{internal_appname} warning: cannot set cookie '$name' => '$value' because the page output has already been started (perhaps debug is enabled?).</p>\n";
	}
	elsif($PREF{we_are_virtual})
	{
		print_http_headers({ nocache => 1, nokeepalive => 1 });
		print "<p>$PREF{internal_appname} warning: cannot set cookie '$name' => '$value' because we are virtual.</p>\n";
	}
	else
	{
		print_p3p_header();
		print "Set-Cookie: $cookie\n";
	}
}


sub determine_cookie_domain
{
	if($ENV{HTTP_HOST} =~ /\w+\.\w+/   &&   !is_ipv4_address($ENV{HTTP_HOST})   &&   !($PREF{never_specify_domain_when_setting_cookies} =~ /yes/i))
	{
		# If we're running on a domain name, then specify it in our cookies.  This allows us
		# to put a dot at the start of the domain name, which causes the cookies to be set for
		# and accessible from the domain and all subdomains including www.  So we'll remove
		# any leading www first, as well as any port number.

		my $domain = $ENV{HTTP_HOST}; $domain =~ s!^www\.!!; $domain =~ s!:\d+$!!; $domain = ".$domain";
		$PREF{cookie_domain} = $domain;
	}
}


sub get_qs_var
{
	my $arg = shift;
	if(ref($arg) eq 'HASH')
	{
		# new way: pass in an anonymous hash containing at least var=>foo, plus other optional options, e.g.:
		#
		# 	my $foo = get_qs_var({ var=>'foo',  maxlength=>150, notnull=>1, allowedchars=>'\w\.-' });
		#
		my $opts = $arg;
		my $val = enc_urldecode_return(   ($qs =~ /(?:^|&(?:amp;)?)$$opts{var}=([^&]*)/)[0]   );
		exit_with_error qq`Variable "$$opts{var}" can't be null, but it is.`		if $val eq ""				&& $$opts{notnull};
		exit_with_error qq`Variable "$$opts{var}" must be alphanumeric, but it isn't.`	if $val !~ /^\w*$/			&& $$opts{alphanumeric};
		exit_with_error qq`Variable "$$opts{var}" must be numeric, but it isn't.`	if $val !~ /^\d*$/			&& $$opts{numeric};
		exit_with_error qq`Variable "$$opts{var}" must be decimal, but it isn't.`	if $val !~ /^[\d\.]*$/			&& $$opts{decimal};
		exit_with_error qq`Variable "$$opts{var}" contains illegal characters.`		if $$opts{allowedchars}	&& $val =~ /[^$$opts{allowedchars}]/;

		my $maxlength = $$opts{maxlength} || 100;
		exit_with_error qq`Variable "$$opts{var}" must be shorter than $maxlength characters, but it's not.` if length($val) > $maxlength;

		return $val;
	}
	else
	{
		# old way: just pass in a string, which is the variable name.
		return enc_urldecode_return(   ($qs =~ /(?:^|&(?:amp;)?)$arg=([^&]*)/)[0]   );
	}
}


# APICHANGE: 201012: expand_custom_vars_in_prefs() no longer accepts a hashref,
# only an optional string.
#
sub expand_custom_vars_in_prefs
{
	$PREF{expand_vars_called} = 1;
	expand_custom_vars_in_prefs___inner(\%PREF, @_);
	expand_custom_vars_in_prefs___inner(\%TEXT, @_);
}


sub expand_custom_vars_in_prefs___inner
{
	my $hashref = shift;
	my $include_undefined = shift; $include_undefined = 0 unless $include_undefined eq 'include_undefined';

	# Execute this a few times without undefineds first, so that nested values can be
	# properly expanded (i.e. one setting contains %PREF{foo}, but $PREF{foo} itself
	# contains %PREF{bar}, etc).

	my $num_iterations = 2;   # dropping this from 5 to 2 cuts about 1/3 sec off our execution time.
	for(my $i = 1; $i <= $num_iterations; $i++)
	{
		my $include_undefined_real = $include_undefined && $i == $num_iterations ? 1 : 0;

		foreach my $key (keys %$hashref)
		{
			if(ref($$hashref{$key}) eq 'HASH') # for prefs that are themselves hashes, i.e. $PREF{foo}{01} as in $PREF{foo}{01}{bar}.
			{
				expand_custom_vars_in_prefs___inner($$hashref{$key});
			}
			else
			{
				next unless $$hashref{$key} && $$hashref{$key} =~ /(%%|%PREF{|%TEXT{|%URL{|%COOKIE{|%SQL{|%ENV{|%DATE{)/;
				next if $PREF{"${key}___skip_init_var_expansion"} =~ /yes/i;
				do_standard_template_vars_processing($include_undefined, $$hashref{$key});
			}
		}
	}
}


sub show_prefs
{
	exit_with_needprivs() unless user_is_allowed_to('do_app_administration');
	$PREF{on_a_wide_page} = 1;
	start_html_output("Prefs");
	print qq`<div id="enc_prefs_list" class="enc_tbl">\n<table>\n<tr><th>Prefs</th></tr>\n`;
	my $oddeven = 1;
	my $allprefs = get_prefs('all');
	foreach my $pref (sort { lc($a) cmp lc($b) } keys %$allprefs)
	{
		print qq`<tr class="` . oddeven($oddeven) . qq`"><td><strong>$pref:</strong> $$allprefs{$pref}</td></tr>\n`;
	}
	print qq`</table>\n</div>\n`;
	print $TEXT{enc_apps_note};
	finish_html_output();
}


sub get_prefs
{
	my $all = shift;
	my %prefs = ();
	foreach my $key (sort { lc($a) cmp lc($b) } keys %PREF)
	{
		#if($all   ||   ($key !~ /^(database_name|database_hostname|database_username|database_password|smtp_auth_username|smtp_auth_password)$/))
		#
		# It's not necessary to hide those sensitive values, since we're only
		# displaying all prefs in authenticated situations in the first place.
		#
		if(1)
		{
			my $value = $PREF{$key};
			$value =~ s!<!&lt;!g;
			$value =~ s!>!&gt;!g;
			$value =~ s!\n!\n<br />!g;
			$prefs{$key} = $value;
		}
	}
	return \%prefs;
}


sub load_webconfig_prefs
{
	# webconfig prefs file format rules:
	#
	# 1. Any line starting with a triple-pound-sign (###) is ignored.
	#
	# 2. All other lines must either start with "::-::name = ", or else the line will be
	#    considered a continuation of the previous line.
	#
	# 3. Technically, the separator includes the newline -- it's "\n::-::".  Other newlines
	#    are valid within pref values, so if manually editing the file, don't add any extra
	#    newlines, because they'll be considered a valid part of whichever pref they're in.

	$PREF{webconfig_file} = add_initial_cwd_prefix($PREF{datadir} . '/' . "$PREF{twochar_app_id}_webconfig_prefs.cgi");
	$PREF{webconfig_file} = -e $PREF{webconfig_file} ? $PREF{webconfig_file} : add_initial_cwd_prefix($PREF{datadir} . '/' . "$PREF{script_basename}_webconfig_prefs.cgi");
	create_file_if_DNE($PREF{webconfig_file},$PREF{writable_file_perms});
	my $contents = cat($PREF{webconfig_file});
	while($contents =~ m!((^|\n)###.*?(\n|$))!gs) { my ($wholething,$start) = ($1,$2); $contents =~ s!$wholething!$start!s; }
	$contents =~ s!^::\-::!!s;
	foreach my $pref (split(/\n::\-::/s, $contents))
	{
		if(my ($name, $value) = ($pref =~ /([\w-]+) = (.*)/s))
		{
			if($name =~ /^applog_(.+)/)
			{
				my $date = $1;
				$MISC{applog}{$date} = $value;
				# For most applog entries, we'll just make them available as a dated list of items
				# in a subhash of %MISC, but for the following, we want them accessible by name:
				if($value eq 'firstrun') { $MISC{firstrun} = $date; }
				elsif($value =~ /current_version=(\S+)/) { $MISC{current_version} = $1; }
				elsif($value =~ /num_accounts_at_firstrun=(\d+)/) { $MISC{num_accounts_at_firstrun} = $1; }
				elsif($value =~ /^a_userbase_\w+_has_logged_in_at_some_point$/) { $MISC{$value} = $date; }
			}
			elsif($name =~ /^PREF-(.+)/)
			{
				$WEBCFG{$1}{raw} = $value;
				# Special case for $PREF{css_extra}, because we'd like to be able to set stuff in there
				# via the prefs_extra file and/or WebConfig, without one overriding (erasing) the other:
				if($1 eq 'css_extra')	{ $WEBCFG{css_extra}{val} = $PREF{css_extra} = $PREF{css_extra} . interpolate_vars_into_webconfig_value($value); }
				else			{ $WEBCFG{$1}{val} = $PREF{$1} = interpolate_vars_into_webconfig_value($value); }
				$WEBCFG{$1}{type} = 'PREF';
			}
			elsif($name =~ /^TEXT-(.+)/)
			{
				$WEBCFG{$1}{raw} = $value;
				$WEBCFG{$1}{val} = $TEXT{$1} = interpolate_vars_into_webconfig_value($value);
				$WEBCFG{$1}{type} = 'TEXT';
			}
		}
	}

	if(!$MISC{firstrun})
	{
		$MISC{this_is_the_firstrun} = 1;
		$MISC{firstrun} = date14();
		applog('firstrun', $MISC{firstrun});
	}

	if(!$MISC{current_version})
	{
		$MISC{version_number_changed} = 1;
		applog("setting version in applog for the first time");
		applog("current_version=$version");
	}
	elsif($MISC{current_version} ne $version)
	{
		$MISC{version_number_changed} = 1;
		applog("version has changed from '$MISC{current_version}' to '$version'");
		applog("current_version=$version");
	}

	# Doing this here because a) we want all installations to have & use site_salt, and
	# b) we don't want any users to have to think about it or configure it at all.
	#
	if(! exists $WEBCFG{site_salt})
	{
		$WEBCFG{site_salt}{val} = $PREF{site_salt} = generate_nonce();
		save_new_webconfig_pref('site_salt', $WEBCFG{site_salt}{val});
	}

	$PREF{'max_' . 'username_' . 'length'} = 1+3;
	$PREF{'max_' . 'password_' . 'length'} = 5-1;
	$PREF{'min_' . 'password_' . 'length'} = 7-3;
}


sub load_userbase_webconfig_prefs($)
{
	my $ub_pref_names_to_import = shift;
	my $ub_webconfig_file = add_initial_cwd_prefix('encdata/userbase/userbase_webconfig_prefs.cgi');   # TODO: this will be wrong if the user changes $PREF{datadir}, but no one ever does that (it probably shouldn't even be in the prefs file...)
	return unless -f $ub_webconfig_file;   # Other apps shouldn't try to create UB's webconfig prefs file.
	my $contents = cat($ub_webconfig_file);
	while($contents =~ m!((^|\n)###.*?(\n|$))!gs) { my ($wholething,$start) = ($1,$2); $contents =~ s!$wholething!$start!s; }
	$contents =~ s!^::\-::!!s;
	foreach my $pref (split(/\n::\-::/s, $contents))
	{
		if(my ($name, $value) = ($pref =~ /([\w-]+) = (.*)/s))
		{
			if($name =~ /^PREF-(.+)/)
			{
				my $prefname = $1;
				next unless exists $$ub_pref_names_to_import{$prefname};
				$PREF{$prefname} = interpolate_vars_into_webconfig_value($value);
			}
			elsif($name =~ /^TEXT-(.+)/)
			{
				my $prefname = $1;
				next unless exists $$ub_pref_names_to_import{$prefname};
				$TEXT{$prefname} = interpolate_vars_into_webconfig_value($value);
			}
		}
	}
}


# When loading the regular prefs files, we just eval{} their whole contents, so any $ENV{foo} or $PREF{foo}
# vars get interpolated automatically.  But the format of WebConfig prefs files is different, and we can't
# just eval{} the whole thing, so we need to manually interpolate the $-vars here.  (The %-vars still get
# interpolated by the expand_custom_vars_in_prefs() calls.)  Also, any other double-quoted transforms won't
# have occurred (e.g. turning "\n" into an actual newline) so do those here too.
#
sub interpolate_vars_into_webconfig_value($)
{
	my $value = shift;
	$value =~ s!\$ENV\{([^\}]+)\}!$ENV{$1}!g;
	$value =~ s!\$PREF\{([^\}]+)\}!$PREF{$1}!g;
	$value =~ s!\$TEXT\{([^\}]+)\}!$TEXT{$1}!g;
	$value =~ s!\\n!\n!g;
	return $value;
}


sub download_webconfig_file
{
	exit_with_needprivs() unless user_is_allowed_to('do_app_administration');
	my $size = (stat $PREF{webconfig_file})[7];
	print	  qq`Content-Type: text/plain\n`
		. qq`Content-Disposition: attachment; filename="$PREF{script_basename}_webconfig_prefs.cgi"\n`
		. qq`Content-Length: $size\n`
		. qq`\n`;
	print cat($PREF{webconfig_file});
}


sub save_webconfig_pref   # for internal use, not called via URL.
{
	my $name = shift;
	my $value = shift;
	my $type = shift || 'PREF';
	my $overwrite = 1;   # for now, this sub will always overwrite, since I think the caller will always need to decide what it's doing with the prev/new value of the var being saved.

	if(! exists $WEBCFG{$name}{val})
	{
		my $empty = ! scalar keys %WEBCFG;
		my $newline = "\n" unless $empty;
		add_text_to_file("${newline}::-::$type-$name = $value", $PREF{webconfig_file}, 'end');
	}
	elsif($overwrite)
	{
		my $contents = cat($PREF{webconfig_file});
		$contents =~ s!((?:^|\n)::\-::)$type-$name = .*?(\n::\-::|$)!$1$type-$name = $value$2!sg;
		add_text_to_file($contents, $PREF{webconfig_file}, 'clobber');
	}
	# These probably aren't needed here:  Actually, we might call this and then do other stuff, so maybe they are:
	$WEBCFG{$name}{raw} = $value;
	$WEBCFG{$name}{val} = interpolate_vars_into_webconfig_value($value);
}


sub delete_webconfig_pref   # for internal use, not called via URL.
{
	my $name = shift;
	my $die_on_error = shift;
	my $type = shift || 'PREF';

	if(! exists $WEBCFG{$name})
	{
		die_nice qq`Error: can't delete WebConfig pref '$name' because it doesn't exist.` if $die_on_error;
		return;
	}

	my $contents = cat($PREF{webconfig_file});
	$contents =~ s!((?:^|\n)::\-::)$type-$name = .*?(\n::\-::|$)!$2!sg;
	add_text_to_file($contents, $PREF{webconfig_file}, 'clobber');

	delete $WEBCFG{$name};
}


sub save_webconfig_pref_ajax
{
	my $query = new CGI;

	my $prefnum  = enc_param('prefnum', $query);
	my $preftype = enc_param('preftype', $query) =~ /^(PREF|TEXT)$/ ? $1 : 'PREF';
	my $prefname = enc_param('prefname', $query);
	my $prefvalue= enc_param('prefvalue', $query);
	my $overwrite = $prefnum eq '0000' ? 0 : 1;   # 0000 means it's a new one we're saving; otherwise it's an existing one we're updating.
	my %limits = ( max_val_length => 50000, max_css_val_length => 100000, max_name_length => 300 );
	my $error = '';

	if(!user_is_allowed_to('do_app_administration'))
	{
		$error = "Access Denied";
	}
	elsif(length($prefnum) > 4   ||   !is_numeric($prefnum))
	{
		$error = "error=Couldn't save pref: invalid prefnum value ('$prefnum').";
	}
	elsif(length($prefname) > $limits{max_name_length}   ||   $prefname !~ /^[0-9a-zA-Z_-]+$/)
	{
		$error = "Invalid prefname; use only letters, numbers, underscores and dashes, $limits{max_name_length} characters max.";
	}
	elsif($prefname eq 'css' && length($prefvalue) > $limits{max_css_val_length})
	{
		$error = "Invalid pref value; cannot exceed $limits{max_css_val_length} characters.";
	}
	elsif($prefname ne 'css' && length($prefvalue) > $limits{max_val_length})
	{
		$error = "Invalid pref value; cannot exceed $limits{max_val_length} characters.";
	}
	elsif($prefname eq 'integrate_with_userbase')
	{
		load_userbase_prefs('force');
		my ($db_connect_success,$errmsg) = get_db_connection();
		if(!   ($db_connect_success && userbase_user_table_exists())   )
		{
			$error = $db_connect_success ? "UserBase user table [ $PREF{user_table} ] is missing; cannot enable." : $errmsg;
		}
	}

	my ($success,$msg) = (0,'');
	if($error)
	{
		$error =~ s!\n!::NEWLINE::!g;   # added 20160423, only for the $errmsg from get_db_connection() above, and possibly not even needed for that?
		$success = 0; $msg = $error;
	}
	else
	{
		$prefvalue =~ s!:::wcfg-start-txtarea-dontchange:::!<textarea!g;
		$prefvalue =~ s!:::wcfg-end-txtarea-dontchange:::!</textarea>!g;

		if(! exists $WEBCFG{$prefname}{val})
		{
			my $empty = ! scalar keys %WEBCFG;
			my $separator = $empty ? "::-::" : "\n::-::";
			add_text_to_file("$separator$preftype-$prefname = $prefvalue", $PREF{webconfig_file}, 'end');
			$success = 1; $msg = 'Saved!';
		}
		elsif($overwrite)
		{
			my $contents = cat($PREF{webconfig_file});
			my $separator = "::-::";
			$contents =~ s!$separator$preftype-$prefname = .*?(\n$separator|$)!$separator$preftype-$prefname = $prefvalue$1!sg;
			add_text_to_file($contents, $PREF{webconfig_file}, 'clobber');
			$success = 1; $msg = 'Updated!';
		}
		else
		{
			$success = 0; $msg = "Pref '$prefname' already exists in WebConfig!";
		}
	}

	if($prefname eq 'admin_password_hash_01' && $success)
	{
		# If we just changed admin_password_hash_01, then we most likely just kicked the user out, since
		# that's probably what he was logged in with.  But the page won't have reloaded/redirected, and
		# any more attempts to update prefs will result in Access Denied errors, with no explanation.  To
		# avoid that, let's just update his login cookie with the new hash:

		my $hashed_pw_base = ($prefvalue =~ /^(.+)v.+/)[0];
		my $expiry = $PREF{num_days_login_lasts} =~ /^(\d+)$/ ? $1 : 1;
		set_encauth_login_cookie($hashed_pw_base, "+${expiry}d");
	}

	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	print "setpref_success=${success}:::::prefnum=${prefnum}:::::msg=${msg}";
	print qq`</data>\n\n`;
	exit;
}


sub save_new_webconfig_pref
{
	my $name = shift;
	my $value = shift;
	my $type = shift || 'PREF';
	my $empty = ! scalar keys %WEBCFG;
	my $separator = $empty ? "::-::" : "\n::-::";
	add_text_to_file("$separator$type-$name = $value", $PREF{webconfig_file}, 'end');
}


# For logging infrequent events (app installation, first admin created, etc) in
# a log (the webconfig file) that we'll never purge.
#
sub applog
{
	my $event = shift;
	my $date = shift || date14();
	my $empty = ! scalar keys %WEBCFG;
	my $separator = $empty ? "::-::" : "\n::-::";
	add_text_to_file("${separator}applog_$date = $event", $PREF{webconfig_file}, 'end');
}


# For logging more frequent/recurring events (e.g. delivery of notification emails)
# that we'll mostly want to purge after a while. Pass { 'purge_datestamp' => 0 } to
# log an item and never purge it.  If unspecified, purge will be set to 1 year.
#
sub eventlog($)
{
	my $optsref = shift; my %data = %$optsref;
	if(!exists $data{datestamp})
	{
		$data{datestamp} = offsettime();
		$data{date} = date14($data{datestamp});
	}
	if(!exists $data{purge_datestamp})
	{
		$data{purge_datestamp} = offsettime() + 60*60*24*365;
		$data{purge_date} = date14($data{purge_datestamp});
	}

	sql_untaint($data{event}, $data{data1}, $data{data2}, $data{data3}, $data{more_details});
	enc_sql_insert("INSERT INTO `$PREF{eventlog_table}` 
		(date,datestamp,purge_date,purge_datestamp,event,data1,data2,data3,more_details)
		VALUES('$data{date}', datestamp, '$data{purge_date}', purge_datestamp, '$data{event}', '$data{data1}', '$data{data2}', '$data{data3}', '$data{more_details}')
	");
}


sub do_webconfig
{
	exit_with_needprivs() unless user_is_allowed_to('do_app_administration');

	my $which = get_qs_var({ var=>'which',  maxlength=>10,  allowedchars=>'\w' });

	start_html_output("WebConfig");

	print qq`
	<div id="webconfig_page">
		<div id="webconfig_buttons">
			<a href="$PREF{here_qsready}action=webconfig">Common Prefs</a>
			<a href="$PREF{here_qsready}action=webconfig&amp;which=wc">Your Prefs</a>
			<a href="$PREF{here_qsready}action=webconfig&amp;which=all">All Prefs</a>
			<a href="#" onclick="toggle_display_flip('webconfig_instr'); return false">Help...</a>
		</div>
		<div id="webconfig_instr">
			<p class="webconfig_intro">Use this page to configure $PREF{internal_appname_nice}'s settings, known as preferences.&nbsp; 
			WebConfig has three views: the most 
			<a href="$PREF{here_qsready}action=webconfig">commonly-adjusted prefs</a>, or 
			<a href="$PREF{here_qsready}action=webconfig&amp;which=wc">all the prefs currently in your WebConfig file</a>, or the
			<a href="$PREF{here_qsready}action=webconfig&amp;which=all">full $PREF{internal_appname_nice} prefs file</a>
			including documentation.&nbsp; Whichever view you use, all your WebConfig adjustments will be stored in the
			$PREF{script_basename}_webconfig_prefs.cgi file (in your /cgi-bin/encdata/$PREF{internal_appname}/
			directory by default), so you can easily <a href="$ENV{SCRIPT_NAME}?action=downloadwebconfig">back up</a>
			your configuration.
			</p>

			<p class="webconfig_intro">
			Alternatively, you can edit your prefs files directly ($PREF{internal_appname}_prefs.cgi
			and $PREF{internal_appname}_prefs_extra.cgi), or you can edit those files <em>and</em> use
			WebConfig, but it's easiest to just use WebConfig.&nbsp; And the WebConfig value will
			always override the prefs-file value, if a given pref is set in both places.
			</p>

			<p class="webconfig_intro">
			<strong>Important note</strong> about the <a href="$PREF{here_qsready}action=webconfig&amp;which=all">All Prefs</a> page: you can adjust and update
			settings on the All Prefs page; but after you adjust a setting, if you want to adjust that
			same setting again, you should go to the Your Prefs page to do it.&nbsp; That's because
			the All Prefs page is designed to show settings exactly as they appear in the prefs
			file on the server.&nbsp; You'll see your changes after hitting the Update button, but
			if you reload the page, they'll appear to be lost &mdash; but they aren't lost; you just
			need to go to the <a href="$PREF{here_qsready}action=webconfig&amp;which=wc">Your Prefs</a> page to see them.
			</p>
		</div>
	`;


	print qq`<form name="enc_webconfig" id="enc_webconfig" method="get" action="#">\n`;

	my $newprefname = get_qs_var({ var=>'n1', maxlength=>300, allowedchars=>'\w\.-' });
	my $newprefval  = get_qs_var({ var=>'v1',  maxlength=>800, allowedchars=>'\w\. #:; \{\} \(\) \n\t -' });
	my $newprefform = qq`<div class="webconfig_pref_new">
			<p class="webconfig_title">Create a new webconfig pref:</p>
			<input type="text" name="prefname_0000" id="prefname_0000" class="prefname" value="$newprefname" placeholder="Name" /><input type="hidden" name="preftype_0000" id="preftype_0000" value="PREF" />
			<textarea name="prefvalue_0000" id="prefvalue_0000" class="prefvalue" placeholder="Value">$newprefval</textarea>
			<input type="button" name="prefsavebtn_0000" id="prefsavebtn_0000" class="prefsavebtn" value="Save" onclick="save_webconfig_pref('0000')" /><div id="prefresult_0000" class="prefresult"></div>
			</div>
	`;

	my $prev_pref = '';
	if($qs =~ /createsingle=yes/)
	{
		print $newprefform;
	}
	elsif($qs =~ /editsingle=(\w{1,300})/)
	{
		my $name = $1;
		my $type = exists $TEXT{$name} ? 'TEXT' : 'PREF';
		my $val  = exists $TEXT{$name} ? $TEXT{$name} : $PREF{$name};
		print get_webconfig_pref_form({ prefname=>$name, preftype=>$type, prefval=>$val, i=>1, stacked=>1, medium=>1 });
	}
	elsif($which eq 'wc')
	{
		print $newprefform;

		my $i = 1;
		foreach my $pref (sort keys %WEBCFG)
		{
			next if $pref =~ /^(dismissed_admin_alerts|site_salt)$/;
			next if $QS{filter} && $pref !~ /$QS{filter}/i;
			# In 'wc' mode, use the raw value ($WEBCFG{$pref}{raw}), so prefs containing e.g. $ENV{SCRIPT_NAME} will keep that var itself when stored,
			# rather than having its value interpolated in.  We want to store the var, and only do the interpolation at loadtime/runtime.
			print get_webconfig_pref_form({ prefname=>$pref, preftype=>$WEBCFG{$pref}{type}, prefval=>$WEBCFG{$pref}{raw}, i=>$i, stacked=>1, medium=>1, prev_pref=>$prev_pref });
			$prev_pref = $pref;
			$i++;
		}
	}
	elsif($which eq 'all')
	{
		print $newprefform;

		# First get the values from any active prefs_extra file:
		#
		my %prefs_extra_values = ();
		if(my $prefs_extra_file = ($PREF{loaded_prefs_files} =~ /(\w+_prefs_extra\.\w+)/)[0])
		{
			my $allprefs = cat($prefs_extra_file);
			my $i = 0;
			my $in_a_multiline_pref = 0;
			my $multiline_pref_type = '';
			my $multiline_pref_name = '';
			my $multiline_pref_value = '';
			foreach my $line (split(/\n/, $allprefs))
			{
				if($in_a_multiline_pref)
				{
					if($line =~ /(.*)`/)
					{
						$multiline_pref_value .= $1;
						$in_a_multiline_pref = 0;
						$prefs_extra_values{$multiline_pref_name} = $multiline_pref_value;
					}
					else
					{
						$multiline_pref_value .= "$line\n";
					}
				}
				elsif($line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*(-?\d+|\$[\w\{\}]+)\s*;(.*)/)
				{
					$i++;
					my ($preftype, $prefname, $prefval_from_prefsfile, $note) = ($1, $2, $3, $4);
					$prefs_extra_values{$prefname} = $prefval_from_prefsfile;
				}
				elsif($line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*(['"])(.*?)\3\s*;(.*)/)
				{
					$i++;
					my ($preftype, $prefname, $prefval_from_prefsfile, $note) = ($1, $2, $4, $5);
					$prefs_extra_values{$prefname} = $prefval_from_prefsfile;
				}
				elsif($line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*qq`(.*?)`\s*;(.*)/)
				{
					$i++;
					my ($preftype, $prefname, $prefval_from_prefsfile, $note) = ($1, $2, $3, $4);
					$prefs_extra_values{$prefname} = $prefval_from_prefsfile;
				}
				elsif($line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*qq`(.*)/   &&   $3 !~ /`/)
				{
					$i++;
					$in_a_multiline_pref = 1;
					$multiline_pref_type = $1;
					$multiline_pref_name = $2;
					$multiline_pref_value = "$3\n";
				}
				else
				{
					# else it's a comment, which we don't care about here from the prefs_extra file.
				}
			}
		}

		# Then load the main prefs file, which is the one we'll display because it has all the documentation:
		#
		my $firstprefsfile = (split(/,/, $PREF{loaded_prefs_files}))[0];
		my $allprefs = cat($firstprefsfile);
		my $i = 0;
		my $in_a_multiline_pref = 0;
		my $multiline_pref_type = '';
		my $multiline_pref_name = '';
		my $multiline_pref_value = '';
		my %section_titles = ();
		foreach my $line (split(/\n/, $allprefs))
		{
			if($in_a_multiline_pref)
			{
				if($line =~ /(.*)`/)
				{
					$multiline_pref_value .= $1;
					$in_a_multiline_pref = 0;
					my $prefval = exists $prefs_extra_values{$multiline_pref_name} ? $prefs_extra_values{$multiline_pref_name} : $multiline_pref_value;
					print get_webconfig_pref_form({ preftype=>$multiline_pref_type, prefname=>$multiline_pref_name, prefval=>$multiline_pref_value, i=>$i, prev_pref=>$prev_pref });
					$prev_pref = $multiline_pref_name;
				}
				else
				{
					$multiline_pref_value .= "$line\n";
				}
			}
			elsif($line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*(-?\d+|\$[\w\{\}]+)\s*;(.*)/
			 ||   $line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*qq`(.*?)`\s*;(.*)/
			 ||   $line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*'(.*?)'\s*;(.*)/
			 ||   $line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*"(.*?)"\s*;(.*)/
			)
			{
				$i++;
				my ($preftype, $prefname, $prefval_from_prefsfile, $note) = ($1, $2, $3, $4);
				$note =~ s!^\s*#\s*!!;
				my $prefval = exists $prefs_extra_values{$prefname} ? $prefs_extra_values{$prefname} : $prefval_from_prefsfile;
				my $nameclass = $prefname =~ /^groups_allowed_to_/ ? 'prefname_fixed_wide' : '';
				print get_webconfig_pref_form({ preftype=>$preftype, prefname=>$prefname, prefval=>$prefval, i=>$i, inline_note=>$note, prev_pref=>$prev_pref, nameclass=>$nameclass });
				$prev_pref = $prefname;
			}
			elsif($line =~ /^\$(PREF|TEXT){(\w+)}\s*=\s*qq`(.*)/   &&   $3 !~ /`/)
			{
				$i++;
				$in_a_multiline_pref = 1;
				$multiline_pref_type = $1;
				$multiline_pref_name = $2;
				$multiline_pref_value = "$3\n";
			}
			else
			{
				# else it's a comment.

				# make angle-brackets show up properly:
				$line =~ s!<!&lt;!g;
				$line =~ s!>!&gt;!g;

				# make links clickable:
				$line =~ s!(https?://encodable.com(\S+))!<a href="$1" target="_blank">$1</a>!g;

				if($line =~ /^# (PREFs Section (\d\d|[A-Z]): ([\w\. -]+))/)
				{
					my $title = $1;
					my $section_num = $2;
					my $short_title = "PREFs_Section_$section_num";
					if(! exists $section_titles{$short_title})
					{
						# first time we're seeing this title, so we're in the Table of Contents at the top.
						print qq`<br /><a href="#$short_title" class="wcfg_toc_link">$title</a>\n`;
						$section_titles{$short_title} = 1;
					}
					elsif($section_titles{$short_title} == 1)
					{
						# second time we're seeing this title, so it's the start of the actual section itself.
						print qq`<br /><a name="$short_title" class="wcfg_section_anchor">$title</a>\n`;
						$section_titles{$short_title} = 'done';
					}
					else
					{
						print qq`<br /><span class="comment wcfg_section_title">$title (cont'd)</span>\n`;
					}
				}
				elsif($line =~ /^#{30}/)
				{
					print "<br /><hr />\n";
				}
				elsif($line =~ /^#\s*$/)
				{
					print "<br />\n";
				}
				elsif($line =~ /^#(\s*)(\S.*)/)
				{
					my ($space,$comment) = ($1,$2);
					$space =~ s!\t!&nbsp; &nbsp; &nbsp;!g;
					print qq`<br /><span class="comment">$space$comment</span>\n`;
				}
				else
				{
					print "<br />$line\n";
				}
			}
		}
	}
	else
	{
		# By default, just show the most commonly-adjusted prefs:

		print $newprefform;

		print qq`<div id="webconfig_common_list">\n`;
		my $i = 1;
		my $prev_pref = '';

		if($PREF{internal_appname} eq 'filechucker')
		{
			for('title', 'minimum_access_level', 'here', 'integrate_with_userbase', 'enable_userdirs', 'webmaster_email_address', 'app_email_address',
				'email_notifications_to_webmaster', 'email_notifications_to_userEntered_addresses',
				'show_the_create_new_subdir_field_on_upload_form', 'display_dropdown_box_for_subdir_selection',
				'store_upload_info_in_database', 'only_allow_these_file_extensions',
				'max_files_allowed_per_upload', 'sizelimit_for_public', 'sizelimit_for_members', 'sizelimit_for_admins',
				'max_file_size_for_public', 'max_file_size_for_members', 'max_file_size_for_admins'
			)
			{
				print get_webconfig_pref_form({ preftype=>'PREF', i=>$i++, prefname=>$_, prefval=>$PREF{$_}, prev_pref=>$prev_pref });
				$prev_pref = $_;
			}
		}
		elsif($PREF{internal_appname} eq 'userbase')
		{
			for('title', 'title_text', 'login_url', 'time_offset', 'webmaster_email_address', 'app_email_address',
				'visitors_can_sign_up_for_their_own_accounts', 'require_email_verification_for_new_signups', 'require_admin_approval_for_new_signups',
				'send_welcome_email_when_user_completes_signup', 'send_welcome_email_when_admin_creates_an_account', 'send_welcome_email_to_accounts_created_via_csv_import',
				'join_paid_group_payment_recipient', 'min_password_length', 'use_builtin_realname_field', 'use_builtin_email_field', 'usernames_must_be_email_addresses',
				'on_member_login_redirect_to', 'on_member_logout_redirect_to', 'always_redirect_members_to', 'create_filechucker_userdir_on_account_creation'
			)
			{
				print get_webconfig_pref_form({ preftype=>'PREF', i=>$i++, prefname=>$_, prefval=>$PREF{$_}, prev_pref=>$prev_pref });
				$prev_pref = $_;
			}
		}
		elsif($PREF{internal_appname} eq 'mailylist')
		{
			for('title', 'here', 'integrate_with_userbase', 'webmaster_email_address', 'app_email_address',
				'time_offset', 'use_builtin_subscriber_list'
			)
			{
				print get_webconfig_pref_form({ preftype=>'PREF', i=>$i++, prefname=>$_, prefval=>$PREF{$_}, prev_pref=>$prev_pref });
				$prev_pref = $_;
			}
		}
		elsif($PREF{internal_appname} eq 'cornerstore')
		{
			for('title', 'here', 'integrate_with_userbase', 'webmaster_email_address', 'app_email_address',
				'paypal_payment_recipient_address', 'time_offset', 'number_of_per_item_options_available',
				'enable_categories'
			)
			{
				print get_webconfig_pref_form({ preftype=>'PREF', i=>$i++, prefname=>$_, prefval=>$PREF{$_}, prev_pref=>$prev_pref });
				$prev_pref = $_;
			}
		}
		elsif($PREF{internal_appname} eq 'visitorlog')
		{
			for('title', 'time_offset', 'visitor_count_startdate', 'visitor_count_offset',
				'integrate_with_userbase', 'admin_password_hash_01', 
				'groups_allowed_to_view_livelog', 'groups_allowed_to_view_stats_page', 'here', 'livelog_url_short', 'stats_url_short'
			)
			{
				print get_webconfig_pref_form({ preftype=>'PREF', i=>$i++, prefname=>$_, prefval=>$PREF{$_}, prev_pref=>$prev_pref });
				$prev_pref = $_;
			}
		}

		print "</div>\n";
	}

	print qq`</form>\n</div>\n`;
	finish_html_output();
}


sub get_webconfig_pref_form
{
	my $optsref = shift; my %opts = %$optsref;
	my $i = $opts{i};
	my $j = $i < 10 ? "000$i" : $i < 100 ? "00$i" : $i < 1000 ? "0$i" : $i;
	my $sizeclass = length($opts{prefval}) < 20 ? 'wcfg_shorttextbox' : length($opts{prefval}) < 200 ? 'wcfg_mediumtextbox' : 'wcfg_largetextbox';
	$sizeclass = 'wcfg_shorttextbox' if $opts{short};
	$sizeclass = 'wcfg_mediumtextbox' if $opts{medium};
	$sizeclass = 'wcfg_largetextbox' if $opts{large};
	my $separator = '<br />' unless $opts{short} || $sizeclass =~ /short/i;
	my $nameclass = $opts{nameclass} ? $opts{nameclass} : length($opts{prefname}) > 50 ? 'prefname_extrawide' : length($opts{prefname}) > 38 ? 'prefname_wide' : 'prefname_short';
	my $note = $opts{note} || get_webconfig_pref_note($opts{prefname}, $opts{prefval}, "prefvalue_$j", $opts{prev_pref});
	my $inline_note = $opts{inline_note};
	$opts{dropdown} = get_webconfig_dropdown_list($opts{prefname});
	my $output = '';

	# Otherwise any values containing a textarea will break the webconfig form itself:
	$opts{prefval} =~ s!<textarea!:::wcfg-start-txtarea-dontchange:::!g;
	$opts{prefval} =~ s!</textarea>!:::wcfg-end-txtarea-dontchange:::!g;

	if($opts{stacked})
	{
		$note = qq`<span class="prefnote prefnote_stacked">$note</span>` if $note;

		$output .= qq`<div class="webconfig_pref webconfig_pref_stacked">
				<p class="webconfig_title"></p>
				$note
				\$${opts{preftype}}{<span class="prefname_label">$opts{prefname}</span>} = 
				<input type="hidden" name="prefname_$j" id="prefname_$j" value="$opts{prefname}" />
				<input type="hidden" name="preftype_$j" id="preftype_$j" value="$opts{preftype}" />
		`;

		if($opts{prefval} =~ /^(yes|no)$/ && $PREF{disable_toggle_mode_for_these_webconfig_prefs} !~ /(?:^|,)$opts{prefname}(?:,|$)/)
		{
			$output .= qq`
				<select name="prefvalue_$j" id="prefvalue_$j" class="prefvalue yesno" onchange="save_webconfig_pref('$j')">
				<option` . ($opts{prefval} eq 'yes' ? ' selected="selected"' : '') . qq`>yes</option>
				<option` . ($opts{prefval} eq 'no'  ? ' selected="selected"' : '') . qq`>no</option>
				</select>
			`;
		}
		else
		{
			$output .= qq`
				<br /><textarea name="prefvalue_$j" id="prefvalue_$j" class="prefvalue $sizeclass" onchange="show_webconfig_not_saved_msg('prefresult_$j')" onkeyup="show_webconfig_not_saved_msg('prefresult_$j')">$opts{prefval}</textarea>
				<br /><input type="button" name="prefsavebtn_$j" id="prefsavebtn_$j" class="prefsavebtn" value="Update" onclick="save_webconfig_pref('$j')" />
			`;
		}

		$output .= qq`
			<div id="prefresult_$j" class="prefresult"></div>
			</div>
		`;
	}
	else
	{
		$inline_note = qq`<span class="prefnote prefnote_inline">$inline_note</span>` if $inline_note;
		$note = qq`<div class="prefnote">$note</div>` if $note;

		$output .= qq`
			<div class="webconfig_pref">
			$note
			<input type="hidden" name="prefname_$j" id="prefname_$j" value="$opts{prefname}" />
			<input type="hidden" name="preftype_$j" id="preftype_$j" value="$opts{preftype}" /><span
			 class="prefname_visible $nameclass">\$${opts{preftype}}{<span class="prefname_label">$opts{prefname}</span>} = </span>
		`;

		if($opts{prefval} =~ /^(yes|no)$/ && $PREF{disable_toggle_mode_for_these_webconfig_prefs} !~ /(?:^|,)$opts{prefname}(?:,|$)/)
		{
			$output .= qq`
				$separator
				<select name="prefvalue_$j" id="prefvalue_$j" class="prefvalue yesno" onchange="save_webconfig_pref('$j')">
				<option` . ($opts{prefval} eq 'yes' ? ' selected="selected"' : '') . qq`>yes</option>
				<option` . ($opts{prefval} eq 'no'  ? ' selected="selected"' : '') . qq`>no</option>
				</select>
			`;
		}
		elsif($opts{dropdown} && $PREF{disable_toggle_mode_for_these_webconfig_prefs} !~ /(?:^|,)$opts{prefname}(?:,|$)/)
		{
			$output .= qq`<select name="prefvalue_$j" id="prefvalue_$j" class="prefvalue" onchange="save_webconfig_pref('$j')">\n`;
			foreach my $option (split(/\|\|\|/, $opts{dropdown}))
			{
				$output .= qq`<option` . ($opts{prefval} eq $option ? ' selected="selected"' : '') . qq`>$option</option>\n`;
			}
			$output .= qq`</select>\n`;
		}
		else
		{
			$output .= qq`
				$separator<textarea name="prefvalue_$j" id="prefvalue_$j" class="prefvalue $sizeclass" onchange="show_webconfig_not_saved_msg('prefresult_$j')"
				  onkeyup="show_webconfig_not_saved_msg('prefresult_$j')">$opts{prefval}</textarea>
				<input type="button" name="prefsavebtn_$j" id="prefsavebtn_$j" class="prefsavebtn" value="Update" onclick="save_webconfig_pref('$j')" />
			`;
		}

		$output .= qq`
			<div id="prefresult_$j" class="prefresult"></div>
			$inline_note
			</div>
		`;
	}

	return $output;
}


sub get_webconfig_pref_note
{
	my ($prefname, $prefvalue, $field_css_id, $prev_pref) = @_;
	my $note = '';
	if($prefname =~ /database_name|store_upload_info_in_database/)
	{
		my $arg = $PREF{internal_appname} eq 'userbase' && !$PREF{login_is_via_encauth} ? 'ubdbsetup' : 'dbsetup';
		$note = qq`See the <a href="$PREF{here_qsready}action=$arg">database settings manager</a>.`;
	}
	elsif($prefname eq 'title'   &&   $PREF{internal_appname} eq 'filechucker')
	{
		$note = qq`For a text title, do this: <br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1 id="fctitle"&gt;Title Here&lt;/h1&gt; <br />Or replace "Title Here" with an &lt;img&gt; tag to use an image.`;
	}
	elsif($prefname eq 'title'   &&   $PREF{internal_appname} eq 'userbase')
	{
		$note = qq`Can optionally include HTML.`;
	}
	elsif($prefname =~ /_password_hash_\d+$/)
	{
		$note = qq`To change a password, <a href="#" onclick="show_pw_hash_popup('$field_css_id'); return false">create a new hash</a>.`;
		$note .= qq`&nbsp; (Note: in UserBase, this password is only used during the initial app installation, or if you need to change your database connection details.&nbsp; Use the <a href="$PREF{here_qsready}action=showusers">Manage Users page</a> to change your account passwords.)` if $PREF{internal_appname} eq 'userbase';
	}
	elsif($prefname eq 'site_salt')
	{
		$note = qq`Don't change site_salt, otherwise you'll be logged out automatically, and you'll need to reset all your password hashes, the first of which (admin_password_hash_01) will need to be reset manually, by creating the hash <a href="$PREF{here_qsready}newpw">here</a> and then putting it into one of your prefs files via FTP/SSH ($PREF{internal_appname}_prefs.cgi, $PREF{internal_appname}_prefs_extra.cgi, or $PREF{script_basename}_webconfig_prefs.cgi).`;
	}
	elsif($prefname =~ /^groups_allowed_to_/ && $prev_pref !~ /^groups_allowed_to_/)
	{
		$note = qq`Can be public, member, or admin; can also include any of your custom <a href="http://encodable.com/userbase/" target="_blank">UserBase</a> groups`;
		$note .= qq` (if you're using UserBase)` unless $PREF{internal_appname} eq 'userbase';
		$note .= qq`; and can include multiple groups separated by commas (but in most cases should be just a single group).&nbsp; Remember that public includes member and admin (because members and admins are also part of the public), and member includes admin (because admins are also members).`;
	}
	elsif($prefname eq 'minimum_access_level')
	{
		$note = qq`Can be public, member, or admin; this overrides all the "groups_allowed_to_" settings that have a lower value (e.g. setting this to member changes all public settings to member, but does not change admin settings to member).`;
	}
	elsif($prefname eq 'integrate_with_userbase')
	{
		$note = qq`Changing this setting may automatically log you out.&nbsp; If you want to enable it, you should first install <a href="http://encodable.com/userbase/" target="_blank">UserBase</a> and log into it with an admin account.&nbsp; Then <a href="$PREF{here_qsready}action=dbsetup">enter your DB details into $PREF{internal_appname_nice}</a>.&nbsp; Then enable this setting.`;
	}
	elsif($prefname eq 'enable_userdirs')
	{
		$note = qq`Puts each user's uploads into his own private subfolder, and prevents each user from seeing any subfolders besides his own.&nbsp; This requires a login system like <a href="http://encodable.com/userbase/" target="_blank">UserBase</a>.`;
	}
	elsif($prefname eq 'sizelimit_for_public')
	{
		$note = qq`The sizelimit and max_file_size settings are all in bytes.`;
	}
	elsif($prefname eq 'only_allow_these_file_extensions')
	{
		$note = qq`Separate them by spaces, and include the dots, e.g.: &nbsp; .jpg .png .gif`;
	}
	elsif($prefname eq 'webmaster_email_address')
	{
		$note = qq`Use the <a href="$PREF{here_qsready}do_email_test">$TEXT{Test_Email_Setup}</a> page to enter your email server details.`;
	}
	elsif($prefname eq 'join_paid_group_payment_recipient')
	{
		$note = qq`If you want to offer <a href="$PREF{here_qsready}action=groups">paid accounts</a>, enter your PayPal email address here.`;
	}
	elsif($prefname eq 'login_url')
	{
		$note = qq`If <a href="/login/">this link works</a> (shows the login/Account Center page) then you can set this to /login/ so that your URLs are nice and short`;
	}
	elsif($prefname eq 'here')
	{
		if($PREF{internal_appname} eq 'filechucker')
		{
			$note = qq`If <a href="/upload/">this link works</a> (shows the upload page) then you can set this to /upload/ so that your URLs are nice and short`;
		}
		elsif($PREF{internal_appname} eq 'cornerstore')
		{
			$note = qq`If <a href="/store/">this link works</a> (shows the store front page) then you can set this to /store/ so that your URLs are nice and short`;
		}
		elsif($PREF{internal_appname} eq 'visitorlog')
		{
			$note = qq`If <a href="/visitors/">this link works</a> (shows the VisitorLog page) then you can set this to /visitors/ so that your URLs are nice and short`;
		}
	}
	elsif($prefname eq 'min_password_length')
	{
		$note = qq`Anything less than 10 is highly insecure.`;
	}
	elsif($prefname eq 'time_offset')
	{
		$note = qq`In case your server is in a different time zone than you are, you can set this to the number of hours to adjust it by (can be negative).&nbsp; The current server date/time is <br />` . date19(time) . qq` and the offset-adjusted date/time is <br />` . date19() . '.';
	}
	elsif($prefname eq 'on_member_login_redirect_to')
	{
		$note = qq`Instead of <a href="http://encodable.com/userbase/faq/#redirection" target="_blank">the default behavior</a>, you can force-redirect members to a specific URL.`;
	}
	elsif($prefname eq 'create_filechucker_userdir_on_account_creation')
	{
		$note = qq`If you're using <a href="http://encodable.com/filechucker/" target="_blank">FileChucker</a> with the private-userdirs feature, those userdirs will be created automatically when each user visits FileChucker.&nbsp; Or you can enable this, to auto-create the folders at the time of account creation.`;
	}
	elsif($prefname =~ 'protected_directory_\d+_ignore_file_extensions')
	{
		$note = qq`This setting lets you use whatever file extensions you want to on your protected URLs, and UserBase will simply ignore the extensions and use the base filename to figure out which actual file/page on your server to display.`;
	}
	elsif($prefname =~ 'protected_directory_\d+_filetypes_to_parse')
	{
		$note = qq`This setting will let UserBase insert variables into pages of the specified file types (e.g. if you put \$PREF{logged_in_username} within your page, UserBase will replace that with the username of the logged-in user).  If you aren't going to put any such variables into your pages anyway, then you can set this to null, which may give a slight performance boost.  Of course don't put any non-text types into this setting in any case (e.g. jpg, zip, etc).`;
	}
	elsif($prefname =~ 'protected_directory_\d+_index_filename')
	{
		$note = qq`When someone visits the protected directory URL without a filename, UserBase will display this page.`;
	}
	elsif($prefname =~ 'protected_directory_\d+')
	{
		$note = qq`In most cases you shouldn't adjust this setting here; instead, <a href="$PREF{here_qsready}action=dirlock">go to DirLock</a> to lock/unlock your pages.`;
	}
	elsif($prefname eq 'visitor_count_startdate')
	{
		$note = qq`For display purposes only; can be in any format you like.`;
	}
	elsif($prefname eq 'visitor_count_offset')
	{
		$note = qq`In case you're switching from a different logging system, you can set this to your previous visitor count, to make VisitorLog start there.`;
	}
	elsif($prefname eq 'livelog_url_short')
	{
		$note = qq`If <a href="/visitors/livelog/">this link works</a> (shows the LiveLog page) then you can set this to /visitors/livelog/ so that your URLs are nice and short`;
	}
	elsif($prefname eq 'stats_url_short')
	{
		$note = qq`If <a href="/visitors/stats/">this link works</a> (shows the Stats page) then you can set this to /visitors/stats/ so that your URLs are nice and short`;
	}
	return $note;
}


sub get_webconfig_dropdown_list($)
{
	my $prefname = shift;
	if($prefname eq 'default_app_style')
	{
		return 'light|||dark';
	}
	return undef;
}


sub show_server_info
{
	exit_with_needprivs() unless user_is_allowed_to('do_app_administration');

	start_html_output($TEXT{Server_Information});

	eval { require MIME::Lite; }; my $mimeliteversion = $@ ? qq`not installed` : $MIME::Lite::VERSION;

	my $old_cgi_text = $PREF{internal_appname} =~ /filechucker/i ? 'uploads' : 'some features';

	my $top_output = `top -b -n 1 |head -n 5`;
	my $uptime_output = `uptime`;
	my $uname_output = `uname -a`;
	if($top_output || $uptime_output || $uname_output)
	{
		$top_output	= "<tr><td>Top</td><td><pre>$top_output</pre></td></tr>" if $top_output;
		$uptime_output	= "<tr><td>Uptime</td><td>$uptime_output</td></tr>" if $uptime_output;
		$uname_output	= "<tr><td>Uname</td><td>$uname_output</td></tr>" if $uname_output;
	}

	print	  qq`
		<div id="enc_server_info" class="enc_tbl">
		<table>
		<tr><th colspan="2">Server Information</th></tr>
		<tr><td>$PREF{internal_appname_nice} version</td><td>$version</td></tr>
		$uptime_output
		$uname_output
		$top_output
		<tr><td>\$CGI::VERSION</td>		<td>$CGI::VERSION (if v3.02 or older, $old_cgi_text probably won't work, at least not reliably)</td></tr>
		<tr><td>\$^V (Perl version)</td>	<td>$^V</td></tr>
		<tr><td>\$MIME::Lite::VERSION</td>	<td>$mimeliteversion</td></tr>
		<tr><td>\$PREF{DOCROOT}</td>		<td>$PREF{DOCROOT}</td></tr>
		<tr><td>SHA Module:</td>		<td>$MISC{SHA_note}</td></tr>
		<tr><td>Loaded modules:</td>		<td>` . (join('<br />', sort(keys %INC))) . qq`</td></tr>
		<tr><td colspan="2">Environment variables:</td></tr>
	`;

	foreach my $var (sort keys %ENV)
	{
		$ENV{$var} =~ s!<!&lt;!g;
		$ENV{$var} =~ s!>!&gt;!g;
		print qq`<tr><td>$var</td>	<td>$ENV{$var}</td></tr>\n`;
	}

	print	  qq`</table>\n</div>\n`;

	print $TEXT{enc_apps_note};

	finish_html_output();
}


sub log_admin_alert   # accepts either a single string (the msg), or a hashref (for messages with variable values that should be excluded from the hash process).
{
	my $opt = shift;
	my $msg = '';
	my $alertid = '';
	if(ref($opt) eq 'HASH')
	{
		$msg = $$opt{msg};
		$alertid = sha1_hex($msg);   # must come before we interpolate the vars, so e.g. messages with a variable number of accounts can be dismissed and remain dismissed even as the number changes.
		$msg =~ s!%%(\w+)%%!$$opt{$1}!g;
	}
	else
	{
		$msg = $opt;
		$alertid = sha1_hex($msg);
	}
	my $dismissed = $WEBCFG{dismissed_admin_alerts}{val} =~ /(^|,)$alertid(,|$)/;
	my $i = 1; $i++ while exists $MISC{admin_alerts}{$i};
	$MISC{admin_alerts}{$i}{msg} = $msg;
	$MISC{admin_alerts}{$i}{alertid} = $alertid;
	$MISC{admin_alerts}{$i}{dismissed} = $dismissed;
	$PREF{admin_alert_icon} = qq`<span id="admin_alert_icon"><img src="$PREF{app_images_url}/alert.png" alt="" /></span>` unless $dismissed;
}


sub show_admin_alerts
{
	exit_with_needprivs() unless user_is_allowed_to('do_app_administration');
	start_html_output($TEXT{Admin_Alerts});
	my ($active, $dismissed) = (0,0);
	foreach my $i (sort keys %{$MISC{admin_alerts}})
	{
		if(!$MISC{admin_alerts}{$i}{dismissed})
		{
			$active++; print qq`<p>$MISC{admin_alerts}{$i}{msg}&nbsp; (<a href="$PREF{here_qsready}action=dismissadminalert&aid=$MISC{admin_alerts}{$i}{alertid}">dismiss</a>)</p>\n`;
		}
	}
	print qq`<p>(none)</p>\n` unless $active;
	print qq`<h3 class="encsubtitles" style="margin-top: 30px;">Dismissed Admin Alerts:</h3>\n`;
	foreach my $i (sort keys %{$MISC{admin_alerts}})
	{
		if($MISC{admin_alerts}{$i}{dismissed})
		{
			$dismissed++; print qq`<p>$MISC{admin_alerts}{$i}{msg}&nbsp; (<a href="$PREF{here_qsready}action=undismissadminalert&aid=$MISC{admin_alerts}{$i}{alertid}">un-dismiss</a>)</p>\n`;
		}
	}
	print qq`<p>(none)</p>\n` unless $dismissed;
	finish_html_output();
}


sub dismiss_admin_alert($$)
{
	my $un = shift;
	my $aid = shift;   # verified as alphanumeric in the caller.
	my $dismissed_admin_alerts = $WEBCFG{dismissed_admin_alerts}{val};
	if($un)
	{
		$dismissed_admin_alerts =~ s!(^|,)$aid(,|$)!$1$2!g;
		decommaify($dismissed_admin_alerts);
	}
	else
	{
		if($dismissed_admin_alerts) { $dismissed_admin_alerts .= ",$aid"; }
		else { $dismissed_admin_alerts = $aid; }
	}
	save_webconfig_pref('dismissed_admin_alerts', $dismissed_admin_alerts);
	enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=adminalerts");
}


sub load_hashing_module()
{
	# 201405: loading the SHA module unconditionally now, since we're including
	# a version of it in our package, so it's guaranteed to always be available.

	eval { require Digest::SHA; };
	if($@)
	{
		eval { require Digest::SHA::PurePerl; };
		if($@)
		{
			die_nice(qq`Error: $@\n<br /><br />\nYou must install either the Digest::SHA Perl module, or the Digest::SHA::PurePerl Perl module.&nbsp; The latter can easily be installed by getting <a href="http://search.cpan.org/~mshelor/Digest-SHA-PurePerl-5.89/lib/Digest/SHA/PurePerl.pm">this download</a>, extracting its lib/Digest/SHA/PurePerl.pm file, and copying it to your server at cgi-bin/perlmodules/Digest/SHA/PurePerl.pm.`);
		}
		else
		{
			import Digest::SHA::PurePerl qw(sha1_hex sha256_hex sha512_hex);
			$MISC{SHA_note} = "Using Digest::SHA::PurePerl, not Digest::SHA";
		}
	}
	else
	{
		import Digest::SHA qw(sha1_hex sha256_hex sha512_hex);
		$MISC{SHA_note} = "Using Digest::SHA, not Digest::SHA::PurePerl";
	}

	# Note: the sha512* functions require a 64-bit OS; they return null on 32-bit systems.
}


sub load_json_module()
{
	eval { require JSON::XS; };
	if($@)
	{
		eval { require JSON::PP; };
		if($@)
		{
			die_nice(qq`Error: $@\n<br /><br />\nYou must install either the JSON::XS Perl module, or the JSON::PP Perl module.&nbsp; The latter can easily be installed by getting <a href="http://search.cpan.org/~makamaka/JSON-2.90/lib/JSON/backportPP.pm">this download</a>, extracting its lib directory, and copying its contents to your server at cgi-bin/perlmodules/.`);
		}
		else
		{
			import JSON::PP qw(encode_json decode_json);
			$MISC{JSON_note} = "Using JSON::PP, not JSON::XS";
		}
	}
	else
	{
		import JSON::XS qw(encode_json decode_json);
		$MISC{JSON_note} = "Using JSON::XS, not JSON::PP";
	}
}


sub store_keyed_message
{
	my $new_message = shift;
	$new_message =~ s/\n/::ENCNL::/gs;
	die_nice qq`Error: message to store is blank, in store_keyed_message.` if $new_message eq '';

	my $one_hour = 60*60;
	my $one_day = 60*60*24*1;
	my $one_week = 60*60*24*7;
	my $current_time = offsettime();
	$PREF{max_age_for_keyed_messages} = $one_day unless $PREF{max_age_for_keyed_messages} =~ /^\d+/;
	$PREF{max_age_for_keyed_messages} = $one_hour if $PREF{server_handles_ip_addresses_incorrectly} =~ /yes/i;

	my $key = generate_nonce($new_message . $current_time . $$ . $ENV{REMOTE_PORT} . $PREF{ip} . $ENV{HTTP_USER_AGENT});
	my $uid = $PREF{logged_in_userid} =~ /^-?\d+$/ ? $PREF{logged_in_userid} : 0;

	my $mfile = add_initial_cwd_prefix($PREF{datadir} . '/' . "_$PREF{internal_appname}_keyed_messages.cgi");
	create_file_if_DNE($mfile,$PREF{writable_file_perms});
	# Note: this -w test must use die rather than die_nice, because in situations such as POSTs where store_keyed_message is used, die_nice would just call store_keyed_message again, resulting in an infinite loop.
	die qq`Error: our keyed-message file ('$mfile') is not writable; you must either make it so, or else delete it so we can re-create it with the correct permissions.` unless -w $mfile;
	my @messages = ();
	open(MFILE,"+<$mfile") or die_nice("could not open file '$mfile' for R/W: $!\n");
	flock MFILE, 2;
	seek MFILE, 0, 0;
	while(<MFILE>)
	{
		if(/^(\d+):/)
		{
			my ($time) = ($1);
			push (@messages,$_) if($time > ($current_time - $PREF{max_age_for_keyed_messages}));
		}
		elsif(/^[\s\n]*$/)
		{
			push (@messages, $_);
		}
	}
	seek MFILE, 0, 0;
	print MFILE @messages;
	print MFILE "${current_time}:${key}:${uid}:$PREF{ip}:$new_message\n\n\n"; # 3 newlines so the raw log is somewhat readable.
	truncate MFILE, tell MFILE;
	close MFILE or die_nice("could not close file '$mfile' after R/W: $!\n");

	return $key;
}


sub get_keyed_message
{
	my $key = shift;
	my $pre_login_check = shift;
	my $denied = 0;
	my $message = '';

	my $mfile = add_initial_cwd_prefix($PREF{datadir} . '/' . "_$PREF{internal_appname}_keyed_messages.cgi");
	create_file_if_DNE($mfile,$PREF{writable_file_perms});
	open(MFILE,"<$mfile") or die_nice("could not open file '$mfile' for reading: $!\n");
	flock MFILE, 1;
	seek MFILE, 0, 0;
	while(<MFILE>)
	{
		if(/^\d+:${key}:(-?\d+):([\d\.]+):(.*)/)
		{
			my ($uid_on_message,$ip_on_message,$msg) = ($1,$2,$3);
			if($PREF{admin_is_logged_in})
			{
				$message = $msg;
			}
			elsif($PREF{member_is_logged_in} && $PREF{logged_in_userid} eq $uid_on_message)
			{
				$message = $msg;
			}
			elsif($PREF{ip} eq $ip_on_message   &&   $uid_on_message =~ /^(0|-1)$/) # only allow IP-based auth if the owner is public.
			{
				$message = $msg;
			}
			elsif($PREF{server_handles_ip_addresses_incorrectly} =~ /yes/i)
			{
				$message = $msg;
			}
			else
			{
				$denied = 1;
				$message = qq`Error: access denied based on userid and/or IP address.`;
			}
			last;
		}
	}
	close MFILE or die_nice("could not close file '$mfile' after reading: $!\n");
	$message =~ s/::ENCNL::/\n/gs;

	if($pre_login_check && $denied)
	{
		# If access-denied occurred before we checked if the user is logged in, then return false so the
		# app can continue execution.
		return '';
	}
	else
	{
		return $message || qq`Message expired or blank.`;
	}
}


# Never call chdir directly; always call enc_chdir instead:
sub enc_chdir($)
{
	my $dir = shift;
	$PREF{new_cwd} = $dir;
	chdir $dir or die_nice qq`Couldn't chdir to directory "$dir": $!\n`;
}


# This is necessary for cases where we've chdir()ed somewhere other than the
# $PREF{initial_cwd}, after which we want to use $PREF{datadir}, which by
# default is not in DOCROOT and contains no path -- it's relative to the
# initial working directory.
#
sub add_initial_cwd_prefix($)
{
	my $item = shift;
	if($PREF{new_cwd} ne $PREF{initial_cwd})
	{
		$item = $PREF{initial_cwd} . '/' . $item;
		condense_slashes('leave_leading_UNC', $item);
	}
	# return the input unchanged if we're still in the initial_cwd.
	return $item;
}


# pass filename to create and optionally the mode to chmod it to.
# the mode must consist of 1-4 octal digits and must NOT be quoted.
# see "perldoc -f chmod" and "man chmod".
sub create_file_if_DNE
{
	my $file = shift;
	my $mode = shift;

	return if -T $file;
	open(NEW,">$file") or die_nice "couldn't create new file $file: $!\n";
	close NEW or die "$0: couldn't close $file after creating it: $!\n";
	if($mode)
	{
		chmod($mode,$file) or die_nice "couldn't chmod file \"$file\" with mode \"$mode\": $!\n";
	}
}


sub create_dir_if_DNE
{
	my $dir = shift;
	my $mode = shift;
	my $make_parents_if_necessary = shift; $make_parents_if_necessary = $make_parents_if_necessary eq 'make_parents';
	my $ignore_errors = shift; $ignore_errors = $ignore_errors eq 'ignore_errors';

	return if -d $dir;

	$dir =~ s!\\!/!g;
	if($make_parents_if_necessary)
	{
		my $progressively_longer_path = '';
		my $i = 0;
		foreach my $individual_path_element(split(/\//, $dir))
		{
			$i++;
			if($i == 1)
			{
				if($dir =~ m!^(\w:/)!) # Winders.
				{
					$progressively_longer_path = $1;
					next;
				}
				elsif(!$individual_path_element) # this means $dir starts with a slash.
				{
					$progressively_longer_path = '/';
					next;
				}
			}

			$progressively_longer_path .= $individual_path_element;
			unless(-d $progressively_longer_path)
			{
				mkdir($progressively_longer_path,$PREF{writable_dir_perms}) or $ignore_errors || die_nice("couldn't create path-portion '$progressively_longer_path' as part of dir '$dir': $!");
				if($mode)
				{
					chmod($mode,$progressively_longer_path) or $ignore_errors || die_nice("couldn't chmod path-portion '$progressively_longer_path' as part of dir '$dir' with mode '$mode': $!");
				}
			}
			$progressively_longer_path .= '/';
		}
	}
	else
	{
		mkdir($dir,$PREF{writable_dir_perms}) or $ignore_errors || die_nice("couldn't create dir $dir: $!");
		if($mode)
		{
			chmod($mode,$dir) or $ignore_errors || die_nice("couldn't chmod dir \"$dir\" with mode \"$mode\": $!");
		}
	}

	$ignore_errors || die_nice qq`dir does not exist after creation: '$dir'` unless -d $dir;
}


sub mirror_dir_tree_and_contents($$)
{
	my ($src,$dst) = @_;
	for(@_) { return(0, qq`error: does not exist: '$_'`) unless -e $_; return(0, qq`error: not a directory: '$_'`) unless -d $_; }
	my ($files, $subfolders) = get_items($src);

	my $copy_cfps	= $PREF{internal_appname} eq 'filechucker' && $PREF{when_copying_a_folder_also_copy_its_cust_perms} =~ /yes/i;
	my $copy_aux	= $PREF{internal_appname} eq 'filechucker';

	my $i = 0;
	my %results = ();
	# start with the shortest pathname to ensure we create parents first.
	#
	foreach my $srcfolder (sort { length($a) <=> length($b) } @$subfolders)
	{
		$i++;
		$results{$i}{folder} = 1;

		my $mode = sprintf "%04o", (   (stat($srcfolder))[2] & 07777   );
		my $dstfolder = $dst . ($srcfolder =~ /^$src(.+)/)[0];
		$results{$i}{src} = $srcfolder;
		$results{$i}{dst} = $dstfolder;
		if(mkdir($dstfolder, oct($mode)))
		{
			if(chmod(oct($mode), $dstfolder))
			{
				$results{$i}{success} = "Created folder '$dstfolder' as a copy of '$srcfolder'.";
			}
			else
			{
				$results{$i}{error} = "Created folder '$dstfolder' but couldn't chmod it with mode '$mode': $!";
			}
			copy_custom_folder_perms($srcfolder, $dstfolder) if $copy_cfps;
		}
		else
		{
			$results{$i}{error} = "Couldn't create folder '$dstfolder' with mode '$mode': $!";
		}
	}

	foreach my $srcfile (@$files)
	{
		$i++;
		$results{$i}{file} = 1;

		my $mode = sprintf "%04o", (   (stat($srcfile))[2] & 07777   );
		my $dstfile = $dst . ($srcfile =~ /^$src(.+)/)[0];
		$results{$i}{src} = $srcfile;
		$results{$i}{dst} = $dstfile;
		if(copy($srcfile, $dstfile))
		{
			if(chmod(oct($mode), $dstfile))
			{
				$results{$i}{success} = "Created file '$dstfile' as a copy of '$srcfile'.";
			}
			else
			{
				$results{$i}{error} = "Created file '$dstfile' but couldn't chmod it with mode '$mode': $!";
			}

			if($copy_aux)
			{
				my($successes_aux, $errors_aux) = copy_aux_data({ srcfile_full => $srcfile, dstfile_full => $dstfile });
				if($successes_aux)
				{
					for(@$successes_aux) { $results{$i}{success} .= "<br /><br />Successfully copied aux data: $_"; }
				}
				if($errors_aux)
				{
					for(@$errors_aux) { $results{$i}{error} .= "<br /><br />Error copying aux data: $_"; }
				}
			}
		}
		else
		{
			$results{$i}{error} = "Couldn't copy source file '$srcfile' to destination file '$dstfile': $!";
		}
	}
	
	copy_custom_folder_perms($src, $dst) if $copy_cfps;

	return \%results;
}


sub send_email
{
	return;
}


sub view_sent_mail
{
	my $tableprefname	= $PREF{sent_mail_table};
	my $viewerprefname	= 'sent_mail';
	my $allowed_to_view	= user_is_allowed_to('view_sent_mail_log');
	my $allowed_to_create	= user_is_allowed_to('edit_sent_mail_log');
	my $allowed_to_edit	= user_is_allowed_to('edit_sent_mail_log');
	my $allowed_to_delete	= user_is_allowed_to('edit_sent_mail_log');

	$PREF{"${viewerprefname}_viewer_default_sort_is_reversed"}		= 1;
	$PREF{"${viewerprefname}_viewer_title"}					= 'Sent Mail';
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			= 'id, timestamp_sent, ip_address, hostname, browser, body, to, from, username_or_type';
	$PREF{"${viewerprefname}_viewer_extra_columns"}{date_sent}		= { position => 2, value => '' };
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date_sent}		= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp_sent%%));`;

	# Nothing below here should need to be edited in most cases:
	# Call get_database_data() before starting any output in case we were POSTed to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"}); print $output; finish_html_output();
}


sub enc_untaint
{
	my $item = shift || '';
	my $original_item = $item;
	my $keep_path = shift || '';
	#printd "enc_untaint($item)\n";

	# Regardless of whether we're keeping the path, dots surrounded by slashes are never allowed.
	#
	#$item =~ s!(^|/|\\)\.+(/|\\|$)!$1!g;
	$item =~ s!\\!/!g; # Need to remove MS garbage beforehand, otherwise an input like .\\StupidCGI.tmp will break this.
	while($item =~ m!((?:^|/|\\)\.+(?:/|\\|$))!)
	{
		$item =~ s!$1!/!;
	}

	#printd "removed slashdots: $item\n";

	if(  $item =~ m!(/|\\)!  &&  !$keep_path)
	{
		$item =~ s!^.*[/\\]+([^/\\]+)!$1!; # remove any path from the front.
		#printd "removed path from front: $item\n";
		$item =~ s!^([^/\\]+)[/\\]+!$1!; # ...and the back.
	}

	$item =~ s![`\*\?\|<>]!!g; # remove some other potentially-unsafe stuff.

	my $leading_UNC_slashes = '';
	if($item =~ m!^//!  &&  $keep_path)
	{
		$leading_UNC_slashes = '//';
		$item =~ s!^/+!!;
	}
	$item =~ s![/\\]{2,}!/!g; # condense any multiples.
	$item = $leading_UNC_slashes . $item; # add back any UNC slashes.

	($item) = ($item =~ /(.*)/); # untaint.

	# In case anything slips through, die as a security precaution.
	#
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m![/\\]! && !$keep_path;
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!(?:^|/|\\)\.+(?:/|\\|$)!;
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!^\.+$!;
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!^\s*$!;

	#printd "untainted: $item\n\n";
	return $item;
}


sub zeropad
{
	# args: 1. string to pad, 2. length to pad to (i.e. final length).
	enc_pad(@_, 0);
}


sub enc_pad
{
	# args: 1. string to pad, 2. length to pad to (i.e. final length), 3. char to use for padding.
	$_[0] = ($_[2] x $_[1]) . $_[0];
	$_[0] =~ s!.*(.{$_[1]})!$1!;
}


sub enc_urlencode
{
	for(@_) { s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg if $_; };
}


sub enc_urldecode
{
	# assuming the input really was URL-encoded, then any plus-signs that were originally there
	# are now in their hex form, so any plus-signs STILL there were converted from spaces by the
	# browser.  so they must be converted back BEFORE restoring any original plus-signs from the
	# hex codes.
	convert_plus_signs_back_to_spaces_in_var_from_GET_method(@_);
	for(@_) { s/%([a-fA-F\d]{2})/chr hex $1/eg  if $_; }
}


sub zeropad_return { my $string = shift; zeropad($string, @_); return $string; }
sub enc_pad_return { my $string = shift; enc_pad($string, @_); return $string; }
sub enc_urlencode_return { my $string = shift; enc_urlencode($string); return $string; }
sub enc_urldecode_return { my $string = shift; enc_urldecode($string); return $string; }


sub convert_plus_signs_back_to_spaces_in_var_from_GET_method
{
	for(@_) { s/\+/ /g  if $_; }
}


sub get_req_uri_qsready
{
	# Returns the URL+QS of the current page, ending either with '?' or '&'.
	# Optionally, pass { remove => 'varname' } to have that variable removed
	# from the returned value's QS.  And optionally pass leave_dupes=>1 if
	# you want this sub to NOT remove duplicates from the returned QS.

	my $optsref = shift; my %opts = %$optsref if $optsref;
	if($qs)
	{
		my $newqs = $qs;
		encdebug "newqs=$newqs";
		for('remove', 'remove1', 'remove2', 'remove3', 'remove4', 'remove5', 'remove6', 'remove7', 'remove8', 'remove9')
		{
			if($opts{$_})
			{
				$newqs =~ s!(^|&)$opts{$_}=[^&]*(&|$)!$1$3!g;
			}
		}
		unless($opts{leave_dupes})
		{
			my %dedupedqs = map { $_ => 1 } split(/&+/, $newqs);
			$newqs = '';
			for(keys %dedupedqs) { $newqs .= $_ . '&'; }
		}
		defooify('&', $newqs);
		$newqs =~ s!&!&amp;!g;
		encdebug "newqs=$newqs";
		return $PREF{REQ_URI_SANS_QS} . $newqs ? "?$newqs&amp;" : '?';
	}
	else
	{
		return $PREF{REQ_URI_SANS_QS} . '?';
	}
}


sub enc_redirect
{
	my $destination = shift;

	if($destination =~ /^referr?er$/i)
	{
		$destination = $ENV{HTTP_REFERER} ? $ENV{HTTP_REFERER} : $PREF{redirection_backup_address};
	}

	unless($destination =~ m!^https?://!)
	{
		$destination = $PREF{protoprefix} . $ENV{HTTP_HOST} . $destination;
	}

	my $destination_raw = $destination;
	$destination_raw =~ s!&amp;!&!g;

	if($PREF{output_started})
	{
		if($PREF{use_javascript_redirect_when_necessary} !~ /no/i)
		{
			print qq`\n<script type="text/javascript">location.href="$destination_raw";</script>\n`;
		}
		else
		{
			print qq`<p>$PREF{internal_appname} warning: cannot redirect because output has already started (perhaps debug is enabled?).&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
		}
	}
	elsif($PREF{we_are_virtual})
	{
		if($PREF{use_javascript_redirect_when_necessary} !~ /no/i)
		{
			print_http_headers({ nocache => 1, nokeepalive => 1 });
			print qq`\n<script type="text/javascript">location.href="$destination_raw";</script>\n`;
		}
		else
		{
			enc_warn "$0: enc_redirect(): cannot redirect because we are virtual.\n";
			print_http_headers({ nocache => 1, nokeepalive => 1 });
			print qq`<p>$PREF{internal_appname} warning: cannot redirect because we are virtual.&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
		}
	}
	else
	{
		if($ENV{SERVER_SOFTWARE} =~ m!microsoft-iis/5!i || $PREF{always_use_meta_for_redirects} =~ /yes/i)
		{
			# A bug in IIS v5 (and lower, probably) makes cookie-setting fail
			# when combined with a header-based redirect:
			#
			#	"BUG: Set-Cookie Is Ignored in CGI When Combined With Location"
			#	http://support.microsoft.com/kb/q176113/
			#
			# So use a meta-redirect instead.
			#
			# Update 20121119: a brain-dead caching system in IIS 7.5 (possibly others) that
			# even caches dynamic script-based output causes this to fail, so we'll now limit
			# this if() to IIS v5 specifically.
			#
			print "Content-type: text/html\n\n";
			print qq`<html><head><meta http-equiv="refresh" content="0;url=$destination"></head><body></body></html>\n`;
		}
		else
		{
			print "Location: $destination_raw\n\n";
		}
	}

	exit;
}


sub kmsg_redirect
{
	my ($msg, $extraqs) = @_;
	die_nice qq`Error: message to display is blank, in kmsg_redirect.` if $msg eq '';
	# Any $PREF{extra_debug} will be lost on redirect unless we store it with the keyed message.
	enc_redirect(   ($PREF{here_static} || $PREF{here}) . "?$PREF{twochar_app_id}kmsg=" . store_keyed_message($msg . ($PREF{extra_debug} ? get_extra_debug_output() : undef)) . $PREF{default_url_vars} . ($extraqs ? "&$extraqs" : '')   );
}


sub smsg_redirect
{
	# smsg: static message.  This only needs to be used in situations where we were
	# POSTed to and we want the static message to appear within the page we're
	# embedded into; for non-POST situations we can just use exit_with_error().
	# (And we could use a kmsg instead here, but that does involve some amount
	# of overhead, so for static messages we might as well avoid it.)
	#
	enc_redirect(   ($PREF{here_static} || $PREF{here}) . "?$PREF{twochar_app_id}smsg=$_[0]" . $PREF{default_url_vars}   );
}


sub enc_redirect_to_ref
{
	# try to redirect to HTTP_REFERER, falling back to the URL
	# specified by ?whence=foo, then to any passed-in URL, and
	# finally to $PREF{here}.

	my $go = shift;
	if($ENV{HTTP_REFERER})
	{
		$go = $ENV{HTTP_REFERER};
	}
	elsif($qs =~ /(?:^|&)whence=(.+)/)
	{
		$go = $1;
		enc_urldecode($go);
	}
	$go = $PREF{here} if !$go;
	enc_redirect($go);
}


sub get_extra_debug_output
{
	if(	$PREF{extra_debug_always} =~ /yes/i
		||
		user_is_allowed_to('view_extra_debug_output')
		||
		($PREF{extra_debug_usernames_list} && $PREF{logged_in_username} &&   ($PREF{extra_debug_usernames_list} =~ /(^|,)\s*$PREF{logged_in_username}\s*(,|$)/))
		||
		($PREF{extra_debug_ips_list} &&   ($PREF{extra_debug_ips_list} =~ /(^|,)\s*$PREF{ip}\s*(,|$)/))
	)
	{
		my $style = $PREF{extra_debug_css} || qq`margin: 20px; padding: 10px; border: 1px solid #999; background: #ddd; color: #333; text-align: left;`;
		$PREF{extra_debug} =~ s/</&lt;/g;
		$PREF{extra_debug} =~ s/>/&gt;/g;
		$PREF{extra_debug} =~ s!\n! <br />\n!g;
		my $extra_debug = qq`<div id="extradebug" style="$style">$PREF{extra_debug}</div>\n` unless !$PREF{extra_debug} && $PREF{hide_extra_debug_container_if_empty} =~ /yes/i;
		my $extra_debug_raw = qq`<div id="extradebug_raw" style="$style">$PREF{extra_debug_raw}</div>\n` if $PREF{extra_debug_raw};
		return qq`$extra_debug\n$extra_debug_raw`;
	}
}


# The tags are broken out into subs so they can be used when printing to STDERR,
# for example:   print STDERR encdebugtag() . "your debug output here";
#
sub encdebugtag   { my $caller = shift || (caller 1)[3]; $caller =~ s!^main::!!; my $tag = date14() . ": runtime " . (time - $PREF{app_start_time}) . " sec: " . ($caller ? "${caller}: " : ''); return $tag; }
sub encdebugtaghi { my $caller = shift || (caller 1)[3]; $caller =~ s!^main::!!; my $runtime = sprintf("%.2f", gettimeofday() - $PREF{script_start_time_highres}); my $tag = date14() . ": runtime $runtime sec: " . ($caller ? "${caller}: " : ''); return $tag; }


sub encdebug { my $caller = (caller 1)[3]; $PREF{extra_debug} .= encdebugtag($caller) . join("\n",@_) . "\n"; }
#
# Or for high-resolution timing, uncomment the "use Time::HiRes" line near the top of the script, and use this one:
#
sub encdebughi { my $caller = (caller 1)[3]; $PREF{extra_debug} .= encdebugtaghi($caller) . join("\n",@_) . "\n"; }


# This is mainly meant for servers without proper STDERR logging, or
# whose error-log we can't get access to.
#
sub encdebuglog
{
	if($PREF{debuglog} =~ /yes/i)
	{
		my $output = '';
		for(@_)
		{
			$output .= date14() . " pid=$$ runtime=" . (time - $PREF{app_start_time}) . "s IP=$ENV{REMOTE_ADDR} user=" . ($PREF{logged_in_username} || '(none)') . " " . (caller 1)[3] . ": $_";
			$output .= "\n" unless $_ =~ /\n$/;
		}
		if($output)
		{
			unless($PREF{debuglogfh})
			{
				open(my $outfh, ">>$PREF{debuglogfile}") or die_nice "couldn't open debug log '$PREF{debuglogfile}' for output: $!\n";
				$PREF{debuglogfh} = $outfh;
			}
			flock $PREF{debuglogfh}, 2;
			print { $PREF{debuglogfh} } $output;
			flock $PREF{debuglogfh}, 8; # release the lock.

			if($PREF{debuglog_to_stderr} =~ /yes/i) { print STDERR $output; }
		}
	}
}


sub condense_slashes
{
	s!\\!/!g;
	my $leave_leading_UNC = 0;
	for(@_)
	{
		if(/^leave_leading_UNC$/)
		{
			$leave_leading_UNC = 1;
			next;
		}
		if($leave_leading_UNC)
		{
			my $leading_UNC_slashes = '';
			if(m!^//!)
			{
				$leading_UNC_slashes = '//';
				s!^/+!!;
			}
			s!/{2,}!/!g; # condense any multiples.
			$_ = $leading_UNC_slashes . $_; # add back any UNC slashes.
		}
		else
		{
			s!/{2,}!/!g;
		}
	}
}


sub slashify	{   fooify('/', @_); }
sub deslashify	{ defooify('/', @_); }
sub commaify	{   fooify(',', @_); }
sub decommaify	{ defooify(',', @_); }
sub spaceify	{   fooify(' ', @_); }
sub despaceify	{ defooify(' ', @_); }


sub slashify_return	{ my $foo = shift; slashify($foo); return $foo; }
sub deslashify_return	{ my $foo = shift; deslashify($foo); return $foo; }
sub commaify_return	{ my $foo = shift; commaify($foo); return $foo; }
sub decommaify_return	{ my $foo = shift; decommaify($foo); return $foo; }
sub spaceify_return	{ my $foo = shift; spaceify($foo); return $foo; }
sub despaceify_return	{ my $foo = shift; despaceify($foo); return $foo; }


sub fooify
{
	# add leading and trailing foos and condense duplicates.
	my $foo = shift;
	$_ = $foo . $_ . $foo for @_;
	s!$foo{2,}!$foo!g for @_;
}


sub defooify
{
	# remove leading and trailing foos and condense duplicates.
	my $foo = shift;
	s!$foo{2,}!$foo!g for @_;
	s!^$foo!!g for @_;
	s!$foo$!!g for @_;
}


sub is_numeric
{
	return $_[0] =~ /^[0-9]+$/;
}


sub die_unless_numeric
{
	die_nice("error: non-numeric value '$_[0]' for $_[1]. [called from: " . (caller 1)[3]  . "]\n") unless $_[0] =~ /^\d+$/;
}


sub die_nice
{
	my $msg = shift;
	my $caller = shift || (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname_nice}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
	exit_with_error($msg);
}


sub die_unless_exists_and_writable($$)
{
	my $caller = (caller 1)[3];
	die_nice("Error: directory '$_[1]' does not exist ($_[0]).", $caller) unless -d $_[0];
	die_nice("Error: directory '$_[1]' is not writable ($_[0]).",$caller) unless -w $_[0];
}


sub enc_warn   # also calls encdebug for this $msg.
{
	# Never call the built-in warn() function directly, because some (lame) servers (IIS) choke
	# on it (and on printing to STDERR), and in bad ways, such as prompting the user to download
	# a file (the script output with the error message) rather than just displaying an error.
	#
	return if $^O =~ /MSWin/i;

	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname_nice}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
	encdebug $msg;
	warn $msg;
}


sub pass_child_error_to_parent($$)
{
	my ($record_id, $msg) = @_;
	my $file = $PREF{datadir} . "/ipc_log_for_child_to_parent_communcation.cgi";
	create_file_if_DNE($file, $PREF{writable_file_perms});
	$msg =~ s!\n!ENCNEWLINE!g;
	add_text_to_file("${record_id}:$msg\n", $file, 'end');
}


sub read_child_error($)
{
	my $record_id = shift;
	my $file = $PREF{datadir} . "/ipc_log_for_child_to_parent_communcation.cgi";
	create_file_if_DNE($file, $PREF{writable_file_perms});
	my $msg = '';
	my $found = 0;
	my @contents = ();
	open(my $iofh, "+<$file") or die_nice qq`couldn't open file "$file" for R/W: $!`;
	flock $iofh, 2;
	seek $iofh, 0, 0;
	while(<$iofh>)
	{
		if(/^${record_id}:(.*)$/)
		{
			$found = 1; $msg = $1; chomp $msg; $msg =~ s!ENCNEWLINE!\n!g;
		}
		else
		{
			push @contents, $_;
		}
	}
	if($found)
	{
		seek $iofh, 0, 0;
		print $iofh @contents;
		truncate $iofh, tell $iofh;
	}
	close $iofh or die_nice qq`couldn't close "$file" after R/W: $!`;

	return $msg ? (0,$msg) : (1,'');
}


sub print_http_headers
{
	return if $PREF{output_started} || $PREF{xml_output_started} || $ENV{suppress_http_headers};
	$PREF{output_started} = 1;

	my $optsref = shift; my %opts = %$optsref if $optsref;

	# Don't print the P3P header from here normally, because we'll pick it up automatically
	# from the site's main .htaccess file.  The only time a script needs to explicitly
	# include it is when setting cookies (and possibly when delivering JS code which is
	# used to set cookies?).
	# 
	#print_p3p_header();

	my $headers = '';
	$headers .= "Cache-Control: no-store, no-cache\n" if $opts{nocache} || $PREF{force_nocache_on_all_output} =~ /yes/i;
	$headers .= "Connection: close\n" if $opts{nokeepalive}; # workaround for a Safari bug that causes uploads to fail about 50% of the time.
	$headers .= "X-Frame-Options: SAMEORIGIN\n";   # prevent clickjacking
	$headers .= "X-XSS-Protection: 1; mode=block\n";   # force-enable browser-based XSS protection, including blocking (rather than sanitizing) dangerous content.
	$headers .= "X-Content-Type-Options: nosniff\n";   # prevent browsers from attempting to sniff content-types, which can lead to security issues.
	$headers .= "Content-type: text/html\n\n";
	$opts{noprint} ? return $headers : print $headers;
}


sub print_xml_headers()
{
	return if $PREF{output_started} || $PREF{xml_output_started};
	$PREF{xml_output_started} = 1;

	print "Cache-Control: no-store, no-cache\n";
	print "Connection: close\n"; # workaround for a Safari bug that causes uploads to fail about 50% of the time.
	print "Content-type: text/xml\n";
	print "\n";
}


sub print_p3p_header
{
	# If you need to set third-party cookies, you'll need to use the P3P
	# privacy policy system, or else IE will reject the cookies.  The system
	# consists of a /w3c folder on your website containing a p3p.xml file
	# and a policy.html file, and then having your server send a P3P header,
	# both in the main .htaccess file and anytime a script needs to output
	# headers.  The value should be something like this:
	#
	#	$PREF{p3p_header} = qq`P3P: CP="ALL DSP COR NID", policyref="/w3c/p3p.xml"`;
	#
	# Or, you can leave off the policyref:
	#
	#	$PREF{p3p_header} = qq`P3P: CP="ALL DSP COR NID"`;
	#
	# You may want to use a service like http://p3pedit.com/ to create your
	# XML and privacy files.  And you can use www.w3.org/P3P/validator.html
	# to validate your setup.

	return if $PREF{p3p_header_printed};

	$PREF{p3p_header_printed} = 1;
	my $noprint = shift;
	my $headers = '';
	$headers .= "$PREF{p3p_header}\n" if $PREF{p3p_header};
	$noprint ? return $headers : print $headers;
}


sub offsettime	{ return time + $PREF{time_offset}; }
sub date6	{ return strftime("%Y%m", localtime(shift || offsettime())); }
sub date8	{ return strftime("%Y%m%d", localtime(shift || offsettime())); }
sub date14	{ return strftime("%Y%m%d-%H%M%S", localtime(shift || offsettime())); }
sub date17	{ return strftime("%Y%m%d-%H:%M:%S", localtime(shift || offsettime())); }
sub date19	{ return strftime("%Y-%m-%d %H:%M:%S", localtime(shift || offsettime())); }


sub offset_etime($$)
{
	my ($etime, $offset) = @_;
	my ($operation, $amount, $multiplier_code) = ($offset =~ /([\+-])(\d+)([smhdb])/);
	my $multiplier = $multiplier_code eq 'm' ? 60 : $multiplier_code eq 'h' ? 3600 : $multiplier_code eq 'd' ? 86400 : 1;
	if($multiplier_code eq 'b')
	{
		while($amount)
		{
			do { $etime = $operation eq '+' ? $etime + 86400 : $etime - 86400; } while is_weekend($etime);
			$amount--;
		}
	}
	else
	{
		$etime = $operation eq '+' ? $etime + ($amount * $multiplier) : $etime - ($amount * $multiplier);
	}
	return $etime;
}


sub is_weekend($)
{
	return (localtime($_[0]))[6] =~ /[06]/; # (localtime($etime))[6] is the weekday, with 0 being Sunday and 6 being Saturday.
}


sub sql_untaint
{
	s/"/&quot;/g for @_;
	s/'/&#39;/g for @_;
	s/`/&#96;/g for @_;
	s/\\/&#92;/g for @_;
}


sub sql_un_untaint
{
	s/&quot;/"/g for @_;
	s/&#39;/'/g for @_;
	s/&#96;/`/g for @_;
	s/&#92;/\\/g for @_;
}


sub sql_un_untaint_return
{
	my $str = shift; sql_un_untaint($str); return $str;
}


sub enc_hash
{
	return $PREF{use_weak_md5_hashes} =~ /yes/i ? md5_hex(@_) : sha1_hex(@_);
}


# 20160709: our old sqlsafe approach didn't always handle non-English characters properly, and had various other
# issues, and never actually blocked anything except possibly some sub-ASCII control characters.  The correct
# approach is to validate each var in its own context anyway, so these will all now just return.
#
sub not_sqlsafe { return; }
sub die_unless_sqlsafe { return; }
sub replace_nonsqlsafe_chars_with { return; }   # TODO: this one might need some special fixes?


sub oddeven
{
	$_[0] = 0 unless $_[0] && $_[0] =~ /^\d+$/;
	$_[0]++ unless $_[1] eq 'dont_inc';
	return $_[1] && $_[1] eq 'reset' ? 'odd' : $_[0] % 2 == 0 ? 'even' : 'odd';
}


sub enc_sql_select($)
{
	#verify_db_connection();
	#my $statement = shift;
	#my $sth = $PREF{dbh}->prepare($statement);
	#$sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL select statement [[$statement]]: $DBI::errstr\n");
	#return $sth->fetchrow;

	my $statement = shift;
	verify_db_connection();
	my $err = "Called from " . (caller 1)[3] . ": error while executing SQL select statement [[$statement]]: ";
	my $sth = $PREF{dbh}->prepare($statement);
	for(my $attempt = 1; $attempt <= 5; $attempt++) {
		if($sth->execute()) {
			return $sth->fetchrow;
		}
		else {
			# If it was NOT a lost-connection error, then die. Otherwise sleep & try again.
			die_nice($err . $DBI::errstr) if($DBI::errstr !~ /lost connection/i);
			sleep 4;
			encdebuglog $err . "$DBI::errstr (on attempt $attempt/5; retrying up to 5 times)\n";
		}
	}
	die_nice($err . "$DBI::errstr (tried 5 times; giving up now).\n");
}


sub enc_sql_select_multi($)
{
	my $statement = shift;
	verify_db_connection();
	my $err = "Called from " . (caller 1)[3] . ": error while executing SQL select statement [[$statement]]: ";
	my $sth = $PREF{dbh}->prepare($statement);
	for(my $attempt = 1; $attempt <= 5; $attempt++) {
		if($sth->execute()) {
			my $i = 1;
			my %hash = ();
			while(my $row = $sth->fetchrow_hashref) {
				foreach my $field (keys %$row) {
					$hash{$i}{$field} = $$row{$field};
				}
				$i++;
			}
			return \%hash;
		}
		else {
			# If it was NOT a lost-connection error, then die. Otherwise sleep & try again.
			die_nice($err . $DBI::errstr) if($DBI::errstr !~ /lost connection/i);
			sleep 4;
			encdebuglog $err . "$DBI::errstr (on attempt $attempt/5; retrying up to 5 times)\n";
		}
	}
	die_nice($err . "$DBI::errstr (tried 5 times; giving up now).\n");
}


sub enc_sql_select_array($)
{
	my $statement = shift;
	verify_db_connection();
	my $err = "Called from " . (caller 1)[3] . ": error while executing SQL select statement [[$statement]]: ";
	my $sth = $PREF{dbh}->prepare($statement);
	for(my $attempt = 1; $attempt <= 5; $attempt++) {
		if($sth->execute()) {
			my @results = ();
			while(my $ref = $sth->fetchrow_arrayref()) 
			{
				push @results, @{$ref};
			}
			return @results;
		}
		else {
			# If it was NOT a lost-connection error, then die. Otherwise sleep & try again.
			die_nice($err . $DBI::errstr) if($DBI::errstr !~ /lost connection/i);
			sleep 4;
			encdebuglog $err . "$DBI::errstr (on attempt $attempt/5; retrying up to 5 times)\n";
		}
	}
	die_nice($err . "$DBI::errstr (tried 5 times; giving up now).\n");
}


sub enc_sql_update($)
{
	my $statement = shift;
	verify_db_connection();
	my $err = "Called from " . (caller 1)[3] . ": error while executing SQL update statement [[$statement]]: ";
	my $sth = $PREF{dbh}->prepare($statement);
	for(my $attempt = 1; $attempt <= 5; $attempt++) {
		if(my $numrows = $sth->execute()) {
			return $numrows;
		}
		else {
			# If it was NOT a lost-connection error, then die. Otherwise sleep & try again.
			die_nice($err . $DBI::errstr) if($DBI::errstr !~ /lost connection/i);
			sleep 4;
			encdebuglog $err . "$DBI::errstr (on attempt $attempt/5; retrying up to 5 times)\n";
		}
	}
	die_nice($err . "$DBI::errstr (tried 5 times; giving up now).\n");
}


sub enc_sql_insert($)
{
	my $statement = shift;
	verify_db_connection();
	my $err = "Called from " . (caller 1)[3] . ": error while executing SQL insert statement [[$statement]]: ";
	my $sth = $PREF{dbh}->prepare($statement);
	for(my $attempt = 1; $attempt <= 5; $attempt++) {
		if($sth->execute()) {
			return;   # success.
		}
		else {
			# If it was NOT a lost-connection error, then die. Otherwise sleep & try again.
			die_nice($err . $DBI::errstr) if($DBI::errstr !~ /lost connection/i);
			sleep 4;
			encdebuglog $err . "$DBI::errstr (on attempt $attempt/5; retrying up to 5 times)\n";
		}
	}
	die_nice($err . "$DBI::errstr (tried 5 times; giving up now).\n");
}


sub enc_sql_delete($)
{
	#my $retval = $sth->execute();
	#die_nice("called from " . (caller 1)[3]  . ": error while executing SQL delete statement: $DBI::errstr.  Statement was: [[ $statement ]]\n") if $retval =~ /^(0|0E0)$/; # execute() returns '0E0' if no rows were affected by the statement.

	my $statement = shift;
	verify_db_connection();
	my $err = "Called from " . (caller 1)[3] . ": error while executing SQL delete statement [[$statement]]: ";
	my $sth = $PREF{dbh}->prepare($statement);
	for(my $attempt = 1; $attempt <= 5; $attempt++) {
		my $retval = $sth->execute();
		if($retval && $retval !~ /^(0|0E0)$/) {
			return;   # success.
		}
		else {
			# If it was NOT a lost-connection error, then die. Otherwise sleep & try again.
			die_nice($err . $DBI::errstr) if($DBI::errstr !~ /lost connection/i);
			sleep 4;
			encdebuglog $err . "$DBI::errstr (on attempt $attempt/5; retrying up to 5 times)\n";
		}
	}
	die_nice($err . "$DBI::errstr (tried 5 times; giving up now).\n");
}


sub enc_sys_call
{
	# TODO: this doesn't always work.

	my $cmd = shift;
	my ($msg,$success) = ();

	if(my $timeout = $PREF{sys_call_timeout})
	{
		eval
		{

		local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
		alarm $timeout;

		# Note: don't change this without changing the matching block below.
		system($cmd);
		if ($? == -1)		{ $success = 0; $msg = "error: failed to execute: $!"; }
		elsif ($? & 127)	{ $success = 0; $msg = sprintf "error: child died with signal %d, %s coredump", ($? & 127),  ($? & 128) ? 'with' : 'without'; }
		else			{ $success = 1; $msg = sprintf "child exited with value %d", $? >> 8; }

		};

		if($@)
		{
			if($@ eq "alarm\n")
			{
				# timed out.
				$success = 0; $msg = "error: timeout while executing: $!";
			}
			else
			{
				# propagate unexpected errors.
				$success = 0; $msg = "unexpected error while executing: $@";
			}
		}
		else
		{
			# didn't time out.
		}
	}
	else
	{
		# Note: don't change this without changing the matching block above.
		system($cmd);
		if ($? == -1)		{ $success = 0; $msg = "error: failed to execute: $!"; }
		elsif ($? & 127)	{ $success = 0; $msg = sprintf "error: child died with signal %d, %s coredump", ($? & 127),  ($? & 128) ? 'with' : 'without'; }
		else			{ $success = 1; $msg = sprintf "child exited with value %d", $? >> 8; }
	}

	$msg = "enc_sys_call(): command was [[ $cmd ]]; result was [[ $msg ]];";
	printd "$msg\n";

	$PREF{sys_call_timeout} = 0; # always reset this so it's disabled by default, and the caller can choose to set it before calling us if necessary.
	return ($success, $msg);
}


sub exit_with_error { $PREF{static_error_message} ? print_and_exit($PREF{static_error_message}) : exit_with___generic($PREF{error_message_template}, 1, @_); } # Errors that the end-user is supposed to see.
sub exit_with_success { exit_with___generic($PREF{success_message_template}, 0, @_); } # Success messages that the end-user is supposed to see.
sub exit_with_notice { exit_with___generic($PREF{notice_message_template}, 0, @_); } # Non-error messages that the end-user is supposed to see.
sub exit_with_output { exit_with___generic('', 0, @_); } # For any output; no template will be used.


sub print_and_exit
{
	# This sub should NOT include any full HTML output, headers/footers, etc.  Just the bare minimum necessary to display the string it receives.
	print_http_headers(); print @_; exit;
}


sub exit_with___generic
{
	my $template = shift;
	my $error = shift;
	my $message = join '', @_; my $raw_msg = $message;
	#print STDERR $message;
	$template =~ s/%%message%%/$message/g;
	$message = $template =~ /\Q$message\E/ ? $template : $message; # in case prefs haven't been loaded yet.
	if($MISC{json_mode})
	{
		json_print($raw_msg);
	}
	elsif($MISC{ajax_mode})
	{
		print_ajax($raw_msg);
	}
	elsif(!$PREF{we_are_virtual} && $PREF{here} ne $ENV{SCRIPT_NAME} && $ENV{REQUEST_METHOD} =~ /post/i)
	{
		# 20081213: added method=post requirement; otherwise, if $PREF{here} is set to something other than
		# $ENV{SCRIPT_NAME}, then visiting the script directly will trigger this, which isn't what we want.
		# TODO: should method=post be the ONLY requirement for this if()?

		## Any $PREF{extra_debug} will be lost on redirect unless we store it with the keyed message.
		#enc_redirect(   ($PREF{here_static} || $PREF{here}) . "?kmsg=" . store_keyed_message($message . ($PREF{extra_debug} ? get_extra_debug_output() : undef))   );
		kmsg_redirect($message);
	}
	else
	{
		start_html_output(''); print $message; finish_html_output();
	}
	if($error) { $message = "Exiting with error: $message\n"; encdebuglog $message; print STDERR $message; }
	exit;
}


# New exit sub like exit_with___generic except without all the cruft (templates, the list-version of $message, and weird virtual/here tests):
#
sub output_and_exit
{
	my $optsref = shift; my %opts = %$optsref;
	$opts{msg} = $PREF{static_error_message} if $PREF{static_error_message} && $opts{is_error};
	if($MISC{json_mode})
	{
		json_print($opts{msg});
	}
	elsif($MISC{ajax_mode})
	{
		foreach my $var (keys %opts)
		{
			if($var eq 'success')	{ $opts{msg} = "success=$opts{$var}:::::msg=" . $opts{msg} }
			elsif($var eq 'error')	{ $opts{msg} = "success=$opts{$var}:::::msg=" . $opts{msg} }
			else			{ $opts{msg} .= ":::::$var=$opts{$var}"; }
		}
		print_ajax($opts{msg});
	}
	else
	{
		$opts{msg} = qq`<div style="margin: 20px auto;">$opts{msg}</div>`;
		if($ENV{REQUEST_METHOD} =~ /post/i)
		{
			$opts{msg} = qq`<div id="encsubtitle">$opts{title}</div>\n$opts{msg}` if $opts{title};   # otherwise the title is lost in this branch.
			kmsg_redirect($opts{msg});
		}
		else
		{
			start_html_output($opts{title}); print $opts{msg}; finish_html_output();
		}
	}
	exit;
}


sub get_kmsg_var_from_url() { return ($qs =~ /(?:^|&)$PREF{twochar_app_id}kmsg=(\w+)(?:&|$)/)[0]; }
sub get_smsg_var_from_url() { return ($qs =~ /(?:^|&)$PREF{twochar_app_id}smsg=(\w+)(?:&|$)/)[0]; }


sub do_early_kmsg_check()
{
	# Need this sub because some errors can occur in the init stages, before the dispatch
	# chain, and therefore before the normal kmsg check.  So without this early check,
	# any such errors would be silently ignored: ?kmsg=foo would be on the URL, but we
	# wouldn't detect it.

	if(my $key = get_kmsg_var_from_url()) {
		if(my $msg = get_keyed_message($key, 1)) {
			start_html_output(''); print $msg; finish_html_output(); exit;
		}
	}
}

sub exit_with_kmsg
{
	start_html_output(''); print get_keyed_message($_[0]); finish_html_output(); exit;
}


sub exit_with_needlogin
{
	start_html_output('');
	$PREF{needlogin_message} =~ s/%%login_url%%/$PREF{login_url}/g;
	print $PREF{needlogin_message};
	finish_html_output();
	exit;
}


sub exit_with_needprivs
{
	my $whenceqs = $qs; $whenceqs =~ s!&!_ANAMP_!g;
	my $login_url = '';
	if(userbase_available() || $PREF{integrate_with_existing_login_system} =~ /yes/i)
	{
		$login_url = $PREF{login_url_qsready};
	}
	else
	{
		$login_url = "$PREF{here_login_qsready}action=" . ($PREF{internal_appname} =~ /visitorlog/i ? 'vllogin' : 'login') . '&amp;';
	}
	$login_url .= ($PREF{default_url_vars} ? "$PREF{default_url_vars}&amp;" : "") . "needprivs=true&amp;whence=$PREF{REQ_URI_SANS_QS}" . ($whenceqs ? "_THEQS_$whenceqs" : '');
	$login_url = "$PREF{protoprefix}$ENV{HTTP_HOST}$login_url" unless $login_url =~ /^https?:/;
	my $js_login_url = $login_url; $js_login_url =~ s!&amp;!&!g;

	my $auto_redirect = qq`<script type="text/javascript">location.href="$js_login_url";</script>\n`;

	$PREF{needprivs_message} =~ s/%%login_url%%/$login_url/g;
	$PREF{needprivs_message} =~ s/%%js_auto_redirect%%/$PREF{member_is_logged_in} ? '' : $auto_redirect/eg;
	$PREF{needprivs_message} =~ s/%%%if-notloggedin%%%(.+?)%%%end-notloggedin%%%/$PREF{member_is_logged_in} ? '' : $1/egs;

	output_and_exit({ title=>'Authentication Required', msg=>$PREF{needprivs_message} });
}


sub printd
{
	my $msg = shift;
	chomp $msg;
	$msg = "$PREF{internal_appname}-debug: " . (offsettime()) . ": $msg";
	if($PREF{debug} || $PREF{force_debug} =~ /yes/i || $debuglog)
	{
		enc_warn "$msg\n";
		encdebug $msg;
		print $debuglog "$msg\n" if $debuglog;
	}
	if($PREF{debug})
	{
		#print_http_headers();
		#print "<!-- $msg -->\n";
	}
}


# Some SQL implementations support other nonsense in the table names; we'll restrict to a sensible set of characters.
#
sub tablename_is_valid				{ return ($_[0] =~ /^\w+$/	&&						length($_[0]) <= $PREF{max_tablename_length});		}
sub check_tablename_for_sql_safeness		{ die_nice("Invalid tablename: '$_[0]'") unless tablename_is_valid($_[0]); 								}


sub test_database_connection_ajax
{
	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	my ($success,$errmsg) = get_db_connection();
	my $result = '';
	if($success)
	{
		$result = "Success!&nbsp; Connected to database $PREF{database_name}.";
		if(   ($PREF{internal_appname} eq 'userbase')   &&   (!db_table_exists($PREF{user_table}) || !enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}`"))   )
		{
			$result .= qq`&nbsp; <a href="$PREF{here_qsready}action=makefirstadmin">Click here to continue</a>.`;
		}
		if($PREF{internal_appname} eq 'visitorlog')
		{
			$result .= qq`&nbsp; <a href="$PREF{here_qsready}action=admin">Click here to continue</a>.`;
		}
	}
	else { $result = $errmsg; }
	$result =~ s!\n!::NEWLINE::!g;
	print qq`dbtest_result=$result`;
	print qq`</data>\n\n`;
	exit;   # explicit exit needed because this sub is called from the early dispatch chain.
}


sub setup_database_prefs()
{
	output_and_exit({ title=>"Authentication Required", msg=>qq`Please <a href="$PREF{here_qsready}action=login&amp;whence=$PREF{REQ_URI_SANS_QS}_THEQS_action=dbsetup">login</a> first.` }) unless $PREF{admin_is_logged_in};
	$PREF{csswrapperclass} = 'encmidwidth';

	start_html_output("Database Setup");
	print qq`<p class="dbsetup_intro">`;
	print qq`Setup Step #2 of 3: ` if $PREF{internal_appname} eq 'userbase' && !$PREF{database_name} && !$PREF{database_username};
	print qq`Please enter your MySQL database name, username, and password below.&nbsp;
		If you have a specific database hostname, enter that too.&nbsp; In many cases
		the hostname can be left blank or set to "localhost".&nbsp; Not sure where to
		find these details?&nbsp; You can usually find/set them in your web hosting
		control panel.&nbsp; Or if you're running your own server, you can install
		MySQL and then <a href="http://encodable.com/database_setup/">create your
		database and user account</a> yourself.
		</p>
	`;


	print qq`<p class="dbsetup_intro">For FileChucker, these settings are not strictly required;
		they're only necessary if you want to use one of the optional features that uses a
		database, such as integrate_with_userbase, or store_upload_info_in_database, etc.
		</p>\n` if $PREF{internal_appname} eq 'filechucker';


	print qq`<br /><form name="enc_webconfig" id="enc_db_setup" method="get" action="#">\n`;

	print	  get_webconfig_pref_form({ preftype=>'PREF', i=>1, short=>1, prefname=>'database_hostname',	prefval=>$PREF{database_hostname} })
		. get_webconfig_pref_form({ preftype=>'PREF', i=>2, short=>1, prefname=>'database_name',	prefval=>$PREF{database_name} })
		. get_webconfig_pref_form({ preftype=>'PREF', i=>3, short=>1, prefname=>'database_username',	prefval=>$PREF{database_username} })
		. get_webconfig_pref_form({ preftype=>'PREF', i=>4, short=>1, prefname=>'database_password',	prefval=>$PREF{database_password} });

	print "\n</form>\n";

	print qq`<br /><br /><div><input type="button" onclick="test_db_connection()" value="Test Database Connection" /><br /><p id="db_test_output"></p></div>\n`;

	finish_html_output();
	exit;   # explicit exit needed because this sub is called from the early dispatch chain.
}


# Call in list context if you want to manually handle any errors; otherwise
# this sub will die on error.
#
sub get_db_connection
{
	my $force = shift;
	my $errmsg = '';
	eval { require DBI; }; die_nice qq`error while trying to load the DBI module.&nbsp; You probably need to <a href="http://encodable.com/perl_modules/" target="_blank">install the Perl module</a> for it.&nbsp; The error message was: <br /><br />\n\n $0: $@\n` if $@;
	if(!$PREF{dbh}   ||   $force)
	{
		my $dbname = $PREF{database_name};
		$dbname .= ":$PREF{database_hostname}" if $PREF{database_hostname};
		$PREF{dbi_connection_string} =~ s!%%dbname%%!$dbname!g;

		if(!$PREF{database_name} || !$PREF{database_username})
		{
			# 20121220: apparently DBI->connect may return true even when the db name/user/pass are all null??
			$errmsg = qq`Can't connect to database because your db prefs are not set (\$PREF{database_name} and \$PREF{database_username}, etc).&nbsp; Please <a href="$PREF{here_qsready}action=dbsetup">go here and set them</a>.`;
		}
		elsif($PREF{dbh} = DBI->connect($PREF{dbi_connection_string}, $PREF{database_username}, $PREF{database_password}))
		{
			# 20090425: there's a bug somewhere in the Perl MySQL stack which causes the
			# database connection to be silently dropped in some cases, resulting in the
			# Perl script simply dying (segfaulting?) when attempting to use the connection.
			# This happens even though mysql_auto_reconnect is enabled; disabling that
			# causes the script to die with the "MySQL server has gone away" error, instead
			# of dying silently.  Furthermore, with mysql_auto_reconnect enabled, the Perl
			# script will also segfault if you call $dbh->ping() after the connection has
			# been lost, making it totally worthless for its intended purpose.  The root
			# cause of this issue may be the following DBD-mysql bug:
			#
			#	http://rt.cpan.org/Public/Bug/Display.html?id=37027
			#
			# That bug report hasn't been updated since October of 2008, and the bug still
			# exists as of April 2009, so as a workaround, we'll disable mysql_auto_reconnect
			# and then always do a $dbh->ping() before every database communication.
			#
			# Update: fixed in 2010?
			#$PREF{dbh}->{mysql_auto_reconnect} = 0;
			$PREF{dbh}->{mysql_auto_reconnect} = 1;
		}
		else
		{
			$errmsg = qq`Error connecting to database.&nbsp; Please <a href="$PREF{here_qsready}action=dbsetup">adjust your db prefs</a> if necessary.&nbsp; The error was: ` . $DBI::errstr;
		}
	}
	if($errmsg)
	{
		if(wantarray) { return (0,$errmsg); }
		else { exit_with_error $errmsg; }
	}
	else { return (1,undef); }   # most callers will ignore this, which is fine.
}


sub verify_db_connection
{
	get_db_connection('force') unless $PREF{dbh} && $PREF{dbh}->ping;
}


sub db_column_exists($$)
{
	my $column_to_find = shift;
	my $table_name = shift;

	verify_db_connection();
	check_tablename_for_sql_safeness($table_name);

	my ($column_name, $temp) = ('','');
	my $sth = $PREF{dbh}->prepare("SHOW COLUMNS FROM `$table_name`;");
	$sth->execute() or die_nice "Error: $DBI::errstr\n";
	$sth->bind_columns(\$column_name, \$temp, \$temp, \$temp, \$temp, \$temp);
	while($sth->fetchrow_arrayref)
	{
		#print STDERR "column_name='$column_name', column_to_find='$column_to_find'\n";

		#return 1 if $column_name eq $column_to_find;
		#
		# MySQL returns a "Duplicate column name" error if you try to create a column
		# named (for example) "Color" when there's already one named "color":
		#
		return 1 if lc($column_name) eq lc($column_to_find);
	}
	return 0;
}


sub db_table_exists($)
{
	my ($table_to_check, $table, $table_exists) = (shift, '', 0);
	verify_db_connection();
	my $sth = $PREF{dbh}->prepare(qq`show tables;`);
	$sth->execute();
	$sth->bind_columns(\$table);
	while($sth->fetchrow_arrayref)
	{
		if($table eq $table_to_check)
		{
			$table_exists = 1;
			last;
		}
	}
	return $table_exists;
}


sub get_db_colnames($)
{
	my $table = shift;
	check_tablename_for_sql_safeness($table);
	my $colnames = '';
	my $column_name = '';
	my $temp = '';
	my $sth = $PREF{dbh}->prepare("SHOW COLUMNS FROM `$table`;");
	$sth->execute() or die_nice "$0: Error: db_column_exists(): $DBI::errstr\n";
	$sth->bind_columns(\$column_name, \$temp, \$temp, \$temp, \$temp, \$temp);
	while($sth->fetchrow_arrayref)
	{
		$colnames .= $column_name . ',';
	}
	$colnames =~ s/,$//;
	return $colnames;
}


sub enlarge_varchar_field_if_necessary($$$)
{
	my ($table, $field, $size) = @_;
	die_unless_sqlsafe($table, $field);
	die_unless_numeric($size, 'size in enlarge_varchar_field_if_necessary()');
	my $field_details = get_field_details_from_db($table,$field);
	unless($$field_details{type} =~ /varchar\($size\)/i)
	{
		my $statement = qq`alter table $table modify $field VARCHAR($size) NOT NULL;`;
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't enlarge $field column on table '$table': $DBI::errstr\n");
		encdebug "enlarged $field field on table $table";
	}
}


sub get_ip_and_host
{
	my $ip = $ENV{REMOTE_ADDR};
	my $host = $ENV{REMOTE_HOST};

	if($PREF{static_hostname})
	{
		$host = $PREF{static_hostname};
	}
	else
	{
		if((!$host) || ($host !~ /\w\.\w/)) { $host = $ip; }
		if($host eq $ip)
		{
			use Socket;
			$host = gethostbyaddr(inet_aton($ip), AF_INET);
		}
		if((!$host) || ($host !~ /\w\.\w/)) { $host = $ip; }
	}

	return ($ip, $host);
}


sub is_ipv4_address
{
	return $_[0] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
}


sub is_private_ipv4_address($)
{
        return ($_[0] =~ /^(10\.|127\.0\.0|192\.168\.)/) || ($_[0] =~ /^172\.(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)\./);
}


sub is_ipv6_address
{
	return $_[0] =~ /^[abcdef\d\.:]{2,39}$/ && $_[0] =~ /:/;   # technically, ::1 and even :: are valid IPV6 addresses.
}


sub fix_remote_ip_and_host
{
	# Fix any screwy IPs, for example (actual REMOTE_ADDR values that we've seen, one per line):
	#
	#	10.67.3.137, 127.0.0.1
	#	167.205.41.63, 2403:8000:22:96::105
	#	144.214.121.6, 203.198.74.110
	#	10.77.40.240, 10.77.19.75
	#	200.9.114.175, 192.9.150.4, 196.1.114.3
	#	unknown, 147.91.177.132
	#	1.0.190.167, 1.0.190.167, 127.0.0.1
	#	109.173.122.122, 109.173.122.122, 127.0.
	#
	# Some of those are non-routable (local) IPs, others are mixed IPV4/IPV6 addresses,
	# etc... let's at least get a single well-formed address out of it where possible:

	my $host_equals_ip = $ENV{REMOTE_ADDR} eq $ENV{REMOTE_HOST};

	# Some hosting companies (Yahoo) set REMOTE_ADDR to their own IP (it's a cache or proxy or something)
	# and then set the true end-user IP in a different ENV var, so if those exist, use them instead.
	# Update 20120501: some hosting companies (iPage) set HTTP_X_FORWARDED_FOR to something invalid, for
	# example "103.22.8.245, 69.34.117.30".
	#
	# One of these alternate vars (HTTP_YAHOOREMOTEIP, HTTP_X_FORWARDED_FOR, HTTP_CLIENT_IP) is sometimes
	# set to the true IP, and/or REMOTE_ADDR itself is sometimes invalid (e.g. containing a list of IPs
	# separated by commas/spaces instead of just a single IP), so to be safe, we need to check each var
	# to find the best value for the real IP.
	# 
	if($ENV{HTTP_YAHOOREMOTEIP} || $ENV{HTTP_X_FORWARDED_FOR} || $ENV{HTTP_CLIENT_IP}	# if one of these weird vars is set,
	 || is_private_ipv4_address($ENV{REMOTE_ADDR})						# or the ip's set but it's private,
	 || (!is_ipv4_address($ENV{REMOTE_ADDR}) && !is_ipv6_address($ENV{REMOTE_ADDR}))	# or the ip's just plain invalid.
	)
	{
		my $an_ip = '';
		foreach my $var ($ENV{HTTP_YAHOOREMOTEIP}, $ENV{HTTP_X_FORWARDED_FOR}, $ENV{HTTP_CLIENT_IP}, $ENV{REMOTE_ADDR})
		{
			my $got_a_good_one = 0;
			foreach my $ip (split(/[, ]+/, $var))
			{
				next if $ip eq $ENV{REMOTE_ADDR};   # if this is already equal to the whole REMOTE_ADDR then no need to check it.
				if(is_ipv6_address($ip))
				{
					enc_warn "fixing REMOTE_ADDR from '$ENV{REMOTE_ADDR}' to '$ip'";
					$ENV{REMOTE_ADDR} = $ip;
					$got_a_good_one = 1;
					last;
				}
				if(is_ipv4_address($ip))
				{
					if(!is_private_ipv4_address($ip))
					{
						enc_warn "fixing REMOTE_ADDR from '$ENV{REMOTE_ADDR}' to '$ip'";
						$ENV{REMOTE_ADDR} = $ip;
						$got_a_good_one = 1;
						last;
					}
					else
					{
						$an_ip = $ip;
					}
				}
			}
			last if $got_a_good_one;   # quit the outer loop too.
		}
		if(!is_ipv4_address($ENV{REMOTE_ADDR}) && !is_ipv6_address($ENV{REMOTE_ADDR}))
		{
			$an_ip ||= '0.0.0.0';
			enc_warn "fixing REMOTE_ADDR from '$ENV{REMOTE_ADDR}' to the less-than-ideal '$an_ip' because we couldn't determine a better one for this client.";
			$ENV{REMOTE_ADDR} = $an_ip;
		}
	}

	$ENV{REMOTE_HOST} = $ENV{REMOTE_ADDR} if $host_equals_ip;
}


sub populate_month_conversion_hashes
{
	$PREF{monthnum}{jan}='01';
	$PREF{monthnum}{feb}='02';
	$PREF{monthnum}{mar}='03';
	$PREF{monthnum}{apr}='04';
	$PREF{monthnum}{may}='05';
	$PREF{monthnum}{jun}='06';
	$PREF{monthnum}{jul}='07';
	$PREF{monthnum}{aug}='08';
	$PREF{monthnum}{sep}='09';
	$PREF{monthnum}{oct}='10';
	$PREF{monthnum}{nov}='11';
	$PREF{monthnum}{dec}='12';

	$PREF{monthnum}{january}='01';
	$PREF{monthnum}{february}='02';
	$PREF{monthnum}{march}='03';
	$PREF{monthnum}{april}='04';
	$PREF{monthnum}{may}='05';
	$PREF{monthnum}{june}='06';
	$PREF{monthnum}{july}='07';
	$PREF{monthnum}{august}='08';
	$PREF{monthnum}{september}='09';
	$PREF{monthnum}{october}='10';
	$PREF{monthnum}{november}='11';
	$PREF{monthnum}{december}='12';

	$PREF{monthname}{"01"} = 'Jan';
	$PREF{monthname}{"02"} = 'Feb';
	$PREF{monthname}{"03"} = 'Mar';
	$PREF{monthname}{"04"} = 'Apr';
	$PREF{monthname}{"05"} = 'May';
	$PREF{monthname}{"06"} = 'Jun';
	$PREF{monthname}{"07"} = 'Jul';
	$PREF{monthname}{"08"} = 'Aug';
	$PREF{monthname}{"09"} = 'Sep';
	$PREF{monthname}{"10"} = 'Oct';
	$PREF{monthname}{"11"} = 'Nov';
	$PREF{monthname}{"12"} = 'Dec';
}


sub save_php_var_to_cache($$)
{
	my $new_var = shift;
	my $new_value = shift;
	my $new_date = offsettime();
	my $new_sessid = get_cookie($PREF{php_session_cookie_name});
	die_nice qq`PHP session ID cookie is null.&nbsp; To get/set your variable (username or userdir) from PHP, you must call $PREF{internal_appname_nice} from a PHP page using setenv() and the call_$PREF{twochar_app_id}.php method, as explained in the FAQ.&nbsp; In rare cases, you may need to adjust \$PREF{php_session_cookie_name} (currently '$PREF{php_session_cookie_name}').` unless $new_sessid; # if there's no sessionid, we have no way to index into the cache file.
	for($new_var, $new_value, $new_date, $new_sessid)
	{
		s/:::::/ENCFIVECOLONS/g;
		s/\n/ENCNEWLINE/g;
	}
	my ($session_found, $var_found) = ();

	create_file_if_DNE($PREF{php_session_cache_file},$PREF{writable_file_perms});
	my @new_contents = ();
	open(CACHEFH,"+<$PREF{php_session_cache_file}") or die_nice("couldn't open cache file '$PREF{php_session_cache_file}' for R/W: $!\n");
	my $iofh = \*CACHEFH;
	flock $iofh, 2;
	seek $iofh, 0, 0;
	while(<$iofh>)
	{
		if(/^date=(\d+?):::::sessid=(\w+?):::::.+/)
		{
			chomp;
			my ($date, $sessid) = ($1, $2);
			if($new_date - $date < $PREF{php_session_cache_ttl})
			{
				if($sessid ne $new_sessid)
				{
					# If this record doesn't belong to the current user, don't bother processing it.
					push (@new_contents, "$_\n");
				}
				else
				{
					$session_found = 1;
					my $new_line = "date=${date}:::::sessid=${sessid}:::::";
					foreach my $var (split(/:::::/))
					{
						my ($name,$value) = ($var =~ /(\w+)=(.*)/);
						next if $name =~ /^(date|sessid)$/i;
						if($name eq $new_var)	{ $new_line .= "$name=${new_value}:::::"; $var_found = 1; }
						else			{ $new_line .= "$name=${value}:::::"; }
					}
					$new_line .= "$new_var=${new_value}:::::" if !$var_found;
					push (@new_contents, "$new_line\n");
				}
			}
		}
	}
	push (@new_contents, "date=${new_date}:::::sessid=${new_sessid}:::::$new_var=${new_value}:::::\n") if !$session_found;
	seek $iofh, 0, 0;
	print $iofh @new_contents;
	truncate $iofh, tell $iofh;
	close $iofh or die_nice("couldn't close cache file '$PREF{php_session_cache_file}' after R/W: $!\n");
}


sub get_php_var_from_cache($)
{
	my $new_var = shift;
	my $new_value = '';
	my $new_date = offsettime();
	my $new_sessid = get_cookie($PREF{php_session_cookie_name});
	die_nice qq`PHP session ID cookie is null.&nbsp; To get/set your variable (username or userdir) from PHP, you must call $PREF{internal_appname_nice} from a PHP page using setenv() and the call_$PREF{twochar_app_id}.php method, as explained in the FAQ.&nbsp; In rare cases, you may need to adjust \$PREF{php_session_cookie_name} (currently '$PREF{php_session_cookie_name}').` unless $new_sessid; # if there's no sessionid, we have no way to index into the cache file.
	for($new_var, $new_value, $new_date, $new_sessid)
	{
		s/:::::/ENCFIVECOLONS/g;
		s/\n/ENCNEWLINE/g;
	}

	create_file_if_DNE($PREF{php_session_cache_file},$PREF{writable_file_perms});
	open(CACHEFH,"<$PREF{php_session_cache_file}") or die_nice("couldn't open cache file '$PREF{php_session_cache_file}' for reading: $!\n");
	my $infh = \*CACHEFH;
	flock $infh, 1;
	seek $infh, 0, 0;
	while(<$infh>)
	{
		if(/^date=(\d+?):::::sessid=(\w+?):::::.+/)
		{
			my ($date, $sessid) = ($1, $2);
			if($new_date - $date < $PREF{php_session_cache_ttl}   &&   $sessid eq $new_sessid)
			{
				if(/(?:^|:::::)$new_var=(.*?)(?::::::|$)/) { $new_value = $1; }
			}
		}
	}
	close $infh or die_nice("couldn't close cache file '$PREF{php_session_cache_file}' after reading: $!\n");
	return $new_value;
}


sub cache_and_read_any_nonpost_env_vars()
{
	$PREF{nonpost_env_var_cache_ttl} = 60*60*24 unless $PREF{nonpost_env_var_cache_ttl} =~ /^\d+$/; # in seconds.
	my $file = $PREF{datadir} . '/cache_for_nonpost_env_vars.cgi';
	create_file_if_DNE($file, $PREF{writable_file_perms});
	my $current_date = offsettime();
	my (%live_env_vars, %cached_env_vars, %live_env_vars_missing_from_cache, %cached_env_vars_that_need_to_be_updated) = ();
	my ($expired_records, @records_from_other_users, @cached_env_vars_missing_from_live_env, @unchanged_cached_env_vars) = ();

	foreach my $var (sort keys %ENV)
	{
		$live_env_vars{$var} = $ENV{$var} if(

			($var =~ /^PHP/)
			
			||
			
			($PREF{enable_username_from_environment_variable} =~ /yes/i   &&   $var eq $PREF{username_envvar_name})
			
		);
	}
	if(%live_env_vars)
	{
		open(my $iofh, "+<$file") or die_nice qq`couldn't open file '$file' for R/W: $!`;
		flock $iofh, 2;
		seek $iofh, 0, 0;
		while(<$iofh>)
		{
			chomp;
			if(/^date=(\d+):::::encvisid=(\w+):::::(\w+)=(.*)/)
			{
				my ($date, $encvisid, $var, $value) = ($1, $2, $3, $4);
				if($current_date - $date < $PREF{nonpost_env_var_cache_ttl})
				{
					if($encvisid eq $PREF{enc_visitor_id})
					{
						$value =~ s!ENCNEWLINE!\n!g;

						$cached_env_vars{$var} = $value;
						if(! exists $ENV{$var})
						{
							push (@cached_env_vars_missing_from_live_env, "$_\n");
							$ENV{$var} = $value;
						}
						elsif($cached_env_vars{$var} ne $ENV{$var})
						{
							$cached_env_vars_that_need_to_be_updated{$var} = $ENV{$var};
						}
						else
						{
							push (@unchanged_cached_env_vars, "$_\n");
						}
					}
					else
					{
						# If this record doesn't belong to the current user, don't bother processing it.
						push (@records_from_other_users, "$_\n");
					}
				}
				else
				{
					$expired_records = 1;
				}
			}
		}
		foreach my $var (sort keys %live_env_vars)
		{
			if(! exists $cached_env_vars{$var})
			{
				$live_env_vars_missing_from_cache{$var} = $live_env_vars{$var};
			}
		}

		my @new_contents = ();
		if($expired_records || %live_env_vars_missing_from_cache || %cached_env_vars_that_need_to_be_updated)
		{
			foreach my $var (keys %live_env_vars_missing_from_cache)
			{
				my $value = $live_env_vars_missing_from_cache{$var}; $value =~ s!\n!ENCNEWLINE!g;
				push @new_contents, "date=${current_date}:::::encvisid=$PREF{enc_visitor_id}:::::${var}=${value}\n";
			}
			foreach my $var (keys %cached_env_vars_that_need_to_be_updated)
			{
				my $value = $cached_env_vars_that_need_to_be_updated{$var}; $value =~ s!\n!ENCNEWLINE!g;
				push @new_contents, "date=${current_date}:::::encvisid=$PREF{enc_visitor_id}:::::${var}=${value}\n";
			}
			push @new_contents, @cached_env_vars_missing_from_live_env;
			push @new_contents, @unchanged_cached_env_vars;
			push @new_contents, @records_from_other_users;
			
			seek $iofh, 0, 0;
			print $iofh @new_contents;
			truncate $iofh, tell $iofh;
		}

		close($iofh) or die_nice qq`couldn't close file '$file' after R/W: $!`;
	}
	else
	{
		# We were POSTed to?  So populate the live %ENV with any cached nonpost vars for this user.

		if(-s $file) # don't bother opening/closing the file if it's empty.
		{
			open(my $infh, $file) or die_nice qq`couldn't open file '$file' for reading: $!`;
			flock $infh, 1;
			seek $infh, 0, 0;
			while(<$infh>)
			{
				chomp;
				if(/^date=(\d+):::::encvisid=$PREF{enc_visitor_id}:::::(\w+)=(.*)/)
				{
					my ($date, $var, $value) = ($1, $2, $3);
					if($current_date - $date < $PREF{nonpost_env_var_cache_ttl})
					{
						$value =~ s!ENCNEWLINE!\n!g;
						$ENV{$var} = $value;
					}
				}
			}
			close($infh) or die_nice qq`couldn't close file '$file' after reading: $!`;
		}
	}
}


sub do_email_test
{
	exit_with_error(qq`This feature is disabled in the trial version of UserBase. <a href="http://encodable.com/userbase/">Get the full version!</a>`);
}


sub send_test_email_ajax
{
	my $to		= $PREF{email_test_recipient};
	my $from	= $PREF{email_test_sender};

	if($PREF{admin_is_logged_in})
	{
		$to = enc_param('email_to') if enc_param('email_to');   # don't check for validity here, to allow multiple addresses.
		$from = enc_param('email_from') if is_valid_email_address(enc_param('email_from'));
	}

	my $subj	= "test message - $PREF{date14} - $ENV{HTTP_HOST} - $PREF{internal_appname_nice}";
	my $format	= $PREF{mailtest_email_format} || 'html';
	my $die		= 0;   # get_qs_var('die') eq '0' ? '' : 'die_on_email_error';

	my $authname	= $PREF{smtp_auth_username} ? 'not null' : 'null';
	my $authpass	= $PREF{smtp_auth_password} ? 'not null' : 'null';

	my $output = '';

	if($PREF{enable_email_test} !~ /yes/i && !$PREF{admin_is_logged_in})
	{
		$output = qq`To use this feature, either <a href="` . get_login_url()  . qq`">login</a> as an admin, or edit your prefs file and set/add these prefs:<br /><br />\$PREF{enable_email_test} = 'yes'; <br />\$PREF{email_test_recipient} = 'you\@wherever.com'; <br />\$PREF{email_test_sender} = 'alsoyou\@somewhere.com';`;
	}
	elsif($to && is_valid_email_address($from))
	{
		my $msg		= $PREF{email_test_message};
		$msg		||= $PREF{email_wrapper_head}
				. qq`This is only a test.&nbsp; Email settings:\n<br /><br />`
				. qq`\$PREF{path_to_sendmail}	= '$PREF{path_to_sendmail}'\n<br />`
				. qq`\$PREF{smtp_server}	= '$PREF{smtp_server}'\n<br />`
				. qq`\$PREF{smtp_auth_username}	is $authname.\n<br />`
				. qq`\$PREF{smtp_auth_password}	is $authpass.\n<br />`
				. qq`\$PREF{use_NetSMTP_for_email}	= '$PREF{use_NetSMTP_for_email}'\n<br />`
				. qq`\$PREF{try_direct_SMTP_connection}	= '$PREF{try_direct_SMTP_connection}'\n<br />`
				. qq`\n<br />Perl module status: \n<br /><br />` . join("\n<br />", get_enc_perl_modules('with_status')) . qq`\n<br />`
				. qq`\n<br />Sent from:\n<br />`
				. qq`<a href="$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{here_qsready}do_email_test">$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{here_qsready}do_email_test</a>\n<br />`
				. $PREF{email_wrapper_foot};

		my ($success, $errmsg) = send_email({ to => $to, from => $from, subject => $subj, message => $msg, mimetype => $format, die_on_error => $die });
		$output = $success ? qq`Sent test message from "$from" to "$to"; no immediate error occurred.&nbsp; Method used: $errmsg.` : qq`Tried to send test message from "$from" to "$to" but an error occurred:<br />\n\n$errmsg`;
	}
	else
	{
		$output = qq`Error: missing/invalid address for sender or receiver.`;
	}

	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	$output =~ s!\n!::NEWLINE::!g;
	print qq`emailtest_result=$output`;
	print qq`</data>\n\n`;
}


sub add_text_to_file($$$)
{
	# Note: this function doesn't automatically insert any newlines; it
	# only inserts precisely what it receives in the $text parameter.

	my ($text, $file, $position) = @_;
	open(my $iofh, "+<$file") or die_nice "couldn't open file '$file' for R/W: $!\n";
	flock $iofh, 2;

	if($position eq 'start')
	{
		seek $iofh, 0, 0;
		my @contents = <$iofh>;
		seek $iofh, 0, 0;
		print $iofh $text;
		print $iofh @contents;
	}
	elsif($position eq 'clobber')
	{
		seek $iofh, 0, 0;
		print $iofh $text;
	}
	else
	{
		seek $iofh, 0, 2;
		print $iofh $text;
	}

	truncate $iofh, tell $iofh;
	close $iofh or die_nice "couldn't close file '$file' after R/W: $!\n";
}


sub handle_file_upload
{
	my $optsref = shift; my %opts = %$optsref;
	my $query = $opts{query};
	my %uploadedfiles = ();
	my @output_filenames = ();
	my $num_files_uploaded = 0;

	foreach my $tmpfile ($query->upload($opts{upload_field_name})) # what upload() returns is apparently both a handle and a filename?
	{
		$num_files_uploaded++;
		$uploadedfiles{$num_files_uploaded}{param}	= enc_param($opts{upload_field_name}, $query);
		$uploadedfiles{$num_files_uploaded}{handle}	= $tmpfile;
		$uploadedfiles{$num_files_uploaded}{filename}	= $tmpfile;
	}

	foreach my $i (sort keys %uploadedfiles)
	{
		my $filename = $uploadedfiles{$i}{filename};
		$filename = lc($filename) if $opts{lowercase_filenames};
		$filename =~ s!.*?([^/\\]+)$!$1!;	# remove any path.
		$filename =~ s!\.{2,}!.!g;		# condense any multi-dots.
		$filename =~ s![^\w\.-]!_!g if $opts{cleanup_filenames}; # remove any unusual stuff including spaces.

		my ($file_base,$file_ext) = ($filename =~ /(.+)\.(.+)/);
		die_nice qq`File base name must not be null.` unless $file_base;
		die_nice qq`File extension must be one of ($opts{allowed_extensions}) but it's "$file_ext".` if $opts{allowed_extensions} && $filename !~ /($opts{allowed_extensions})/i;

		my $path = $opts{output_path}; $path .= '/' unless $path =~ m!/$!;
		my $output_file_full = $path . $filename;
		$output_file_full = serialize_filename_if_file_exists($output_file_full);
		$uploadedfiles{$i}{output_file_full} = $output_file_full;

		my $upload_filehandle = $uploadedfiles{$i}{handle};
		open(UPLOADFILE,">$output_file_full") or die_nice "couldn't create file '$output_file_full': $!\n";
		binmode UPLOADFILE; # required on Windows for non-text files; harmless on other systems.
		while(<$upload_filehandle>) { print UPLOADFILE; }
		close UPLOADFILE or die_nice "couldn't close file '$output_file_full': $!\n";
		chmod $PREF{writable_file_perms}, $output_file_full;

		my (undef,$output_filename) = split_path_and_filename($output_file_full);
		push @output_filenames, $output_filename;
	}

	return @output_filenames;
}


sub get_database_data
{
	$PREF{on_page} = 'default';
	my ($tableprefname,$viewerprefname,$allowed_to_view,$allowed_to_create,$allowed_to_edit,$allowed_to_delete) = @_;
	my $dbtable = $PREF{$tableprefname} || $tableprefname; # "$tableprefname" can be the name of the pref OR of the table.
	my $createmode = 0;
	my $editmode = 0;
	my $row_id_to_edit = 0;

	if($PREF{"${viewerprefname}_enable_whence_links"} =~ /yes/i)
	{
		if((my $ref = $ENV{HTTP_REFERER}) && $qs !~ /(?:^|&)dbvwrwhence=.+/)
		{
			$ref =~ s!\?!_encrplcdqm_!g;
			$ref =~ s!&!_encrplcdamp_!g;
			$ref =~ s!^https?://!!;
			$ref =~ s!^$ENV{HTTP_HOST}!!;
			$ref .= '_dbvwrwhncend_';
			$qs .= "&dbvwrwhence=$ref";
			$ENV{REQUEST_URI} .= $ENV{REQUEST_URI} =~ /\?/ ? "&dbvwrwhence=$ref" : "?dbvwrwhence=$ref"
		}
		if($qs =~ /(?:^|&)dbvwrwhence=(.+)_dbvwrwhncend_/)
		{
			$PREF{dbvwrwhence} = $1;
			$PREF{dbvwrwhence} =~ s!_encrplcdqm_!?!g;
			$PREF{dbvwrwhence} =~ s!_encrplcdamp_!&!g;
		}
	}

	my $display_length		= $PREF{"${viewerprefname}_viewer_max_display_length"} || 500;
	my $pagetitle			= $PREF{"${viewerprefname}_viewer_title"};
	my $template			= $PREF{"${viewerprefname}_viewer_template"} || qq`\n%%subtitle%%\n%%header_note%%\n%%%if-db_view_controls%%%<p id="db_view_controls">[ %%db_view_controls%% ]</p>\n%%%end-db_view_controls%%%\n%%%if-qs_filters%%%<p id="db_filter_note">%%filter_note%%</p>\n%%%end-qs_filters%%%<br />\n%%output%%\n<p>%%pagelinks%%</p>\n%%serverdate%%\n%%footer_misc%%\n%%csv_link%%\n%%search_form%%\n%%footer_note%%\n`;
	my @template_viewcontrols	= $PREF{"${viewerprefname}_viewer_template_viewcontrols"} || (qq`%%horizlink:text=Horizontal%%`, qq`%%vertlink:text=Vertical%%`, qq`%%viewalllink:text=View All%%`);
	my $template_viewcontrols_sep	= $PREF{"${viewerprefname}_viewer_template_viewcontrols_separator"} || ' | ';
	$template			=~ s!%%header_note%%!<div class="database_header_note">$PREF{"${viewerprefname}_viewer_header_note"}</div>!g;
	$template			=~ s!%%subtitle%%!$PREF{"${viewerprefname}_viewer_subtitle"} ? qq`<div class="database_subtitle">$PREF{"${viewerprefname}_viewer_subtitle"}</div>` : ''!eg;
	$template			=~ s!%%footer_note%%!$PREF{"${viewerprefname}_viewer_footer_note"}!g;
	my $itemsperpage		= $PREF{"${viewerprefname}_viewer_itemsperpage"} || 10;
	$itemsperpage			= $QS{ipp} if $QS{ipp} =~ /^\d+$/ && $PREF{admin_is_logged_in};
	my $extra_columns		= \%{$PREF{"${viewerprefname}_viewer_extra_columns"}};
	my %db_update_details		= ( table => $dbtable, viewerprefname => $viewerprefname );
	my $csv_output			= '';

	my $creation_title_transforms	= \%{$PREF{"${viewerprefname}_creation_title_transforms"}};
	my $editmode_title_transforms	= \%{$PREF{"${viewerprefname}_editmode_title_transforms"}};
	my $viewer_title_transforms	= \%{$PREF{"${viewerprefname}_viewer_title_transforms"}};
	my $viewer_value_transforms	= \%{$PREF{"${viewerprefname}_viewer_value_transforms"}};
	my %custom_titles		= ();

	my $selection_restrictions	= $PREF{"${viewerprefname}_viewer_selection_restrictions"};
	my $editmode_restrictions	= $PREF{"${viewerprefname}_editmode_restrictions"};
	
	$PREF{"${viewerprefname}_viewer_db_url"}	||= "$PREF{here_qsready}action=" . get_qs_var('action');
	$PREF{"${viewerprefname}_viewer_db_url_full"}	||= $PREF{protoprefix} . $ENV{HTTP_HOST} . $PREF{"${viewerprefname}_viewer_db_url"}; # for within emails, etc.

	# extra_columns have a position within the displayed table, and a value, although
	# the value will often be null because it'll instead be set by a transform.  set
	# their position to >1000 in order to put them at the end of the table.
	#
	# title_transforms just change the header text for the specified column.
	#
	# value_transforms use "%%variable%%" to refer to the name/value of their own column, and
	# can also use %%foo%%, where foo is the name of any other column in the same table.
	#
	# _editmode_frontend_value_transforms are viewer transforms specifically for edit-mode;
	# they transform the values that pre-populate the form when editing a record.  So they
	# don't transform the backend (i.e. the POST side) at all.
	#
	# You can pass ?raw$columnname=yes on the URL to display that column's values in their
	# raw form, with any viewer transformations disabled.
	#
	# To create an image picker:
	#
	#	$PREF{"${viewerprefname}_image_picker"}{your_field_name_here} = {
	#		thumb_size	=> 80,
	#		other_sizes	=> '600,800,1200'
	#	};

	my ($range_start,$range_end,$sql_range_start) = get_pagination_range($itemsperpage);

	if($allowed_to_create)
	{
		$createmode = 1 if get_qs_var('createmode') eq 'true';
	}

	if($allowed_to_edit)
	{
		# Nothing in here should need editing.
		if(get_qs_var('editmode') eq 'true'   &&   get_qs_var('editid') =~ /^(\d+)$/)
		{
			$editmode = 1;
			$row_id_to_edit = $1;
		}
		elsif(!$createmode)
		{
			$$extra_columns{edit} = { position => 1 };
			$$viewer_value_transforms{edit} = qq`%%variable%% = '<a href="$PREF{REQ_URI_SANS_QS}?$qs&editmode=true&amp;editid=%%id%%&amp;dbview=vert">$TEXT{Edit}</a>';`;
		}
	}
	$PREF{db_editor_mode} = $createmode ? 'create' : $editmode ? 'edit' : '';

	my $viewing_single_item = 1 if $createmode || $editmode || $QS{id} =~ /^\d+$/;

	my $hiddencols		= $qs =~ /allfields=true/ ? 0
				: ($viewing_single_item  && $PREF{"${viewerprefname}_viewer_hidden_columns_singlemode"}) ? $PREF{"${viewerprefname}_viewer_hidden_columns_singlemode"}
				: (!$viewing_single_item && $PREF{"${viewerprefname}_viewer_hidden_columns_multimode"})  ? $PREF{"${viewerprefname}_viewer_hidden_columns_multimode"}
				: $PREF{"${viewerprefname}_viewer_hidden_columns"};   # TODO: add UI for allfields=true.
	my $disabledcols	= $PREF{"${viewerprefname}_viewer_disabled_columns"};
	$hiddencols = apply_column_hiding_from_browser($hiddencols);

	if($PREF{"${viewerprefname}_viewer_show_view_link"} && !$createmode && !$editmode && !$viewing_single_item)
	{
		$$extra_columns{view} = { position => 1 };
		$$viewer_value_transforms{view} = qq`%%variable%% = '<a href="$PREF{REQ_URI_SANS_QS}?$qs&amp;id=%%id%%&amp;dbview=vert">$TEXT{View}</a>';`;
	}

	die_unless_sqlsafe($dbtable);
	die_unless_numeric($row_id_to_edit, '$row_id_to_edit');
	$db_update_details{record_id} = $row_id_to_edit;
	my $live_data_fingerprint = sha256_hex($ENV{HTTP_HOST} . $ENV{HTTP_USER_AGENT} . join('',enc_sql_select("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit")));

	my $restriction = '';
	my $num_cols = 0;

	my $db_colnames = get_db_colnames($dbtable);
	$num_cols += ($db_colnames =~ tr/,//) + 1;

	# If any extra (i.e. not straight from the DB) columns were specified,
	# get or assign their positions:
	#
	my %extra_column_names = ();
	foreach my $colname (keys %$extra_columns)
	{
		my $requested_pos = $$extra_columns{$colname}{position};
		if(!$requested_pos || ($requested_pos < 1000))
		{
			my $pos = $$extra_columns{$colname}{position} =~ /^(\d+)$/ ? $1 : $num_cols;
			$pos++ while exists $extra_column_names{$pos};
			$extra_column_names{$pos} = $colname;
			$num_cols++;
		}
	}

	# Create the combined @column_list from the actual DB columns and
	# the extra columns with their specified positions:
	#
	my $j = 0;
	my @column_list = ();
	for(my $i = 1; $i <= $num_cols; $i++)
	{
		if($extra_column_names{$i})	{ push @column_list, $extra_column_names{$i};	}
		else				{ push @column_list, (split(/,/, $db_colnames))[$j++];	}
	}

	# Now go through the extra columns again, for any that requested to
	# be at the end of the table (by specifying a position >1000):
	#
	foreach my $colname (keys %$extra_columns)
	{
		my $requested_pos = $$extra_columns{$colname}{position};
		if($requested_pos >= 1000)
		{
			push @column_list, $colname;
			$num_cols++;
		}
	}

	my $column_list = join ',', @column_list;

	my $vertical = $qs =~ /(?:^|&)dbview=vert(?:&|$)/ || ($PREF{"${viewerprefname}_viewer_default_mode"} =~ /vertical/i && $qs !~ /(?:^|&)dbview=horiz(?:&|$)/);
	$vertical = 0 if ($PREF{"${viewerprefname}_viewer_forced_mode"} =~ /horiz/i   ||   ($viewing_single_item && $PREF{"${viewerprefname}_viewer_forced_mode_in_singlemode"} =~ /horiz/i)   ||   (!$viewing_single_item && $PREF{"${viewerprefname}_viewer_forced_mode_in_multimode"} =~ /horiz/i));
	$vertical = 1 if ($PREF{"${viewerprefname}_viewer_forced_mode"} =~ /vert/i    ||   ($viewing_single_item && $PREF{"${viewerprefname}_viewer_forced_mode_in_singlemode"} =~ /vert/i)    ||   (!$viewing_single_item && $PREF{"${viewerprefname}_viewer_forced_mode_in_multimode"} =~ /vert/i));
	my %columns = map { $_ => 1 } split(/,/, $column_list);
	my %hidden_columns = map { $_ => 1 } split(/\s*,\s*/, $hiddencols);
	my %disabled_columns = map { $_ => 1 } split(/\s*,\s*/, $disabledcols);
	my %hidden_cells = ();

	my %uncreatable_columns = map { $_ => 1 } split(/\s*,\s*/, $PREF{"${viewerprefname}_viewer_uncreatable_columns"});
	my %uneditable_columns = map { $_ => 1 } split(/\s*,\s*/, $PREF{"${viewerprefname}_viewer_uneditable_columns"});
	my %autoset_columns = %{$PREF{"${viewerprefname}_creation_autoset_columns"}} if $PREF{"${viewerprefname}_creation_autoset_columns"};
	$uneditable_columns{id} = $uncreatable_columns{id} = 1;

	$PREF{"${viewerprefname}_viewer_item_name"} = $PREF{"${viewerprefname}_viewer_item_name"} || 'record';
	$PREF{"${viewerprefname}_viewer_item_name_plural"} = $PREF{"${viewerprefname}_viewer_item_name_plural"} || $PREF{"${viewerprefname}_viewer_item_name"}.'s';
	s!%%itemname%%!$PREF{"${viewerprefname}_viewer_item_name"}!g for ($TEXT{database_create_button}, $TEXT{database_create_button_2}, $TEXT{database_delete_successful}, $TEXT{database_deleter_title}, $TEXT{database_deleter_checkbox}, $TEXT{database_deleter_button});


	# Set any viewer/editor options that apply to all modes (view/create/edit):
	#
	foreach my $column (split(/,/, $column_list))
	{
		my $fieldtype_already_set = 0;
		if(my ($fieldtype,$label,$listitems,$defaultvalue) = field_structure_managed_by_us($column))
		{
			$custom_titles{$column} = $label if $label;
			$PREF{"${viewerprefname}_creation_default_value"}{lc($column)} = $defaultvalue if $defaultvalue;
			if($fieldtype eq 'dropdown')
			{
				$listitems =~ s!\n!\|\|\|!g; # our field structure manager uses newline as separator; this function uses "|||".
				$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)} = $listitems;
				$fieldtype_already_set = 1;
			}
			elsif($fieldtype eq 'checkbox')
			{
				$PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} = 1;
				$fieldtype_already_set = 1;
			}
			elsif($fieldtype eq 'radio')
			{
				$listitems =~ s!\n!\|\|\|!g; # our field structure manager uses newline as separator; this function uses "|||".
				$PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)} = $listitems;
				$fieldtype_already_set = 1;
			}
			elsif($fieldtype eq 'freeformmulti')
			{
				$PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)} = 1;
				$fieldtype_already_set = 1;
			}
		}
		if(datatype_is_bool($dbtable,$column) && !$fieldtype_already_set)
		{
			$PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} = 1;
			$fieldtype_already_set = 1;
		}
	}


	# Note: early return.
	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		my $return_url_base = enc_param('enc_post_return_url') || $PREF{REQ_URI_SANS_QS};

		my $wholequery = CGI->new();
		my %allparams = $wholequery->Vars; check_input_data(\%allparams);
		my %multiboxes = ();
		foreach my $param(sort keys %allparams)
		{
			if(my ($col,$val) = ($param =~ /^encdb_multibox_col_(.+)_val_(.+)/))
			{
				enc_urldecode($val);
				$multiboxes{$col} .= $val . '|||';
			}
		}
		foreach my $col (keys %multiboxes) { $multiboxes{$col} =~ s!\|\|\|$!!; } # strip the final trailing '|||'.

		if(enc_param('searchmode') eq 'true')
		{
			exit_with_needprivs() unless $PREF{"${viewerprefname}_allowed_to_search"};

			my $redirect_url = get_return_url_for_dbviewer($return_url_base, $viewerprefname) . '&';

			my $searchquery = new CGI(); # must happen if we were POSTed to, or there's a weird delay between client/server after the script finishes.
			my %params = $searchquery->Vars; check_input_data(\%params);
			foreach my $param(sort keys %params)
			{
				#print "$param: $params{$param}<br />\n";
				if(my ($field) = ($param =~ /^srch_(.+)/))
				{
					my $value = $params{$param};
					my $srchmode = $params{"srchmode_${field}"};
					$redirect_url =~ s!srch[1234]_${field}=[^&]+!!g; # remove any previous values for this field from the url.
					$redirect_url .= "srch${srchmode}_${field}=$value&" unless $srchmode == 4;   # 4 means ignore-this-field.
				}
			}

			defooify('&', $redirect_url);
			enc_redirect($redirect_url);		
		}
		elsif($editmode)
		{
			exit_with_needprivs() unless $allowed_to_edit;

			my $data_fingerprint_before_editing = enc_param('enc_form_dfp');
			exit_with_error(qq`Error: data fingerprint mismatch; the data changed while you were editing it.&nbsp; Go back, reload the page, and try again.`) unless $live_data_fingerprint eq $data_fingerprint_before_editing;

			# We're only dealing with a single row here, but we'll use _multi to get the named fields into a hash.
			my $existingdata = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit $editmode_restrictions");

			if($qs =~ /editdelete=true/)
			{
				exit_with_needprivs() unless $allowed_to_delete;

				$db_update_details{action} = 'delete'; $db_update_details{action_pasttense} = 'deleted';

				foreach my $col (keys %{$$existingdata{1}})
				{
					exit_with_error("Error: this record cannot be deleted.") if exists $PREF{"${viewerprefname}_viewer_undeletable_rows"}{lc($col)}{   $$existingdata{1}{$col}   };
				}

				if(enc_param('confirmdeleterecord') =~ /on/i)
				{
					my $values = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit LIMIT 1");
					enc_sql_delete("DELETE FROM `$dbtable` WHERE `id` = $row_id_to_edit LIMIT 1");

					if(my $code = $PREF{"${viewerprefname}_deletion_oncomplete_code"})
					{
						$code =~ s/%%(\w+)%%/$$values{1}{$1}/g;
						eval $code; die_nice $@ if $@;
					}

					$db_update_details{deleted_record} = $existingdata;
					send_notification_emails_for_database_update(\%db_update_details) if $PREF{"${viewerprefname}_emailalert_on_updates"} =~ /yes/i;
					enc_redirect(get_return_url_for_dbviewer($return_url_base, $viewerprefname));
				}
				else
				{
					$qs =~ s!editdelete=true!!g;
					defooify('&',$qs);
					enc_redirect($return_url_base . ($qs ? "?$qs" : ''));
				}
			}
			else
			{
				$db_update_details{action} = 'edit'; $db_update_details{action_pasttense} = 'edited';

				my %values = ();
				foreach my $column (keys %{$$existingdata{1}})
				{
					my $value = $column eq 'id' ? $row_id_to_edit : enc_param("encdb_$column");   # otherwise $values{id} will always be null.
					$value =~ s!\r\n!\n!g;
					$values{"${column}___raw"} = $value;

					if(my $code = $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)})
					{
						my %values_temp = { $column => '' };
						transform_value_according_to_code($dbtable, $value, \%values_temp, $code, $column, 2, undef);
						$value = $values_temp{$column};
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)})
					{
						$value = enc_param("encdb_" . $column) =~ /on/i ? 1 : 0;
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)})
					{
						$value = $multiboxes{$column};
					}
					elsif($PREF{"${viewerprefname}_file_picker"}{lc($column)})
					{
						$value = process_encdb_filepicker_post($viewerprefname, $column, $wholequery, enc_param("encdb_$column"));
					}
					elsif($PREF{"${viewerprefname}_image_picker"}{lc($column)})
					{
						$value = process_encdb_filepicker_post($viewerprefname, $column, $wholequery, enc_param("encdb_$column"));
					}

					replace_nonsqlsafe_chars_with($PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column}, $value) if exists $PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column};

					$values{$column} = $value;
				}

				# A second version of the same loop, but this time %values is full, so that 
				# verify_new_database_value() can use it, in case the caller has used the
				# _viewer_value_verifications mechanism with embedded %%foo%% variables which
				# require accessing other column values.
				#
				my $col_i = 0;
				foreach my $column (keys %values)
				{
					next if $disabled_columns{$column} || $column =~ /^enchddn_/i || $$existingdata{1}{enchddn_uneditable_cols_in_this_row} =~ /$column/i;
					next if $column =~ /___raw$/;
					next if $uneditable_columns{lc($column)};
					next if exists $PREF{"${viewerprefname}_viewer_uneditable_values"}{lc($column)}{   $$existingdata{1}{$column}   };

					my $value = $values{$column};
					verify_new_database_value($dbtable,$viewerprefname,$column,$value,$row_id_to_edit,\%values);

					sql_untaint($value,$column);
					die_unless_sqlsafe($value,$column);

					$col_i++;
					unless($value eq $$existingdata{1}{$column})
					{
						$db_update_details{changed_record}{$col_i}{column} = $column;
						$db_update_details{changed_record}{$col_i}{old_value} = $$existingdata{1}{$column};
						$db_update_details{changed_record}{$col_i}{new_value} = $value;

						$value = $value eq '' ? qq`NULL` : qq`'$value'`;
						my $success = enc_sql_update("UPDATE `$dbtable` SET `$column` = $value WHERE `id` = $row_id_to_edit");
						die_nice("SQL returned '$success' instead of '1' while updating '$column'.") unless $success == 1;
					}
				}

				if(my $code = $PREF{"${viewerprefname}_editmode_oncomplete_code"})
				{
					$code =~ s/%%(\w+)___old%%/$$existingdata{1}{$1}/g;
					$code =~ s/%%(\w+)%%/$values{$1}/g;
					eval $code; die_nice $@ if $@;
				}

				$db_update_details{whole_changed_record} = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit");
				send_notification_emails_for_database_update(\%db_update_details) if $PREF{"${viewerprefname}_emailalert_on_updates"} =~ /yes/i;
				enc_redirect(get_return_url_for_dbviewer($return_url_base, $viewerprefname));
			}
		}
		else
		{
			exit_with_needprivs() unless $allowed_to_create;

			$db_update_details{action} = 'create'; $db_update_details{action_pasttense} = 'created';

			my @namelist = my @valuelist = ();

			# Do this twice, because we might need to interpolate a variable value from a
			# late column into an early column, which won't be set the first time through.
			#
			my %values = ();
			my %creation_autoset_columns___done = ();
			my %POST_value_transforms___done = ();
			foreach my $pass (1,2)
			{
				foreach my $column (split(/,/, $db_colnames))
				{
					if(my $code = $PREF{"${viewerprefname}_creation_autoset_columns"}{lc($column)})
					{
						my $value = '';
						transform_value_according_to_code($dbtable, $value, \%values, $code, $column, $pass, \%creation_autoset_columns___done);
					}
					elsif(my $code = $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)})
					{
						my $value = enc_param("encdb_" . $column);
						$values{"${column}___raw"} = $value;
						transform_value_according_to_code($dbtable, $value, \%values, $code, $column, $pass, \%POST_value_transforms___done);
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)})
					{
						$values{$column} = enc_param("encdb_" . $column) =~ /on/i ? 1 : 0;
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)})
					{
						$values{$column} = $multiboxes{$column};
					}
					elsif($PREF{"${viewerprefname}_file_picker"}{lc($column)})
					{
						next unless $pass == 1;   # don't want to process the uploaded files multiple times.
						$values{$column} = process_encdb_filepicker_post($viewerprefname, $column, $wholequery, enc_param("encdb_$column"));
					}
					elsif($PREF{"${viewerprefname}_image_picker"}{lc($column)})
					{
						next unless $pass == 1;   # don't want to process the uploaded files multiple times.
						$values{$column} = process_encdb_filepicker_post($viewerprefname, $column, $wholequery, enc_param("encdb_$column"));
					}
					else
					{
						$values{$column} = enc_param("encdb_" . $column);
					}
					$values{$column} =~ s!\r\n!\n!g;
				}
			}

			foreach my $column (keys %values)
			{
				next if $uncreatable_columns{$column};
				next if $column =~ /^enchddn_/i;
				next if $column =~ /___raw$/;
				next if $disabled_columns{$column} && !($autoset_columns{$column} || $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)}); # don't allow disabled columns to be set, except via autoset values, or via being transformed from other columns, etc.

				my $value = $values{$column};
				replace_nonsqlsafe_chars_with($PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column}, $value) if exists $PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column};
				verify_new_database_value($dbtable,$viewerprefname,$column,$value,'',\%values);
				$values{$column} = $value; # want the sqlsafe version but not the sql_untainted version.
				sql_untaint($value);
				die_unless_sqlsafe($value);
				push @namelist, "`$column`";

				$value = 0 if !$value && datatype_is_numeric($dbtable, $column);
				push @valuelist, "'$value'";
			}

			my $statement = "INSERT INTO `$dbtable` (" . (join ',', @namelist) . ") VALUES(" . (join ',', @valuelist) . ")";
			enc_sql_insert($statement);
			my $id = enc_sql_select("SELECT LAST_INSERT_ID() FROM `$dbtable`");
			$values{id} = $db_update_details{record_id} = $id;

			if(my $code = $PREF{"${viewerprefname}_creation_oncomplete_code"})
			{
				$code =~ s/%%(\w+)%%/$values{$1}/g;
				eval $code; die_nice $@ if $@;
			}

			$db_update_details{created_record} = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $id");
			send_notification_emails_for_database_update(\%db_update_details) if $PREF{"${viewerprefname}_emailalert_on_updates"} =~ /yes/i;
			if(my $template = $PREF{"${viewerprefname}_creation_complete_page_template"})
			{
				$template =~ s/%%(\w+)%%/$values{$1}/g; kmsg_redirect($template);
			}
			elsif(my $redirect = $PREF{"${viewerprefname}_creation_complete_redirection_url"})
			{
				$redirect =~ s/%%(\w+)%%/$values{$1}/g; enc_redirect($redirect);
			}
			else
			{
				enc_redirect(get_return_url_for_dbviewer($return_url_base, $viewerprefname));
			}
		}
	}




	my (@toggles,$headers_horiz_string,%headers_horiz,%headers_vert,$firstcol) = ();
	my $header_i = 0;
	foreach my $column (split(/,/, $column_list))
	{
		next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
		next if $uncreatable_columns{$column} && $createmode;
		next if $$extra_columns{$column} && $createmode;
		$header_i++;

		$firstcol = $column unless $firstcol;
		my $name = my $title = $column;
		if($$creation_title_transforms{$column} && $createmode)		{ $title = $$creation_title_transforms{$column};											}
		elsif($$editmode_title_transforms{$column} && $editmode)	{ $title = $$editmode_title_transforms{$column};											}
		elsif($$viewer_title_transforms{$column})			{ $title = $$viewer_title_transforms{$column};											}
		elsif($custom_titles{$column})					{ $title = $custom_titles{$column};											}
		else								{ $title =~ s/^(\w)/\u$1/; $title =~ s/_/ /g unless $PREF{dont_convert_underscores_to_spaces_in_db_titles} =~ /yes/i;	}
		my $strike = qq`style="text-decoration: line-through;"` if $hidden_columns{$name};
		push @toggles, qq`<a href="#" onclick="toggle_column('col_$name'); return false" id="link-col_$name" $strike>$title</a>`;

		$hidden_cells{$name} = qq`style="display: none;"` if $hidden_columns{$name} && !$createmode; # don't hide them in createmode, where the user must be able to see them to enter values for them.

		my $new_qs = $qs;
		#$new_qs =~ s/(^|&)$qs_id(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)sort=\w+?(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)reverse=\d(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)phase=\w+?(&|$)/$1$2/g;
		$new_qs .= "&sort=$name";
		if($qs =~ /(?:^|&)reverse=1(?:&|$)/) { $new_qs .= "&reverse=0"; } else { $new_qs .= "&reverse=1"; }
		defooify('&',$new_qs);
		$new_qs =~ s/&/&amp;/g;

		my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{"${column}_header"} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{"${column}_header"};
		my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{"${column}_header"} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{"${column}_header"};
		#my $link = $self =~ /\?/ ? "$self&$new_qs" : "$self?$new_qs";
		my $link = "$PREF{REQ_URI_SANS_QS}?$new_qs";
		$headers_horiz_string	.= qq`<th class="col_$name" $hidden_cells{$name} $style_horiz><a href="$link">$title</a></th>`;
		$headers_horiz{$name}	 = qq`<th class="col_$name" $hidden_cells{$name} $style_horiz><a href="$link">$title</a></th>`;
		$headers_vert{$name}	 = qq`<td class="col_$name verthead" $hidden_cells{$name} $style_vert><a href="$link">$title</a><span class="header_input_notes">` . ($createmode || $editmode ? $PREF{"${viewerprefname}_input_notes_for_vertmode_col_header"}{$column} : '') . qq`</span></td>`;

		unless($$extra_columns{edit} && ($header_i == 1)) { $csv_output .= $title . ','; }
	}
	$csv_output =~ s!,$!!; $csv_output .= "\n";   # remove the extra trailing comma and add a newline.

	my $output = '';
	my %qs_filters = ();
	my $there_were_some_results = 0;

	if($createmode)
	{
		my $createclass = $vertical ? 'enc_dbcreate_tbl_vert' : 'enc_dbcreate_tbl_horiz';
		$output .= qq`<form id="${dbtable}_create_form" onsubmit="return encdb_submit('${dbtable}_create_form')" accept-charset="UTF-8" method="post" enctype="multipart/form-data" action="$ENV{SCRIPT_NAME}?$qs" style="margin: 0; padding: 0;">\n`;
		$output .= qq`<div id="${dbtable}_table" class="enc_tbl enc_db_tbl enc_create_tbl $createclass">\n<table>\n`;
		$output .= qq`<tr class="headers">$headers_horiz_string</tr>\n` unless $vertical;

		my $i = 0;
		my $numcols = 1;
		my $oddeven = oddeven($i);
		$output .= qq`<tr class="$oddeven">` unless $vertical;
		foreach my $column (split(/,/, $column_list))
		{
			next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
			next if $uncreatable_columns{$column};
			next if $$extra_columns{$column};
			next if $autoset_columns{$column};

			my $value = '';
			if(my $default = $PREF{"${viewerprefname}_creation_default_value"}{lc($column)})
			{
				if($default eq 'preset:date8')		{ $value = strftime("%Y%m%d",localtime(offsettime())); }
				elsif($default eq 'preset:date17')	{ $value = strftime("%Y%m%d-%H:%M:%S",localtime(offsettime())); }
				elsif($default eq 'preset:etime')	{ $value = offsettime(); }
				elsif($default =~ /%URL\{\w+\}/)	{ interpolate_vars_from_URL_and_cookies($default); $value = $default; }
				else					{ $value = $default; }
			}

			my $required = $PREF{"${viewerprefname}_createmode_required_fields"}{lc($column)} ? 'required' : '';
			#my $readonly = $uneditable_columns{lc($column)};
			my $readonly = '';

			my ($readonly__still_submitted, $readonly__still_submitted__class) = ('readonly="readonly"', 'db_readonly') if $PREF{"${viewerprefname}_readonly_value__still_submitted"}{lc($column)};


			# Process viewer/editor options:
			#
			if($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} && !$readonly)
			{
				$value = qq`<input type="checkbox" name="encdb_$column" ` . ($value ? qq`checked="checked"` : '') . qq` class="$required " />`;
			}
			elsif(exists $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} && !$readonly)
			{
				my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
				$value  = qq`<select name="encdb_$column" class="$required ">`
					. qq`<option value="1"` . ($value  ? ' selected="selected"' : '') . qq`>$yes</option>`
					. qq`<option value="0"` . (!$value ? ' selected="selected"' : '') . qq`>$no</option>`
					. qq`</select>`;
			}
			elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)})
			{
				my $dropdown = qq`<select name="encdb_$column" class="$required ">`;
				my $value_is_in_list = 0;
				foreach my $item (split(/\s*\|\|\|\s*/, $list))
				{
					my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
					my $selected = '';
					if($submitted_value eq $value)
					{
						$selected = 'selected="selected"';
						$value_is_in_list = 1;
					}
					$dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
				}
				$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
				$dropdown .= qq`</select>`;
				$value = $dropdown;
			}
			elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)})
			{
				my %allvalues = map { $_ => 1 } split(/\|\|\|/, $value);
				my @boxes = ();
				my $value_is_in_list = 0;
				foreach my $item (split(/\s*\|\|\|\s*/, $list))
				{
					my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
					my $checked = '';
					if($allvalues{$submitted_value})
					{
						$checked = 'checked="checked"';
						$value_is_in_list = 1;
					}
					my $submitted_value_for_paramname = enc_urlencode_return($submitted_value);
					my $boxid = "encdb_multibox_col_${column}_val_${submitted_value_for_paramname}";
					push @boxes, qq`<input type="checkbox" name="$boxid" id="$boxid" $checked class="$required " /><label for="$boxid">$displayed_value</label>`;
				}
				push @boxes, qq`$value (error: not in list!)` if !$value_is_in_list && $value;
				my $separator = $PREF{"db_viewer_multibox_separator___$column"} || $PREF{db_viewer_multibox_separator___global} || '<br />';
				$value = join $separator, @boxes;
			}
			elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)})
			{
				my $item_i = 1;
				my @buttons = ();
				my $value_is_in_list = 0;
				foreach my $item (split(/\s*\|\|\|\s*/, $list))
				{
					my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
					my $checked = '';
					if($submitted_value eq $value)
					{
						$checked = 'checked="checked"';
						$value_is_in_list = 1;
					}
					push @buttons, qq`<input type="radio" name="encdb_$column" id="encdb_radio_${column}_${item_i}" value="$submitted_value" $checked class="$required " /><label for="encdb_radio_${column}_${item_i}">$displayed_value</label>`;
					$item_i++;
				}
				my $separator = $PREF{"db_viewer_radiobutton_separator___$column"} || $PREF{db_viewer_radiobutton_separator___global} || '<br />';
				$value = join $separator, @buttons;
			}
			elsif(my $query = $PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{lc($column)})
			{
				# The value of this query pref must start with: SELECT foo,bar FROM [...].
				# The first column will be the submitted value and the second the displayed value.

				my ($col1,$col2) = ($query =~ /^SELECT (\w+),(\w+) FROM /);
				my $dropdown = qq`<select name="encdb_$column" class="$required ">`;
				my $value_is_in_list = 0;
				my $results = enc_sql_select_multi($query);
				foreach my $k (sort { $a <=> $b } keys %$results)
				{
					my $submitted_value = $$results{$k}{$col1};
					my $displayed_value = $$results{$k}{$col2};
					my $selected = '';
					if($submitted_value eq $value)
					{
						$selected = 'selected="selected"';
						$value_is_in_list = 1;
					}
					$dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
				}
				$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
				$dropdown .= qq`</select>`;
				$value = $dropdown;
			}
			elsif(my $folder = $PREF{"${viewerprefname}_file_list"}{lc($column)})
			{
				my @files = get_all_files($folder);
				my $dropdown = qq`<select name="encdb_$column" class="$required "><option selected="selected" value=""></option>`;
				foreach my $file (@files)
				{
					$dropdown .= qq`<option value="$file">$file</option>`;
				}
				$dropdown .= qq`</select>`;
				$value = $dropdown;
			}
			elsif(exists $PREF{"${viewerprefname}_file_picker"}{lc($column)})
			{
				my $file_picker = \%{$PREF{"${viewerprefname}_file_picker"}{lc($column)}};
				unless($$file_picker{disable_existing_file_chooser_in_createmode})
				{
					my ($link_url, undef, $filenames) = get_encdb_filepicker_info($file_picker, $viewerprefname, $column);
					$value  = qq`<div class="encdb_filpkr_wrapper">\n<div class="encdb_filpkr_chosen_label">$TEXT{database_file_picker_chosen_files_label}</div>\n<div class="encdb_filpkr_chosen" id="encdb_filpkr_chosen_$column"><div class="empty_placeholder">$TEXT{database_file_picker_no_files_label}</div></div>\n`;
					$value .= qq`<div class="encdb_filpkr_all_label">$TEXT{database_file_picker_available_files_label}</div>\n<div class="encdb_filpkr_all" id="encdb_filpkr_all_$column">\n`;
					foreach my $file (@$filenames)
					{
						my $css_id = $file; $css_id =~ s!\W!_!g;
						$value .= qq`<div class="encdb_filpkr_file_block" id="encdb_filpkr_file_${column}_${css_id}">`
							. ($PREF{database_file_picker_file_icon} ? qq`<div class="filpkr_icon"><a href="$link_url/$file"><img src="$PREF{database_file_picker_file_icon}" /></a></div>` : undef)
							. qq`<div class="filpkr_text">$file<br /><a href="#" class="encdb_filpkr_actionlink" onclick="encdb_filpkr_choose('$column','$file','$css_id'); return false" />$TEXT{database_file_picker_choose_button}</a></div>`
							. qq`</div>\n`;
					}
					$value .= qq`<div class="empty_placeholder">$TEXT{database_file_picker_no_files_label}</div>` if !@$filenames;
					$value .= qq`<input type="hidden" name="encdb_$column" id="encdb_$column" class="$required " />\n`;
					$value .= qq`</div>\n`;
				}
				unless($$file_picker{disable_file_uploader_in_createmode})
				{
					$value .= qq`<div class="encdb_filpkr_upload_label">$TEXT{database_file_picker_upload_files_label}</div>\n<div class="encdb_filpkr_upload" id="encdb_filpkr_upload_$column"><input type="file" name="encdb_upload_$column" id="encdb_upload_$column" class="encdb_fileupload $required" ` . ($$file_picker{disable_multiupload} ? '' : 'multiple="multiple"') . qq` /></div>\n` unless $$file_picker{disable_upload};
				}
			}
			elsif(exists $PREF{"${viewerprefname}_image_picker"}{lc($column)})
			{
				my $image_picker = \%{$PREF{"${viewerprefname}_image_picker"}{lc($column)}};
				my ($link_url, $thumb_url, $filenames) = get_encdb_filepicker_info($image_picker, $viewerprefname, $column);
				$value  = qq`<div class="encdb_imgpkr_wrapper">\n<div class="encdb_imgpkr_chosen_label">$TEXT{database_image_picker_chosen_images_label}</div>\n<div class="encdb_imgpkr_chosen" id="encdb_imgpkr_chosen_$column"><div class="empty_placeholder">$TEXT{database_image_picker_no_images_label}</div></div>\n`;
				$value .= qq`<div class="encdb_imgpkr_all_label">$TEXT{database_image_picker_available_images_label}</div>\n<div class="encdb_imgpkr_all" id="encdb_imgpkr_all_$column">\n`;
				foreach my $image (@$filenames)
				{
					my $css_id = $image; $css_id =~ s!\W!_!g;
					$value .= qq`<div class="encdb_imgpkr_image_block" id="encdb_imgpkr_image_${column}_${css_id}">`
						. qq`<div class="imgpkr_thumb"><a href="$link_url/$image"><img src="$thumb_url/$image" /></a></div>`
						. qq`<div class="imgpkr_text">$image<br /><a href="#" class="encdb_imgpkr_actionlink" onclick="encdb_imgpkr_choose('$column','$image','$css_id'); return false" />$TEXT{database_image_picker_choose_button}</a></div>`
						. qq`</div>\n`;
				}
				$value .= qq`<div class="empty_placeholder">$TEXT{database_image_picker_no_images_label}</div>` if !@$filenames;
				$value .= qq`<input type="hidden" name="encdb_$column" id="encdb_$column" class="$required " />\n`;
				$value .= qq`</div>\n`;
				$value .= qq`<div class="encdb_imgpkr_upload_label">$TEXT{database_image_picker_upload_images_label}</div>\n<div class="encdb_imgpkr_upload" id="encdb_imgpkr_upload_$column"><input type="file" name="encdb_upload_$column" id="encdb_upload_$column" class="encdb_fileupload $required" ` . ($$image_picker{disable_multiupload} ? '' : 'multiple="multiple"') . qq` /></div>\n` unless $$image_picker{disable_upload};
			}
			else
			{
				my $textlength = 'longtext';
				my $force_textarea = $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)};

				$value = $readonly
					? qq`<div class="readonly">$value</div>`
					: (length($value) > 50 || $force_textarea)
					? qq`<textarea name="encdb_$column" class="text $textlength $readonly__still_submitted__class $required" $readonly__still_submitted>$value</textarea>`
					: qq`<input type="text" name="encdb_$column" class="text $readonly__still_submitted__class $required" value="$value" $readonly__still_submitted />`;
			}

			my $percol_css_class = $PREF{"${viewerprefname}_viewer_css_class"}{$column};
			my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
			my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
			my $style = $vertical ? $style_vert : $style_horiz;
			my $vertclass = 'vertcell' if $vertical;
			$output .= qq`<tr class="` . oddeven($i) . qq` vertrow $percol_css_class">` if $vertical;
			$output .= $headers_vert{$column} if $vertical;
			$output .= qq`<td class="col_$column $vertclass" $hidden_cells{$column} $style>$value</td>`;
			$output .= qq`</tr>\n` if $vertical;
			$numcols++;
		}
		$output .= qq`</tr>\n` unless $vertical;

		$output .= qq`<tr class="` . oddeven($i) . qq`">`;
		$output .= qq`<td colspan="$numcols" class="button"><input type="submit" class="button" onclick="encdb_submit('${dbtable}_create_form')" value="$TEXT{database_create_button_2}" /></td>`;
		$output .= qq`</tr>\n`;

		$output .= qq`</table>\n</div>\n`;
		$output .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n`;
		$output .= qq`</form>\n`;
	}
	else
	{
		if($#toggles > 10)
		{
			my @abbreviated_toggles = ();
			for(my $m=0; $m<=$#toggles; $m++)
			{
				if($m == 10) { push @abbreviated_toggles, qq`<a href="#" onclick="toggle_display('encdb_showhide_links','inline'); return false">More...</a> <span id="encdb_showhide_links">`; }
				push @abbreviated_toggles, $toggles[$m];
			}
			push @abbreviated_toggles, qq`<a href="#" onclick="toggle_display('encdb_showhide_links','none'); return false">...Less</a></span>`;
			@toggles = @abbreviated_toggles;
		}
		push @toggles, qq`<a href="#" onclick="reset_visible_cols_cookie_for_this_page(); return false">Reset</a>`;
		my $tblclass = '';
		if($editmode)	{ $tblclass = $vertical ? ' enc_dbedit_tbl_vert' : ' enc_dbedit_tbl_horiz'; $tblclass .= ' enc_edit_tbl'; }
		else		{ $tblclass = $vertical ? ' enc_dbview_tbl_vert' : ' enc_dbview_tbl_horiz'; }
		my $quicksort_class = quicksort_is_active() ? 'enc_sortable' : '';
		$output .= qq`<form id="${dbtable}_edit_form" onsubmit="return encdb_submit('${dbtable}_edit_form')" accept-charset="UTF-8" method="post" enctype="multipart/form-data" action="$ENV{SCRIPT_NAME}?$qs" style="margin: 0; padding: 0;">\n` if $editmode;
		$output .= qq`<div id="columntoggles">Show/hide: ` . (join ' &nbsp; ', @toggles) . qq`</div>\n` unless $PREF{"${viewerprefname}_viewer_hide_column_toggles"} =~ /yes/i;
		$output .= qq`<div id="${dbtable}_table" class="enc_tbl enc_db_tbl $tblclass">\n<table class="$quicksort_class" id="db_viewer_table">\n` unless $vertical;
		$output .= qq`<tr class="headers">$headers_horiz_string</tr>\n` unless $vertical;

		# 20090429: changed the query from this:
		#
		#	SELECT * FROM `$dbtable` LIMIT $sql_range_start, $range_end
		#
		# ...to this:
		#
		#	SELECT * FROM `$dbtable` $DESC LIMIT $sql_range_start, $range_end
		#
		# ...where $DESC = $reverse ? 'ORDER BY `id` DESC' : ''.
		# This is so that, when sorting in reverse with multiple pages of records (with
		# for example 25 records per page), page #1 shows the *last* 25 records, rather
		# than the first 25 but in reverse order.  But, shouldn't we be using $sortkey,
		# as in the original now-commented-out query, rather than hard-coding it to `id`?

		my $sortkey = $qs =~ /(?:^|&)sort=(\w+?)(?:&|$)/ ? $1
			: $PREF{"${viewerprefname}_viewer_default_sort_field"} ? $PREF{"${viewerprefname}_viewer_default_sort_field"} 
			: exists $columns{id} ? 'id'
			: $firstcol;
		my $reverse =   $qs =~ /(?:^|&)reverse=1(?:&|$)/   ||   ($PREF{"${viewerprefname}_viewer_default_sort_is_reversed"} == 1 && $qs !~ /(?:^|&)reverse=0(?:&|$)/)   ? 1 : 0;
		#my $DESC = $reverse ? 'ORDER BY `id` DESC' : '';
		my $DESC = $reverse ? 'DESC' : '';
		enc_urldecode($sortkey);
		die_unless_sqlsafe($sortkey);

		# 20110823: moving the querystring-based result restriction logic up here, so we can
		# make it part of the actual SQL query, and thus have the result count and pagination
		# numbers etc be correct, as opposed to before when this was done just after the SQL
		# query by simply hiding (skipping) result rows that didn't match the qs-specified
		# restrictions.
		#
		unless(get_qs_var('disable_url_filters') eq 'yes')
		{
			foreach my $column (split(/,/, $column_list))
			{
				if($qs =~ /(?:^|&)$column(@)?=([^&]*)(?:&|$)/i   &&   get_qs_var("filter$column") ne 'no')
				{
					my $approx = $1;
					my $url_specified_value = $2;
					enc_urldecode($url_specified_value);
					sql_untaint($url_specified_value);
					die_unless_sqlsafe($url_specified_value);
					$selection_restrictions .= $selection_restrictions ? " AND " : " WHERE ";
					$selection_restrictions .= $approx ? "`$column` LIKE '%$url_specified_value%'" : "`$column` = '$url_specified_value'";
					$qs_filters{$column} = $url_specified_value;
				}
			}
		}

		# 20120515: in editmode, we'll fail to display the record if the specified record
		# ID doesn't fall within the page range specified by page=X on the URL -- or if
		# there is no page=X on the URL, in which case the range defaults to 0,10 which
		# means editing any record beyond the first 10 IDs would fail.  This occurs for
		# example when someone clicks a comment moderation link in a comment notification
		# email from FileChucker: that link contains the ID to edit, but no page=X.  So,
		# since we don't actually care about ranges when editing a single record anyway,
		# we'll just use a selection restriction and bypass the range.
		#
		if($editmode)
		{
			$selection_restrictions .= $selection_restrictions ? ' AND ' : ' WHERE ';
			$selection_restrictions .= "`id` = $row_id_to_edit";
		}

		while($qs =~ /(?:^|&)srch([123])_([^=]+)=([^&]+)/g)
		{
			my ($srchmode, $srchfield, $srchvalue) = ($1, $2, $3);
			$srchvalue = enc_urldecode_return($srchvalue);
			sql_untaint($srchfield,$srchvalue);
			die_unless_sqlsafe($srchfield,$srchvalue);
			$selection_restrictions .= $selection_restrictions ? " AND " : " WHERE ";
			if($srchmode == 1) # exact.
			{
				$selection_restrictions .= "`$srchfield` = '$srchvalue'";
			}
			elsif($srchmode == 2) # partial.
			{
				$selection_restrictions .= "`$srchfield` LIKE '%$srchvalue%'";
			}
			elsif($srchmode == 3) # invert.
			{
				$selection_restrictions .= "`$srchfield` NOT LIKE '%$srchvalue%'";
			}
		}
		
		#my $rows = enc_sql_select_multi("SELECT * FROM `$dbtable` ORDER BY `$sortkey` LIMIT $sql_range_start, $range_end");
		my $LIMIT = $editmode ? '' : "LIMIT $sql_range_start, $itemsperpage";
		my $mainquery = "SELECT * FROM `$dbtable` $selection_restrictions ORDER BY `$sortkey` $DESC $LIMIT";
		encdebug "query: $mainquery";
		my $rows = enc_sql_select_multi($mainquery);

		# Do a first pass so we can perform value_transforms, so the values are
		# set and then we can do the sorting properly in the second pass.
		#
		foreach my $row (keys %$rows)
		{
			# Actually, do this first pass twice, because we might need to interpolate
			# a variable value from a late column into an early column, which won't be
			# set the first time through.
			#
			my %already_transformed = ();
			foreach my $pass (1,2)
			{
				foreach my $column (split(/,/, $column_list))
				{
					#next if $disabled_columns{$column}; # actually, don't skip disabled cols here; we want their values to be available for transforms for other cols.
					my $value = exists $$extra_columns{$column} ? $$extra_columns{$column}{value} : $$rows{$row}{$column};
					$$rows{$row}{"${column}___raw"} = $value if $pass==1;
					if((my $code = $$viewer_value_transforms{$column})   &&   $qs !~ /(^|&)raw$column=yes(&|$)/i)
					{
						transform_value_according_to_code($dbtable, $value, \%{$$rows{$row}}, $code, $column, $pass, \%already_transformed);
					}
					elsif((my $code = $PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{lc($column)})   &&   $qs !~ /(^|&)raw$column=yes(&|$)/i)
					{
						transform_value_according_to_code($dbtable, $value, \%{$$rows{$row}}, $code, $column, $pass, \%already_transformed);
					}
					else
					{
						$$rows{$row}{$column} = $value;
					}
				}
			}
		}

		my $there_was_some_output = 0;
		my $numcols = 0;
		my $i = 1;
		my %prev_row = ();
		foreach my $row (sort
		{
			  $$rows{$a}{$sortkey} =~ /^\d*$/ && $$rows{$b}{$sortkey} =~ /^\d*$/ && $reverse	? lc($$rows{$b}{$sortkey}) <=> lc($$rows{$a}{$sortkey})
			: $$rows{$a}{$sortkey} =~ /^\d*$/ && $$rows{$b}{$sortkey} =~ /^\d*$/			? lc($$rows{$a}{$sortkey}) <=> lc($$rows{$b}{$sortkey})
			: $reverse										? lc($$rows{$b}{$sortkey}) cmp lc($$rows{$a}{$sortkey})
			: 											  lc($$rows{$a}{$sortkey}) cmp lc($$rows{$b}{$sortkey})
		}
		keys %$rows)
		{
			my $failed_to_match_url_spec = my $row_is_hidden_via_value_regex = 0;
			foreach my $column (split(/,/, $column_list))
			{
				if(exists $PREF{"${viewerprefname}_viewer_hidden_values_regex"}{lc($column)} && $qs !~ /showhiddenrows=true/)
				{
					my $regex = $PREF{"${viewerprefname}_viewer_hidden_values_regex"}{lc($column)};
					$row_is_hidden_via_value_regex ||= $regex && $$rows{$row}{$column} =~ /($regex)/i;
				}
			}
			next if $failed_to_match_url_spec || $row_is_hidden_via_value_regex;

			next if $editmode && $$rows{$row}{id} != $row_id_to_edit;

			$numcols = 0;
			my $oddeven = oddeven($i);
			$output .= qq`<div id="${dbtable}_table" class="enc_tbl enc_db_tbl $tblclass">\n<table>\n` if $vertical;
			$output .= qq`<tr class="$oddeven">` unless $vertical;
			foreach my $column (split(/,/, $column_list))
			{
				next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
				my $value = '';

				if($editmode)
				{
					$value = $$rows{$row}{"${column}___raw"};
					my $transformed_value = $$rows{$row}{$column};

					# If *any* of the columns in this row are specified in _viewer_undeletable_rows,
					# then the whole row must be undeletable, so disable the $allowed_to_delete bit.
					#
					$allowed_to_delete = 0 if exists $PREF{"${viewerprefname}_viewer_undeletable_rows"}{lc($column)}{$value};
					#
					# Or if the table has an "enchddn_undeletable" column, and it's enabled for this
					# row, then disable the $allowed_to_delete bit.
					#
					$allowed_to_delete = 0 if $$rows{$row}{enchddn_undeletable};

					my $required = $PREF{"${viewerprefname}_editmode_required_fields"}{lc($column)} ? 'required' : '';

					my $uneditable_value = exists $PREF{"${viewerprefname}_viewer_uneditable_values"}{lc($column)}{$value};
					my $readonly = $$extra_columns{lc($column)} || $uneditable_columns{lc($column)} || $uneditable_value;
					$readonly = 1 if $value ne $transformed_value && exists $PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{lc($column)};
					$readonly = 1 if exists $$rows{$row}{enchddn_uneditable_cols_in_this_row} && $$rows{$row}{enchddn_uneditable_cols_in_this_row} =~ /$column/i;

					if($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} && !$readonly)
					{
						$value = qq`<input type="checkbox" name="encdb_$column" ` . ($value ? qq`checked="checked"` : '') . qq` class="$required " />`;
					}
					elsif(exists $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} && !$readonly)
					{
						my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
						if($transformed_value =~ /^[01]?$/)
						{
							$value  = qq`<select name="encdb_$column" class="$required ">`
								. qq`<option value="1"` . ($value  ? ' selected="selected"' : '') . qq`>$yes</option>`
								. qq`<option value="0"` . (!$value ? ' selected="selected"' : '') . qq`>$no</option>`
								. qq`</select>`;
						}
						else
						{
							# So we can use a transform to set the displayed value to 'N/A' (for example)
							# if necessary, for cases where the column shouldn't apply at all based on
							# other column values for this row.
							#
							$value = $transformed_value;
						}
					}
					elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)})
					{
						my $dropdown = qq`<select name="encdb_$column" class="$required ">`;
						my $value_is_in_list = 0;
						foreach my $item (split(/\s*\|\|\|\s*/, $list))
						{
							my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
							my $selected = '';
							if($submitted_value eq $value)
							{
								$selected = 'selected="selected"';
								$value_is_in_list = 1;
							}
							$dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
						}
						$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
						$dropdown .= qq`</select>`;
						$value = $dropdown;
					}
					elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)})
					{
						my %allvalues = map { $_ => 1 } split(/\|\|\|/, $value);
						my @boxes = ();
						my $value_is_in_list = 0;
						foreach my $item (split(/\s*\|\|\|\s*/, $list))
						{
							my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
							my $checked = '';
							if($allvalues{$submitted_value})
							{
								$checked = 'checked="checked"';
								$value_is_in_list = 1;
							}
							my $submitted_value_for_paramname = enc_urlencode_return($submitted_value);
							my $boxid = "encdb_multibox_col_${column}_val_${submitted_value_for_paramname}";
							push @boxes, qq`<input type="checkbox" name="$boxid" id="$boxid" $checked class="$required " /><label for="$boxid">$displayed_value</label>`;
						}
						push @boxes, qq`$value (error: not in list!)` if !$value_is_in_list && $value;
						my $separator = $PREF{"db_viewer_multibox_separator___$column"} || $PREF{db_viewer_multibox_separator___global} || '<br />';
						$value = join $separator, @boxes;
					}
					elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)})
					{
						my $item_i = 1;
						my @buttons = ();
						my $value_is_in_list = 0;
						foreach my $item (split(/\s*\|\|\|\s*/, $list))
						{
							my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
							my $checked = '';
							if($submitted_value eq $value)
							{
								$checked = 'checked="checked"';
								$value_is_in_list = 1;
							}
							push @buttons, qq`<input type="radio" name="encdb_$column" id="encdb_radio_${column}_${item_i}" value="$submitted_value" $checked class="$required " /><label for="encdb_radio_${column}_${item_i}">$displayed_value</label>`;
							$item_i++;
						}
						my $separator = $PREF{"db_viewer_radiobutton_separator___$column"} || $PREF{db_viewer_radiobutton_separator___global} || '<br />';
						$value = join $separator, @buttons;
					}
					elsif(my $query = $PREF{"${viewerprefname}_editmode_dropdown_from_SQL"}{lc($column)})
					{
						# The value of this query pref must start with: SELECT foo,bar FROM [...].
						# The first column will be the submitted value and the second the displayed value.

						my ($col1,$col2) = ($query =~ /^SELECT (\w+),(\w+) FROM /);
						my $dropdown = qq`<select name="encdb_$column" class="$required ">`;
						my $value_is_in_list = 0;
						my $results = enc_sql_select_multi($query);
						foreach my $k (sort { $a <=> $b } keys %$results)
						{
							my $submitted_value = $$results{$k}{$col1};
							my $displayed_value = $$results{$k}{$col2};
							my $selected = '';
							if($submitted_value eq $value)
							{
								$selected = 'selected="selected"';
								$value_is_in_list = 1;
							}
							$dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
						}
						$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
						$dropdown .= qq`</select>`;
						$value = $dropdown;
					}
					elsif(my $folder = $PREF{"${viewerprefname}_file_list"}{lc($column)})
					{
						my @files = get_all_files($folder);
						my $dropdown = qq`<select name="encdb_$column" class="$required ">`;
						my $value_is_in_list = 0;
						foreach my $file (@files)
						{
							my $selected = '';
							if($file eq $value)
							{
								$selected = 'selected="selected"';
								$value_is_in_list = 1;
							}
							$dropdown .= qq`<option value="$file" $selected>$file</option>`;
						}
						$dropdown .= qq`<option selected="selected" value="$value">$value (error: file does not exist!)</option>` if !$value_is_in_list && $value;
						$dropdown .= qq`</select>`;
						$value = $dropdown;
					}
					elsif(exists $PREF{"${viewerprefname}_file_picker"}{lc($column)})
					{
						my $file_picker = \%{$PREF{"${viewerprefname}_file_picker"}{lc($column)}};
						unless($$file_picker{disable_existing_file_chooser_in_editmode})
						{
							my ($link_url, undef, $filenames) = get_encdb_filepicker_info($file_picker, $viewerprefname, $column);
							my $dbvalue = $value;
							my @chosen_filenames = split(/:::::/, $dbvalue);
							$value = qq`<div class="encdb_filpkr_wrapper">\n<div class="encdb_filpkr_chosen_label">$TEXT{database_file_picker_chosen_files_label}</div>\n<div class="encdb_filpkr_chosen" id="encdb_filpkr_chosen_$column">`;
							if(@chosen_filenames)
							{
								foreach my $file (@chosen_filenames)
								{
									my $css_id = $file; $css_id =~ s!\W!_!g;
									$value .= qq`<div class="encdb_filpkr_file_block" id="encdb_filpkr_file_chosen_${column}_${css_id}">`
										. ($PREF{database_file_picker_file_icon} ? qq`<div class="filpkr_icon"><a href="$link_url/$file"><img src="$PREF{database_file_picker_file_icon}" /></a></div>` : undef)
										. qq`<div class="filpkr_text">$file<br /><a href="#" class="encdb_filpkr_actionlink" onclick="encdb_filpkr_unchoose('$column','$file','$css_id'); return false" />$TEXT{database_file_picker_remove_button}</a></div>`
										. qq`</div>\n`;
								}
							}
							else
							{
								$value .= qq`<div class="empty_placeholder">$TEXT{database_file_picker_no_files_label}</div>`;
							}
							$value .= qq`</div>\n`;
							$value .= qq`<div class="encdb_filpkr_all_label">$TEXT{database_file_picker_available_files_label}</div>\n<div class="encdb_filpkr_all" id="encdb_filpkr_all_$column">\n`;
							foreach my $file (@$filenames)
							{
								my $css_id = $file; $css_id =~ s!\W!_!g;
								$value .= qq`<div class="encdb_filpkr_file_block" id="encdb_filpkr_file_${column}_${css_id}">`
									. ($PREF{database_file_picker_file_icon} ? qq`<div class="filpkr_icon"><a href="$link_url/$file"><img src="$PREF{database_file_picker_file_icon}" /></a></div>` : undef)
									. qq`<div class="filpkr_text">$file<br /><a href="#" class="encdb_filpkr_actionlink" onclick="encdb_filpkr_choose('$column','$file','$css_id'); return false" />$TEXT{database_file_picker_choose_button}</a></div>`
									. qq`</div>\n`;
							}
							$value .= qq`<div class="empty_placeholder">$TEXT{database_file_picker_no_files_label}</div>` if !@$filenames;
							$value .= qq`<input type="hidden" name="encdb_$column" id="encdb_$column" class="$required" value="$dbvalue" />\n`;
							$value .= qq`</div>\n`;
						}
						unless($$file_picker{disable_file_uploader_in_editmode})
						{
							$value .= qq`<div class="encdb_filpkr_upload_label">$TEXT{database_file_picker_upload_files_label}</div>\n<div class="encdb_filpkr_upload" id="encdb_filpkr_upload_$column"><input type="file" name="encdb_upload_$column" id="encdb_upload_$column" class="encdb_fileupload $required" ` . ($$file_picker{disable_multiupload} ? '' : 'multiple="multiple"') . qq` /></div>\n` unless $$file_picker{disable_upload};
						}
					}
					elsif(exists $PREF{"${viewerprefname}_image_picker"}{lc($column)})
					{
						my $image_picker = \%{$PREF{"${viewerprefname}_image_picker"}{lc($column)}};
						my ($link_url, $thumb_url, $filenames) = get_encdb_filepicker_info($image_picker, $viewerprefname, $column);
						my $dbvalue = $value;
						my @chosen_filenames = split(/:::::/, $dbvalue);
						$value = qq`<div class="encdb_imgpkr_wrapper">\n<div class="encdb_imgpkr_chosen_label">$TEXT{database_image_picker_chosen_images_label}</div>\n<div class="encdb_imgpkr_chosen" id="encdb_imgpkr_chosen_$column">`;
						if(@chosen_filenames)
						{
							foreach my $image (@chosen_filenames)
							{
								my $css_id = $image; $css_id =~ s!\W!_!g;
								$value .= qq`<div class="encdb_imgpkr_image_block" id="encdb_imgpkr_image_chosen_${column}_${css_id}">`
									. qq`<div class="imgpkr_thumb"><a href="$link_url/$image"><img src="$thumb_url/$image" /></a></div>`
									. qq`<div class="imgpkr_text">$image<br /><a href="#" class="encdb_imgpkr_actionlink" onclick="encdb_imgpkr_unchoose('$column','$image','$css_id'); return false" />$TEXT{database_image_picker_remove_button}</a></div>`
									. qq`</div>\n`;
							}
						}
						else
						{
							$value .= qq`<div class="empty_placeholder">$TEXT{database_image_picker_no_images_label}</div>`;
						}
						$value .= qq`</div>\n`;
						$value .= qq`<div class="encdb_imgpkr_all_label">$TEXT{database_image_picker_available_images_label}</div>\n<div class="encdb_imgpkr_all" id="encdb_imgpkr_all_$column">\n`;
						foreach my $image (@$filenames)
						{
							my $css_id = $image; $css_id =~ s!\W!_!g;
							$value .= qq`<div class="encdb_imgpkr_image_block" id="encdb_imgpkr_image_${column}_${css_id}">`
								. qq`<div class="imgpkr_thumb"><a href="$link_url/$image"><img src="$thumb_url/$image" /></a></div>`
								. qq`<div class="imgpkr_text">$image<br /><a href="#" class="encdb_imgpkr_actionlink" onclick="encdb_imgpkr_choose('$column','$image','$css_id'); return false" />$TEXT{database_image_picker_choose_button}</a></div>`
								. qq`</div>\n`;
						}
						$value .= qq`<div class="empty_placeholder">$TEXT{database_image_picker_no_images_label}</div>` if !@$filenames;
						$value .= qq`<input type="hidden" name="encdb_$column" id="encdb_$column" class="$required" value="$dbvalue" />\n`;
						$value .= qq`</div>\n`;
						$value .= qq`<div class="encdb_imgpkr_upload_label">$TEXT{database_image_picker_upload_images_label}</div>\n<div class="encdb_imgpkr_upload" id="encdb_imgpkr_upload_$column"><input type="file" name="encdb_upload_$column" id="encdb_upload_$column" class="encdb_fileupload $required" ` . ($$image_picker{disable_multiupload} ? '' : 'multiple="multiple"') . qq` /></div>\n` unless $$image_picker{disable_upload};
					}
					else
					{
						$value = $transformed_value if $readonly; # display the transformed value, instead of the raw value, if it's not editable.
						$value = $transformed_value if $PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{lc($column)};

						$value =~ s!"!&quot;!g unless $readonly;
						my $textlength = length($value) < 50 ? 'shorttext' : length($value) < 200 ? 'mediumtext' : 'longtext';
						my $force_textarea = $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)};

						if(!$value && exists $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)})
						{
							$value = $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)};
						}

						if(datatype_is_binary($dbtable, $column)) { $value = '[binary data]'; $readonly = 1; }

						$value = $readonly
							? qq`<div class="readonly">$value</div>`
							: (length($value) > 50 || $force_textarea)
							? qq`<textarea name="encdb_$column" class="text $textlength $required">$value</textarea>`
							: qq`<input type="text" name="encdb_$column" class="text $required" value="$value" />`;
					}
				}
				else
				{
					if(get_qs_var("raw$column") eq 'yes')
					{
						$value = $$rows{$row}{"${column}___raw"};
					}
					else
					{
						$value = $$rows{$row}{$column};

						# Value processing:
						#
						if($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)})
						{
							$value = $value ? $TEXT{boolean_true_string} : $TEXT{boolean_false_string};
						}
						elsif($PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)})
						{
							my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
							$value = $value == 1 ? $yes : $value =~ /^0?$/ ? $no : $value;
						}
						elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)})
						{
							foreach my $item (split(/\s*\|\|\|\s*/, $list))
							{
								my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
								$value = $displayed_value if $submitted_value eq $value;
							}
						}
						elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)})
						{
							my %allvalues = map { $_ => 1 } split(/\|\|\|/, $value);
							my @boxes = ();
							foreach my $item (split(/\s*\|\|\|\s*/, $list))
							{
								my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
								push(@boxes, $displayed_value) if $allvalues{$submitted_value};
							}
							my $sep = $PREF{"${viewerprefname}_viewer_column_multibox_separator"}{lc($column)} || '<br />';
							$value = join $sep, @boxes;
						}
						elsif(exists $PREF{"${viewerprefname}_file_picker"}{lc($column)})
						{
							my $file_picker = \%{$PREF{"${viewerprefname}_file_picker"}{lc($column)}};
							my ($link_url, undef, $filenames) = get_encdb_filepicker_info($file_picker, $viewerprefname, $column);
							my $sep = $PREF{"${viewerprefname}_file_picker_separator"}{lc($column)} || '<br /><br />';
							my @files = ();
							foreach my $file (split(/:::::/, $value))
							{
								push @files, qq`<a href="$link_url/$file" class="encdb_filpkr_viewmode_link">` . ($PREF{database_file_picker_file_icon} ? qq`<img src="$PREF{database_file_picker_file_icon}" class="encdb_filpkr_viewmode_icon" /> ` : undef) . qq`$file</a>`;
							}
							$value = join $sep, @files;
						}
						elsif(exists $PREF{"${viewerprefname}_image_picker"}{lc($column)})
						{
							my $image_picker = \%{$PREF{"${viewerprefname}_image_picker"}{lc($column)}};
							my ($link_url, $thumb_url, $filenames) = get_encdb_filepicker_info($image_picker, $viewerprefname, $column);
							if($$image_picker{hide_thumbs_in_viewmode})
							{
								my $sep = $PREF{"${viewerprefname}_image_picker_separator"}{lc($column)} || ', ';
								$value = join $sep, split(/:::::/, $value);
							}
							else
							{
								my $sep = $PREF{"${viewerprefname}_image_picker_separator"}{lc($column)} || '<br /><br />';
								my @thumbs = ();
								foreach my $image_filename (split(/:::::/, $value))
								{
									push @thumbs, qq`<a href="$link_url/$image_filename" class="encdb_imgpkr_viewmode_link"><img src="$thumb_url/$image_filename" class="encdb_imgpkr_viewmode_thumb" /></a>`;
								}
								$value = join $sep, @thumbs;
							}
						}

						# Value correction/cleanup:
						#
						my $max_display_length = $PREF{"${viewerprefname}_viewer_percolumn_max_display_length"}{lc($column)} =~ /^(\d+)$/ ? $1 : $display_length;
						if(length($value) > $max_display_length && ($value !~ m!</?\S+>! || $PREF{"${viewerprefname}_viewer_show_HTML_as_code"}{lc($column)})) # don't shorten values containing HTML, b/c it'll break the code.
						{
							my $abbreviated_value = $value;
							$abbreviated_value =~ s/^(.{$max_display_length}).*/$1.../s;
							$value =~ s/"/\\"/g;
							$value = $PREF{"${viewerprefname}_viewer_show_HTML_as_code"}{lc($column)} ? $abbreviated_value : qq`<span title="$value">$abbreviated_value</span>`;
						}
						if(!$value && exists $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)})
						{
							$value = $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)};
						}
						if($PREF{"${viewerprefname}_viewer_show_HTML_as_code"}{lc($column)})
						{
							$value =~ s/</&lt;/g;
							$value =~ s/>/&gt;/g;
						}
						if(datatype_is_binary($dbtable, $column))
						{
							if($column =~ /(image|thumb|photo)/i)
							{
								if($PREF{"${viewerprefname}_viewer_disable_smallimage_display"}{lc($column)})
								{
									$value = '[binary data]' if $value;
								}
								else
								{
									my $image_url = $PREF{REQ_URI_WITH_QS} . "&subaction=dbdownload&dbcol=$column&dbid=" . $$rows{$row}{id};
									$value = qq`<img src="$image_url" class="enc_dbview_thumb" />` if $value;
								}
							}
							else
							{
								$value = '[binary data]' if $value;
							}
						}
						$value =~ s!\n!<br />\n!g;
					}

					$value = '' if $PREF{"${viewerprefname}_viewer_hide_consecutive_dupes"} && ($value eq $prev_row{$column}) && !$vertical;

					unless($$extra_columns{edit} && ($numcols == 0))
					{
						my $csv_value = $$rows{$row}{"${column}___raw"};
						$csv_value =~ s!,!ENCODEDCOMMA!g if $PREF{use_placeholder_for_real_commas_in_CSV_DB_data} eq 'yes';
						$csv_value =~ s!\n!ENCODEDNEWLINE!g;
						if($PREF{convert_HTML_to_ASCII_in_CSV_DB_data} ne 'no')
						{
							$csv_value =~ s!&quot;!"!g;
							$csv_value =~ s!&#39;!'!g;
						}
						if($PREF{show_sizes_in_KB_in_CSV_DB_data} ne 'no'   &&   $column =~ /size/i   &&   $csv_value =~ /^\d+$/)
						{
							$csv_value = int($csv_value / 1024);
							$csv_value .= ' ' . $PREF{KB};
						}
						$csv_value = '"'.$csv_value.'"' unless $PREF{quote_all_fields_in_CSV_DB_data} eq 'no';
						$csv_output .= $csv_value . ',';
					}

					if(exists $PREF{"${viewerprefname}_viewer_summable_columns"}{$column})
					{
						$PREF{"${viewerprefname}_viewer_summable_columns"}{$column}{sum} += $$rows{$row}{"${column}___raw"};
					}
				}

				my $percol_css_class = $PREF{"${viewerprefname}_viewer_css_class"}{$column};
				my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
				my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
				my $style = $vertical ? $style_vert : $style_horiz;
				my $vertclass = 'vertcell' if $vertical;
				$output .= qq`<tr class="` . oddeven($i) . qq` vertrow $percol_css_class">` if $vertical;
				$output .= $headers_vert{$column} if $vertical;
				$output .= qq`<td class="col_$column $vertclass" $hidden_cells{$column} $style>$value</td>`;
				$output .= qq`</tr>\n` if $vertical;
				$there_was_some_output = 1;
				$numcols++;

				$prev_row{$column} = $value;
			}

			$csv_output =~ s!,$!!; $csv_output .= "\n";   # remove the final trailing comma and add a newline.

			if($vertical)
			{
				$output .= get_db_editor_submit_button($i, $dbtable, $viewerprefname, $numcols, $live_data_fingerprint, $editmode, $allowed_to_create, %hidden_cells);
			}

			$output .= qq`</tr>\n` unless $vertical;
			$output .= qq`</table>\n</div>\n` if $vertical;
		}

		unless($numcols)
		{
			foreach my $column (split(/,/, $column_list))
			{
				next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
				$numcols++;
			}
		}

		if(!$vertical)
		{
			$output .= get_db_editor_submit_button($i, $dbtable, $viewerprefname, $numcols, $live_data_fingerprint, $editmode, $allowed_to_create, %hidden_cells);
			$there_was_some_output = 1 if $editmode || $allowed_to_create;
		}

		unless($there_was_some_output)
		{
			$output .= qq`<div id="${dbtable}_table" class="enc_tbl enc_db_tbl">\n<table>\n` if $vertical;
			$output .= qq`<tr class="` . oddeven($i) . qq`">`;
			$output .= qq`<td colspan="$numcols">$TEXT{no_output_from_database}</td>`;
			$output .= qq`</tr>\n`;
			$output .= qq`</table>\n</div>\n` if $vertical;
		}

		$output .= qq`</table>\n</div>\n` unless $vertical;
		$output .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n` if $editmode;
		$output .= qq`</form>\n` if $editmode;


		if($editmode && $allowed_to_delete)
		{
			$output .= qq`
					<form accept-charset="UTF-8" id="database_deleter" method="post" action="$ENV{SCRIPT_NAME}?$qs&amp;editdelete=true"><div class="enc_tbl enc_db_tbl"><table>
					<tr class="headers"><th>$TEXT{database_deleter_title}</th></tr>
					<tr class="` . oddeven($i) . qq`"><td><input type="checkbox" class="checkbox" name="confirmdeleterecord" id="confirmdeleterecord" /><label for="confirmdeleterecord">` . ($PREF{"${viewerprefname}_record_deletion_warning"} || $TEXT{database_deleter_checkbox}) . qq`</label></td></tr>
					<tr class="` . oddeven($i) . qq`"><td class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_deleter_button}" /></td></tr>
					</table></div>
					<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />
					</form>
			`;
		}


		$output .= qq`

		<script type="text/javascript">

		function toggle_column(theclass)
		{
			var rows = gebi('${dbtable}_table').getElementsByTagName('tr');
			var col_is_hidden = 0;

			var cells = new Array;
			for(i = 0; i < rows.length; i++)
			{
				var headers = rows[i].getElementsByTagName('th');
				for(j = 0; j < headers.length; j++)
				{
					var re = new RegExp('(^| )' + theclass + '( |\$)', "i");
					if(headers[j].className.match(re))
						cells.push(headers[j]);
				}

				var nonheaders = rows[i].getElementsByTagName('td');
				for(j = 0; j < nonheaders.length; j++)
				{
					var re = new RegExp('(^| )' + theclass + '( |\$)', "i");
					if(nonheaders[j].className.match(re))
						cells.push(nonheaders[j]);
				}
			}
			for(i = 0; i < cells.length; i++)
			{
				if(cells[i].style.display == 'none')
				{
					cells[i].style.display = navigator.userAgent.indexOf("MSIE") ==  -1 ? 'table-cell' : 'block'; // IE doesn't support table-cell...
					gebi("link-" + theclass).style.textDecoration = '';
				}
				else
				{
					cells[i].style.display = 'none';
					gebi("link-" + theclass).style.textDecoration = 'line-through';
					col_is_hidden = 1;
				}
			}

			set_visible_cols_cookie(theclass, col_is_hidden);
		}
		
		</script>

		`;
	}


	my $search_form = '';
	if(!$editmode && !$createmode && $PREF{"${viewerprefname}_allowed_to_search"})
	#if(0) # this is in progress.
	{
		$search_form .= qq`<div id="${dbtable}_search_wrapper" class="db_search">\n<div id="search_title" onclick="showhide_element('db_search_form');">Search:</div>\n`;
		$search_form .= qq`<form accept-charset="UTF-8" method="post" id="db_search_form" action="$ENV{SCRIPT_NAME}?$qs" ` . ($qs !~ /(^|&)srch[123]_(\w+)/ ? qq`style="position: absolute; left: -7000px; height: 0; overflow: hidden;"` : '') . qq`>\n`;
		$search_form .= qq`<div id="${dbtable}_search_table" class="not_enc_tbl">\n<table class="" id="db_viewer_search_table">\n` unless $vertical;
		$search_form .= qq`<tr class="headers">%%headers_horiz_local%%</tr>\n` unless $vertical;

		my $i = 0;
		my $numcols = 0;
		my $oddeven = oddeven($i);
		my $headers_horiz_local = '';
		$search_form .= qq`<div id="${dbtable}_search_table" class="db_search">\n<table>\n` if $vertical;
		$search_form .= qq`<tr class="$oddeven">` unless $vertical;
		foreach my $column (split(/,/, $column_list))
		{
			next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
			next if $$extra_columns{$column}{position} == 1 && $column eq 'edit';
			$numcols++;
			
			$headers_horiz_local .= $headers_horiz{$column};

			my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
			my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
			my $style = $vertical ? $style_vert : $style_horiz;
			my $vertclass = 'vertcell' if $vertical;
			$search_form .= qq`<tr class="$oddeven vertrow">` if $vertical;
			$search_form .= $headers_vert{$column} if $vertical;
			
			$search_form .= qq`<td class="col_$column $vertclass" $hidden_cells{$column} $style><input type="text" class="srch_text" name="srch_$column" value="` . (get_qs_var("srch1_$column") || get_qs_var("srch2_$column") || get_qs_var("srch3_$column")) . qq`" />`;
			$search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_1" value="1" ` . ($qs =~ /(^|&)srch1_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_1">Exact match</label>`;
			$search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_2" value="2" ` . ($qs =~ /(^|&)srch2_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_2">Partial match</label>`;
			$search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_3" value="3" ` . ($qs =~ /(^|&)srch3_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_3">Don't match</label>`;
			$search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_4" value="4" ` . ($qs !~ /(^|&)srch[123]_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_4">Unused</label>`;
			$search_form .= qq`</td>`;
			
			$search_form .= qq`</tr>\n` if $vertical;
		}
		$search_form =~ s!%%headers_horiz_local%%!$headers_horiz_local!;

		if(!$vertical)
		{
			$search_form .= qq`</tr>\n`; # unless $vertical;
		}

		#$search_form .= qq`<tr class="` . oddeven($i) . qq` enc_sortbottom">`;
		#$search_form .= qq`<td colspan="$numcols" class="search"><input type="submit" value="$TEXT{database_search_button}" /></td>`;
		#$search_form .= qq`</tr>\n`;
		#
		#$search_form .= qq`</table>\n</div>\n`;

		my $search_reset_url = $qs;
		$search_reset_url =~ s!(^|&)srch[1234]_[^=]+=[^&]+!!g;
		defooify('&', $search_reset_url);
		$search_reset_url = $PREF{REQ_URI_SANS_QS} . '?' . $search_reset_url;

		$search_form .= qq`</table>\n<input type="submit" value="$TEXT{database_search_button}" />\n`;
		$search_form .= qq`<input type="button" name="db_search_form_reset_button" id="db_search_form_reset_button" value="Reset" onclick='if(window.confirm("Really clear the search form?")) { location.href="$search_reset_url"; }' />\n`;
		$search_form .= qq`</div>\n`;

		$search_form .= qq`<input type="hidden" name="searchmode" value="true" />\n`;
		$search_form .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n`;
		$search_form .= qq`</form>\n</div>\n`;
	}


	$template =~ s!%%output%%!$output!;

	my $uri = $ENV{REQUEST_URI};
	$uri =~ s/(\?|&)dbview=(horiz|vert)/$1/gi;
	defooify('&', $uri);
	my $horizlink	= $uri . ($uri =~ /\?/ ? '&' : '?') . qq`dbview=horiz`;
	my $vertlink	= $uri . ($uri =~ /\?/ ? '&' : '?') . qq`dbview=vert`;
	$uri = $ENV{REQUEST_URI};
	$uri =~ s!editdelete=true!!g;
	$uri =~ s!(edit|create)mode=true!!g;
	$uri =~ s!editid=\d+!!g;
	clean_database_url($uri);
	defooify('&',$uri);
	defooify('\?',$uri);

	my @template_viewcontrols_pruned = ();
	for(@template_viewcontrols)
	{
		if($PREF{"${viewerprefname}_viewer_forced_mode"} =~ /horiz|vert/)
		{
			s!%%(?:horiz|vert)link:text=([^%]+)%%!!g;
		}
		else
		{
			s!%%horizlink:text=([^%]+)%%!$vertical ? qq`<a href="$horizlink">$1</a>` : $1!eg;
			s!%%vertlink:text=([^%]+)%%!$vertical ? $1 : qq`<a href="$vertlink">$1</a>`!eg;
		}

		s!%%viewalllink:text=([^%]+)%%!$editmode || $createmode ? qq`<a href="$uri">$1</a>` : ''!eg;

		push(@template_viewcontrols_pruned, $_) if $_;
	}

	my $filter_note = '';
	if(%qs_filters)
	{
		$filter_note = qq`Using filters from your URL variables: `;
		foreach my $col (sort keys %qs_filters)
		{
			$filter_note .= qq`$col=$qs_filters{$col}, `;
		}
		$filter_note =~ s!, $!!;
		$filter_note .= qq`<br />Pass ?filter\$fieldname=no to disable one, or disable_url_filters=yes to disable them all.`;
	}

	# For example:   %%%if-whence%%% %%whencelink:text=Back To Fields List%% | %%%end-whence%%%
	#
	$template =~ s!%%whencelink:text=([^%]+)%%!$PREF{dbvwrwhence} ? qq`<a href="$PREF{dbvwrwhence}">$1</a>` : ''!eg;
	$template =~ s!%%%if-whence%%%(.*?)%%%end-whence%%%!$PREF{dbvwrwhence} ? $1 : ''!egs;

	$template =~ s!%%%if-db_view_controls%%%(.*?)%%%end-db_view_controls%%%!@template_viewcontrols_pruned ? $1 : ''!egs;
	$template =~ s!%%db_view_controls%%!join $template_viewcontrols_sep, @template_viewcontrols_pruned!egs;

	$template =~ s!%%%if-qs_filters%%%(.*?)%%%end-qs_filters%%%!$filter_note ? $1 : ''!egs;
	$template =~ s!%%filter_note%%!$filter_note!g;

	my $numitems = enc_sql_select("SELECT COUNT(*) FROM `$dbtable` $selection_restrictions");
	my $pagelinks = get_pagination_links_mark2( { range_start => $range_start, range_end => $range_end, num_items => $numitems, items_per_page => $itemsperpage, itemname_singular => $PREF{"${viewerprefname}_viewer_item_name"}, itemname_plural => $PREF{"${viewerprefname}_viewer_item_name_plural"}, hide_when_single_page => $PREF{"${viewerprefname}_viewer_hide_footer_pagelinks_when_singlepage"} } ) unless $createmode || $editmode;
	$template =~ s!%%%if-pagelinks%%%(.*?)%%%end-pagelinks%%%!$pagelinks ? $1 : ''!egs;
	$template =~ s!%%pagelinks%%!$pagelinks!g;
	$template =~ s!%%search_form%%!$search_form!g;
	$template =~ s!%%itemname_plural%%!$PREF{"${viewerprefname}_viewer_item_name_plural"}!g;
	$template =~ s!%%serverdate%%!'<p class="encserverdate">Server date: ' . date14() . '</p>'!eg;
	$template =~ s!%%csv_link%%!$editmode || $createmode ? undef : qq`<p class="enccsvlink"><a href="$ENV{SCRIPT_NAME}?$qs&amp;csvdownload=true">Download CSV</a></p>`!eg;

	my $footer_misc = '';
	foreach my $col (sort keys %{$PREF{"${viewerprefname}_viewer_summable_columns"}})
	{
		$footer_misc .= "<strong>Sums:</strong> $col: " . $PREF{"${viewerprefname}_viewer_summable_columns"}{$col}{sum} . "&nbsp; &nbsp; &nbsp; ";
	}
	$template =~ s!%%footer_misc%%!<p class="encfootermisc">$footer_misc</p>!;

	if(get_qs_var('srchvrfymode') eq 'true')
	{
		my $go = $there_were_some_results ? $PREF{"${viewerprefname}_search_verify_mode_redirection_url_for_matches"} : $PREF{"${viewerprefname}_search_verify_mode_redirection_url_for_misses"};;
		my %searchterms = ();
		while($qs =~ /(?:^|&)srch[123]_([^=]+)=([^&]+)/g)
		{
			$searchterms{$1} = $2;
		}
		$go =~ s!%%(\w+)%%!$searchterms{$1}!g;
		if($go)
		{
			enc_redirect($go);
		}
		else
		{
			my $srchmatch = $TEXT{db_search_verify_mode_match_text} || qq`Your search found a match.`;
			my $srchmiss = $TEXT{db_search_verify_mode_miss_text} || qq`Your search found no match.`;
			exit_with_notice($there_were_some_results ? $srchmatch : $srchmiss);
		}
	}

	# This is down here, instead of further up, because we want to allow the allowed_to_search
	# permission to allow access in the case where the search is just returning a matched/failed
	# result (not returning any actual database rows for viewing).  For example, in the situation
	# where a customer needs to be able to look up a license number, registration code, coupon
	# code, etc, and the site owner wants to allow that, but only for verification purposes, not
	# to display the database search result rows to the customer.
	#
	exit_with_needprivs() unless $allowed_to_view;

	if($QS{csvdownload} eq 'true')
	{
		my $csvfilename = $ENV{HTTP_HOST} . '-' . $QS{action} . '-' . date14();
		$csvfilename =~ s!\.!!g;
		$csvfilename .= '.csv';

		print	  qq`Content-Type: text/plain\n`
			. qq`Content-Disposition: attachment; filename="$csvfilename"\n`
			. qq`Content-Length: ` . length($csv_output) . qq`\n`
			. "\n"
			. $csv_output;

		exit;
	}

	return $template;
}


sub get_db_editor_submit_button
{
	my (undef, $dbtable, $viewerprefname, $numcols, $live_data_fingerprint, $editmode, $allowed_to_create, %hidden_cells) = @_;
	# Using $_[0] for $i so that its value is updated in the caller.
	my $output = '';

	if($editmode)
	{
		$output .= qq`<tr class="` . oddeven($_[0]) . qq`">`;
		$output .= qq`<td colspan="$numcols" class="button">$PREF{"${viewerprefname}_editmode_save_button_note"}`;
		$output .= qq`<input type="hidden" id="all_cols_toggled" value="0" /><input type="button" onclick="encdb_toggle_all_columns('${dbtable}_edit_form')" id="toggle_all_cols" value="$TEXT{database_toggle_cols_button}" />` if %hidden_cells;
		$output .= qq`<input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" onclick="encdb_submit('${dbtable}_edit_form')" value="$TEXT{database_save_button}" /></td>`;
		$output .= qq`</tr>\n`;
	}
	elsif($allowed_to_create)
	{
		$output .= qq`<tr class="` . oddeven($_[0]) . qq` enc_sortbottom">`;
		$output .= qq`<td colspan="$numcols" class="addnew"><a href="$PREF{REQ_URI_SANS_QS}?$qs&amp;createmode=true&amp;dbview=vert">$TEXT{database_create_button}</a></td>`;
		$output .= qq`</tr>\n`;
	}

	return $output;
}


sub get_encdb_filepicker_info($$$)
{
	my ($filepicker, $viewerprefname, $column) = @_;
	my $type = $PREF{"${viewerprefname}_image_picker"}{lc($column)} ? 'image' : 'file';
	my $foldername = $viewerprefname . '_' . lc($column);
	$foldername =~ s!\W!_!g;

	my $urlpath = $$filepicker{link_url} || $PREF{appdir_url} . '/' . $foldername;
	my $realpath = $PREF{DOCROOT} . $urlpath;
	create_dir_if_DNE($realpath, $PREF{writable_dir_perms}, 'make_parents');

	my $thumb_urlpath = $$filepicker{thumb_url} || $urlpath . '/thumbs/' . ($$filepicker{thumb_size} || 80) . 'px';
	my $thumb_realpath = $PREF{DOCROOT} . $thumb_urlpath;
	create_dir_if_DNE($thumb_realpath, $PREF{writable_dir_perms}, 'make_parents') if $type eq 'image';

	my @filenames = get_all_files($realpath);
	return ($urlpath, $thumb_urlpath, \@filenames);
}


sub process_encdb_filepicker_post($$$$)
{
	my ($viewerprefname, $column, $wholequery, $field_value) = @_;
	my ($picker,$type) = $PREF{"${viewerprefname}_image_picker"}{lc($column)} ? (\%{$PREF{"${viewerprefname}_image_picker"}{lc($column)}}, 'image') : (\%{$PREF{"${viewerprefname}_file_picker"}{lc($column)}}, 'file');
	my ($link_url, $thumb_url, $filenames) = get_encdb_filepicker_info($picker, $viewerprefname, $column);
	my @uploaded_files = handle_file_upload({ query => $wholequery, upload_field_name => "encdb_upload_$column", output_path => "$PREF{DOCROOT}/$link_url", lowercase_filenames => 1, cleanup_filenames => 1, allowed_extensions => $$picker{allowed_extensions} || $PREF{database_file_picker_default_allowed_file_types} });
	my $uploaded_files = join(':::::', @uploaded_files);

	if($type eq 'image')
	{
		foreach my $filename (@uploaded_files)
		{
			do_batch_resizing({ input_file_full => "$PREF{DOCROOT}/$link_url/$filename", create_resized_copy_01_size => $$picker{thumb_size}, create_resized_copy_01_output_dir_full => "$PREF{DOCROOT}/$thumb_url", other_sizes => $$picker{other_sizes}, });
		}
	}

	my $chosen_files = $field_value;
	return $chosen_files && $uploaded_files ? "${chosen_files}:::::${uploaded_files}" : $chosen_files ? $chosen_files : $uploaded_files;
}


sub send_notification_emails_for_database_update($)
{
	my $details_ref = shift; my %details = %$details_ref;

	my $viewerprefname	= $details{viewerprefname};
	my $recipients		= $PREF{"${viewerprefname}_emailalert_recipients"};
	my $from		= $PREF{"${viewerprefname}_emailalert_sender"};
	my $subject		= $PREF{"${viewerprefname}_emailalert_subject"};
	my $body		= $PREF{"${viewerprefname}_emailalert_body"};
	my $format		= $PREF{"${viewerprefname}_emailalert_type"};
	my $failure_action	= $PREF{"${viewerprefname}_emailalert_failure_action"};

	my $changes_rows = '';
	if($details{changed_record})
	{
		foreach my $col_i (sort { $a <=> $b } keys %{$details{changed_record}})
		{
			my $changes_template = $PREF{"${viewerprefname}_emailalert_changes_template"};
			$changes_template =~ s!%%column%%!$details{changed_record}{$col_i}{column}!g;
			$changes_template =~ s!%%old_value%%!$details{changed_record}{$col_i}{old_value}!g;
			$changes_template =~ s!%%new_value%%!$details{changed_record}{$col_i}{new_value}!g;
			$changes_rows .= $changes_template;
		}
	}

	my $all_rows = '';
	my $sorted_column_list = '';
	my $whole_record = $details{deleted_record} || $details{created_record} || $details{whole_changed_record};
	foreach my $col (sort { lc($a) cmp lc($b) } keys %{$$whole_record{1}})
	{
		$sorted_column_list .= "$col," unless $PREF{"${viewerprefname}_emailalert_fields_to_hide"} =~ /(^|,)\s*$col\s*(,|$)/;

		my $value_for_email = $$whole_record{1}{$col}; $value_for_email =~ s!&lt;!<!g; $value_for_email =~ s!&gt;!>!g;
		s!%FIELD{$col}!$value_for_email!g for($recipients, $from);
	}
	$sorted_column_list = $PREF{"${viewerprefname}_emailalert_fields_to_show"} if $PREF{"${viewerprefname}_emailalert_fields_to_show"};
	decommaify($sorted_column_list);
	foreach my $col (split(/\s*,\s*/, $sorted_column_list))
	{
		my $allrows_template = $PREF{"${viewerprefname}_emailalert_record_template"};
		$allrows_template =~ s!%%column%%!$col!g;
		$allrows_template =~ s!%%value%%!$$whole_record{1}{$col}!g;
		$all_rows .= $allrows_template;
	}

	$body =~ s!%%username%%!$PREF{logged_in_username} || '(unknown)'!eg;
	$body =~ s!%%action%%!$details{action}!g;
	$body =~ s!%%action_pasttense%%!$details{action_pasttense}!g;
	$body =~ s!%%table%%!$details{table}!g;
	$body =~ s!%%record_id%%!$details{record_id}!g;
	$body =~ s!%%db_url%%!$PREF{"${viewerprefname}_viewer_db_url"}!g;
	$body =~ s!%%db_url_full%%!$PREF{"${viewerprefname}_viewer_db_url_full"}!g;
	$body =~ s!%%changes%%!$PREF{"${viewerprefname}_emailalert_changes_header"}$changes_rows!g;
	$body =~ s!%%record%%!$PREF{"${viewerprefname}_emailalert_record_header"}$all_rows!g;

	$body =~ s!%%%if-edit%%%(.*?)%%%endif-edit%%%!$details{action} eq 'edit' ? $1 : $2!egs;
	$body =~ s!%%%ifelse-deletion%%%(.*?)%%%else%%%(.*?)%%%endelse-deletion%%%!$details{action} eq 'delete' ? $1 : $2!egs;
	
	foreach my $to (split(/\s*,\s*/, $recipients))
	{
		if($to eq 'all_members_of_the_loggedin_users_custom_groups')
		{
			foreach my $to_inner (get_email_addresses_for_all_members_of_this_users_groups($PREF{logged_in_userid}))
			{
				send_email($to_inner, $from, $subject, $body, $format, $failure_action);
			}
		}
		else
		{
			send_email($to, $from, $subject, $body, $format, $failure_action);
		}
	}
}


sub get_return_url_for_dbviewer($$)
{
	my $return_url_base = shift;
	my $viewerprefname = shift;
	my $qsl = $qs;
	$qsl =~ s!dbview=(horiz|vert)!!g if $qsl =~ /dbview=horiz/i && $qsl =~ /dbview=vert/i; # if both are present, remove both.
	$qsl =~ s!dbview=vert!!; # we always add 1 dbview=vert on the way to this page, so we should always remove 1 on the way back out.
	$qsl =~ s!editdelete=true!!g;
	$qsl =~ s!editmode=true!!g;
	$qsl =~ s!editid=\d+!!g;
	$qsl =~ s!createmode=true!!g;
	if(exists $PREF{"${viewerprefname}_vars_to_remove_from_redirect_URL"})
	{
		foreach my $var (keys %{ $PREF{"${viewerprefname}_vars_to_remove_from_redirect_URL"} })
		{
			$qsl =~ s!$var=[^&]*!!g;
		}
	}
	defooify('&',$qsl);
	return $return_url_base . ($qsl ? "?$qsl" : '');
}


sub get_database_item($$)
{
	my ($tableprefname,$allowed_to_view) = @_;
	my $dbtable = $PREF{$tableprefname} || $tableprefname; # "$tableprefname" can be the name of the pref OR of the table.
	exit_with_error qq`Access to item denied.` unless $allowed_to_view;

	my $id		= get_qs_var({ var=>'dbid',  maxlength=>10,  notnull=>1, allowedchars=>'\d' });
	my $column	= get_qs_var({ var=>'dbcol', maxlength=>200, notnull=>1, allowedchars=>'\w\.-' });
	my ($data,$type) = enc_sql_select("SELECT `$column`,`${column}_type` FROM `$dbtable` WHERE `id` = $id");
	print "Content-type: " . get_content_type_from_ext($type) . "\n\n";
	print $data;
}


sub get_grouplist_multibox()
{
	my $optsref = shift; my %opts = %$optsref if $optsref;
	my $groups = get_groups_hash();
	my (@builtins, @others) = ();
	foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
	{
		next if $opts{only_paid_groups} && !is_paid_group($group);
		if(is_builtin_group($group) && !$opts{dont_separate_builtins})
		{
			push(@builtins, $$groups{$group}{id} . '///' . '<strong>'.$group.'</strong>');
		}
		else
		{
			push(@others, $$groups{$group}{id} . '///' . $group);
		}
	}
	return join('|||', @builtins) . (@builtins ? '|||' : '') . join('|||', @others);
}


sub get_userlist_multibox()
{
	return '' unless userbase_available();
	my $list = '';
	my $members = get_users_belonging_to_group({ group=>$PREF{member_group_name}, exclude_pending=>1 });
	foreach my $uid (sort { lc($$members{$a}{username}) cmp lc($$members{$b}{username}) } keys %$members)
	{
		$list .= $uid . '///' . $$members{$uid}{username} . '|||';
	}
	$list =~ s!\|\|\|$!!;   # strip the trailing '|||'.
	return $list;
}


sub print_db_table_info
{
	my $table = shift;
	my $sep = shift || "\n";
	foreach my $col(split(/,/, get_db_colnames($table)))
	{
		my $datatype = get_field_datatype($table,$col);
		print "$col: $datatype$sep";
	}
}


sub datatype_is_bool($$)
{
	my ($table,$column) = @_;
	my $datatype = get_field_datatype($table,$column);
	return $datatype =~ /^(bool|tinyint\(1\))/i;
}


sub datatype_is_numeric($$)
{
	my ($table,$column) = @_;
	my $datatype = get_field_datatype($table,$column);
	return $datatype =~ /(decimal|int)\(/i;
}


sub datatype_is_binary($$)
{
	my ($table,$column) = @_;
	my $datatype = get_field_datatype($table,$column);
	return $datatype =~ /blob/i;
}


sub get_field_datatype($$)
{
	my ($table,$column) = @_;
	sql_untaint($table,$column);
	die_unless_sqlsafe($table,$column);

	# This fails on some older MySQL versions, which apparently don't allow the WHERE clause
	# on the SHOW COLUMNS query.  So we'll have to return all columns and manually search them.
	#my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table` WHERE `field` = '$column'");
	#return $$coltypetest{1}{Type} || $$coltypetest{1}{type};

	my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table`");
	foreach my $j (keys %$coltypetest)
	{
		return ($$coltypetest{$j}{Type} || $$coltypetest{$j}{type}) if ($$coltypetest{$j}{Field} =~ /^$column$/i || $$coltypetest{$j}{field} =~ /^$column$/i);
	}
}


sub get_field_details_from_db($$)
{
	my ($table,$column) = @_;
	sql_untaint($table,$column);
	die_unless_sqlsafe($table,$column);

	my %details = ();
	my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table`");
	foreach my $j (keys %$coltypetest)
	{
		 if($$coltypetest{$j}{Field} =~ /^$column$/i || $$coltypetest{$j}{field} =~ /^$column$/i)
		 {
		 	$details{type}		= exists $$coltypetest{$j}{Type}	? $$coltypetest{$j}{Type}	: $$coltypetest{$j}{type};
		 	$details{null}		= exists $$coltypetest{$j}{Null}	? $$coltypetest{$j}{Null}	: $$coltypetest{$j}{null};
		 	$details{key}		= exists $$coltypetest{$j}{Key}		? $$coltypetest{$j}{Key}	: $$coltypetest{$j}{key};
		 	$details{default}	= exists $$coltypetest{$j}{Default}	? $$coltypetest{$j}{Default}	: $$coltypetest{$j}{default};
		 	$details{extra}		= exists $$coltypetest{$j}{Extra}	? $$coltypetest{$j}{Extra}	: $$coltypetest{$j}{extra};
		 	
		 	# For integer types, the returned value will be something like one of the following:
		 	#
		 	#	bigint(20)
		 	#	int(10) unsigned
		 	#
		 	# But the number in parentheses is added by MySQL automatically (i.e. even when you
		 	# don't specify it when creating the column, which you wouldn't in most cases), and
		 	# it is NOT an indicator of the field size, as the MySQL manual explains:
		 	#
		 	#	http://dev.mysql.com/doc/refman/5.0/en/numeric-types.html
		 	#	
		 	#	Numeric Type Attributes
		 	#	
		 	#	MySQL supports an extension for optionally specifying the display width of
		 	#	integer data types in parentheses following the base keyword for the type.
		 	#	For example, INT(4) specifies an INT with a display width of four digits.
		 	#	This optional display width may be used by applications to display integer
		 	#	values having a width less than the width specified for the column by
		 	#	left-padding them with spaces. (That is, this width is present in the
		 	#	metadata returned with result sets. Whether it is used or not is up to the
		 	#	application.)
			#	
			#	The display width does *not* constrain the range of values that can be stored
			#	in the column. Nor does it prevent values wider than the column display width
			#	from being displayed correctly. For example, a column specified as
			#	SMALLINT(3) has the usual SMALLINT range of -32768 to 32767, and values
			#	outside the range permitted by three digits are displayed in full using more
			#	than three digits. 
		 	#	
		 	# Therefore, for our purposes here, where in 99% of cases we didn't specify this number
		 	# explicitly, and therefore it's meaningless in the context of determining whether the
		 	# column type has changed, we will remove this number.
		 	#
		 	$details{type} =~ s!int\(\d+\)!int!;
		 	
		 	return \%details;
		 }
	}
	die_nice qq`Column '$column' not found on table '$table'.`;
}


sub get_field_details_from_creation_string($)
{
	my ($creation_string) = @_;

	my %details = ();
 	$details{type}		= ($creation_string =~ m!^(\S+( unsigned)?)!i)[0];
 	$details{null}		= $creation_string =~ m!not null!i ? 'NO' : 'YES';
 	$details{key}		= $creation_string =~ m!primary key!i ? 'PRI' : ''; # TODO: add detection of other key types.
	$details{default}	= $creation_string =~ m!default (\S+)!i ? $1 : ''; # TODO: some types have a default DEFAULT value other than NULL.
	$details{extra}		= $creation_string =~ m!auto_increment!i ? 'auto_increment' : ''; # TODO: potentially lots of other stuff here.
 	
	$details{type} =~ s!int\(\d+\)!int!; # see note in the get_field_details_from_db() sub.

	$details{default} =~ s!^'(.*)'$!$1!; # In case the specified default value is quoted, remove
	$details{default} =~ s!^"(.*)"$!$1!; # the quotes before actually using/comparing the value.
	 	
 	return \%details;
}


sub field_datatype_has_changed($$$)
{
	my ($table,$fieldname,$creation_string) = @_;
	my $new_fieldtype = get_field_details_from_creation_string($creation_string);
	my $old_fieldtype = get_field_details_from_db($table,$fieldname);
	
	my $changed = 0;
	my ($old,$new) = ();
	foreach my $attrib (sort keys %$old_fieldtype)
	{
		$changed = 1 if lc($$old_fieldtype{$attrib}) ne lc($$new_fieldtype{$attrib});
		$old .= "old $attrib: " . lc($$old_fieldtype{$attrib}) . "; ";
		$new .= "new $attrib: " . lc($$new_fieldtype{$attrib}) . "; ";
	}

	if($changed)
	{
		encdebug "datatype has changed for '$fieldname':\nold=$old\nnew=$new\n";
		return 1;
	}
	else
	{
		encdebug "datatype has NOT changed for '$fieldname':\nold=$old\nnew=$new\n";
		return 0;
	}
}


sub clean_database_url
{
	$_[0] =~ s!dbview=(horiz|vert)!!g if $_[0] =~ /dbview=horiz/ && $_[0] =~ /dbview=vert/; # if both are present, remove all.
	for('horiz','vert')
	{
		if($_[0] =~ /dbview=$_/) { $_[0] =~ s!dbview=$_!!g; $_[0] .= "&dbview=$_"; } # condense multiple occurrences of the same one.
	}
	$_[0] =~ s!\?&+!?!g;
}


sub verify_new_database_value($$$$$$)
{
	# Notes:
	#
	#	_viewer_unique_values requires that the table has a column called "id" which is unique and not null.
	#
	#	On syntax: this is wrong: $PREF{"${viewerprefname}_viewer_unique_values"}{foo} = 1;   # in the caller
	#	Instead, it must be this: $PREF{"${viewerprefname}_viewer_unique_values"}{foo}{ignorecase} = 1;
	#	This is because, if we want to allow the {ignorecase} sub-option ANYWHERE, then that means {foo}
	#	is actually a hashref, and thus can't just be set to 1.
	#	We probably want ignorecase in 99.9% of situations, but we can always add a corresponding
	#	"honorcase" version (or whatever) in the future if necessary.
	#

	my ($dbtable,$viewerprefname,$column,$value,$rowid,$all_fields) = @_;
	sql_untaint($value,$column);
	die_unless_sqlsafe($value,$column);

	if(exists $PREF{"${viewerprefname}_viewer_unique_values"}{lc($column)})
	{
		unless(exists $PREF{"${viewerprefname}_viewer_unique_values"}{lc($column)}{ignorenull} && ($value eq ""))
		{
			if(exists $PREF{"${viewerprefname}_viewer_unique_values"}{lc($column)}{ignorecase})
			{
				if($rowid =~ /^\d+$/) # edit mode.
				{
					if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE LOWER(`$column`) = LOWER('$value') AND `id` != $rowid"))
					{
						exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
					}
				}
				else # add-new-record mode.
				{
					if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE LOWER(`$column`) = LOWER('$value')"))
					{
						exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
					}
				}
			}
			else
			{
				if($rowid =~ /^\d+$/) # edit mode.
				{
					if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE `$column` = '$value' AND `id` != $rowid"))
					{
						exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
					}
				}
				else # add-new-record mode.
				{
					if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE `$column` = '$value'"))
					{
						exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
					}
				}
			}
		}
	}

	# 201001: APICHANGE: $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)} was a string; now it's a hash.
	#
	if(exists $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)})
	{
		foreach my $testnum (keys %{ $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)} })
		{
			my $code = $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)}{$testnum};
			if($code =~ /^preset:(.+)/)
			{
				foreach my $preset (split(/\s*,\s*/, $1))
				{
					my ($error,%vars) = ('',());
					   if(($preset eq 'nonnull')		&& (!$value && ($value !~ /^0$/)))	{ $error = $TEXT{Error_input_null}; }
					elsif(($preset eq 'alnum')		&& ($value !~ /^[[:alnum:]]*$/))	{ $error = $TEXT{Error_input_not_alnum}; }
					elsif(($preset eq 'word')		&& ($value !~ /^\w*$/))			{ $error = $TEXT{Error_input_not_word}; }
					elsif(($preset eq 'numeric')		&& ($value !~ /^\d*$/))			{ $error = $TEXT{Error_input_not_numeric}; }
					elsif(($preset =~ /^minvalue=(\d+)$/)	&& ($value < $1))			{ $error = $TEXT{Error_input_too_small}; $vars{min} = $1; }
					elsif(($preset =~ /^maxvalue=(\d+)$/)	&& ($value > $1))			{ $error = $TEXT{Error_input_too_large}; $vars{max} = $1; }
					elsif(($preset =~ /^minlength=(\d+)$/)	&& (length($value) < $1))		{ $error = $TEXT{Error_input_too_short}; $vars{min} = $1; }
					elsif(($preset =~ /^maxlength=(\d+)$/)	&& (length($value) > $1))		{ $error = $TEXT{Error_input_too_long}; $vars{max} = $1; }
					#print STDERR "column=$column, value=$value, preset=$preset, error=$error\n";

					if($error) { $error =~ s/%%encfieldname%%/$column/g; $error =~ s/%%(\w+)%%/$vars{$1}/g; kmsg_redirect($error); }
				}
			}
			else
			{
				$code =~ s/%%variable%%/\$value/g;
				$code =~ s/%%encfieldname%%/$column/g;
				$code =~ s/%%(\w+)%%/$$all_fields{$1}/g;
				eval $code; # modified $value directly.
				die $@ if $@; # in case the custom code had an error in it.
				# die_from_eval: can accept a whole literal message, or "smsg_foo" which maps to $TEXT{smsg_foo} -- where possible, use static messages rather than keyed messages.
				if($value =~ /die_from_eval:(.*)/) { my $msg = $1; $msg =~ m!^smsg_(.+)! ? smsg_redirect($1) : kmsg_redirect($msg); }
			}
		}
	}
}


sub transform_value_according_to_code
{
	my $dbtable		= shift;
	my $value		= shift;
	my $values		= shift; # hashref
	my $code		= shift;
	my $column		= shift;
	my $pass		= shift;
	my $already_transformed = shift; # hashref.

	if($code =~ /^preset:(.+)/)
	{
		foreach my $preset (split(/\s*,\s*/, $1))
		{
			   if($preset eq 'make_lowercase')	{ $value = lc($value); }
			elsif($preset eq 'make_uppercase')	{ $value = uc($value); }
			elsif($preset eq 'numeric')		{ $value =~ s![^\d\.]!!g; }
			elsif($preset eq 'remove_nonalnum')	{ $value =~ s![^[:alnum:]]!!g; }
			elsif($preset eq 'date8')		{ $value = strftime("%Y%m%d",localtime(offsettime())); }
			elsif($preset eq 'date17')		{ $value = strftime("%Y%m%d-%H:%M:%S",localtime(offsettime())); }
			elsif($preset eq 'etime')		{ $value = offsettime(); }

			elsif($preset eq 'next_int_if_null_or_zero' && !$value)
			{
				$value = enc_sql_select("SELECT MAX(`$column`) FROM `$dbtable`") =~ /^(\d+)$/ ? $1 : 0; $value++;
			}

			#print STDERR "column=$column, value=$value, preset=$preset\n";
		}
		$$values{$column} = $value;
	}
	else
	{
		$code =~ s/%%variable%%/\$value/g;
		$code =~ s/%%(\w+)%%/exists $$values{$1} || $pass==2 ? $$values{$1} : $&/eg;
		if($code !~ /%%\w+%%/ || $pass==2)
		{
			if(!$$already_transformed{$column})
			{
				$$already_transformed{$column} = 1;
				eval $code; # modifies $value directly.
				# 20120918: added die capability here (copied from verify_new_database_value()); was there a reason we weren't doing that here before?
				die $@ if $@; # in case the custom code had an error in it.
				# die_from_eval: can accept a whole literal message, or "smsg_foo" which maps to $TEXT{smsg_foo} -- where possible, use static messages rather than keyed messages.
				if($value =~ /die_from_eval:(.*)/) { my $msg = $1; $msg =~ m!^smsg_(.+)! ? smsg_redirect($1) : kmsg_redirect($msg); }
				$$values{$column} = $value;
			}
		}
	}
}


sub get_pagination_range($)
{
	my $items_per_page = $_[0];
	my $page_num = $qs =~ /(?:^|&)page=(\d+)(?:&|$)/ ? $1 : 1;
	my $range_start = ($items_per_page * ($page_num - 1)) + 1; # $range_start = 1 if $range_start < 1; # negative check not necessary if $page_num is guaranteed to be >= 1.
	my $range_end = $items_per_page * $page_num;
	my $sql_range_start = $range_start - 1; # because SQL's LIMIT is zero-based.

	($range_start,$range_end,$sql_range_start) = (1,999999999,0) if $qs =~ /(?:^|&)pagination=off(?:&|$)/;

	# We need to adjust itemsperpage (in the caller), not just the range start & end, when
	# pagination=off, because SQL's 'LIMIT' uses range_start & itemsperpage (not range_end).
	$_[0] = 999999999 if $qs =~ /(?:^|&)pagination=off(?:&|$)/;

	return ($range_start,$range_end,$sql_range_start);
}


sub get_pagination_links_mark2
{
	## first 4 args are mandatory; rest are optional.
	#my ($range_start, $range_end, $num_items, $items_per_page,
	#	$itemname_singular,
	#	$itemname_plural,
	#	$pagename_singular,
	#	$pagename_plural,
	#	$template,
	#	$num_pagelinks,
	#	$viewall_template
	#) = @_;
	#
	# 20110226: APICHANGE: args for this sub are now hash-based:
	#
	my $optsref = shift; my %opts = %$optsref if $optsref;

	$opts{template} ||= qq`
		<div class="pagelinks">
			<div class="text">
			<span class="bookend">{</span>%%num_items%% %%itemname%% on %%num_pages%% %%pagename%%.
			%%%if-show_opts_links%%%
				&nbsp;Options: &nbsp; %%alllink%% %%%if-show_sort_links%%%&nbsp; %%quicksortlink%% %%%end-show_sort_links%%%
			%%%end-show_opts_links%%%
			<span class="bookend">}</span>
			</div><br />

			%%%if-multiple_pages%%%
			<div class="links">
			%%%ifelse-frstlink%%% <a href="%%frstlink%%" class="first">&lt;&lt;</a>	%%%else%%% <span class="disabled first">&lt;&lt;</span>	%%%endelse-frstlink%%% %%spc%%
			%%%ifelse-prevlink%%% <a href="%%prevlink%%">&lt;</a>			%%%else%%% <span class="disabled">&lt;</span>		%%%endelse-prevlink%%% %%spc%%

			%%%template:linklist%%%
				%%%ifelse-currentpage%%%
					<span class="current">%%pagenum%%</span> %%spc%%
				%%%else%%%
					<a href="%%link%%">%%pagenum%%</a> %%spc%%
				%%%endelse-currentpage%%%
			%%%end-template:linklist%%%

			%%%ifelse-nextlink%%% <a href="%%nextlink%%">&gt;</a>			%%%else%%% <span class="disabled">&gt;</span>		%%%endelse-nextlink%%% %%spc%%
			%%%ifelse-lastlink%%% <a href="%%lastlink%%" class="last">&gt;&gt;</a>	%%%else%%% <span class="disabled last">&gt;&gt;</span>	%%%endelse-lastlink%%%
			</div>
			%%%end-multiple_pages%%%
		</div>
	`;

	$opts{viewall_template} ||= qq`
		<div class="pagelinks">
		(Viewing all %%num_items%% %%itemname%%.&nbsp; <a href="%%pageslink%%">View individual pages?</a>)
		</div>
	`;

	$opts{itemname_singular}	||= $TEXT{item}		|| 'item';
	$opts{itemname_plural}		||= $TEXT{items}	|| 'items';
	$opts{pagename_singular}	||= $TEXT{page}		|| 'page';
	$opts{pagename_plural}		||= $TEXT{pages}	|| 'pages';
	$opts{num_pagelinks}		||= 8;
	my $spacer			= $PREF{pagination_links_spacer} || '';

	my $num_pages = int($opts{num_items}/$opts{items_per_page});
	$num_pages++ if $num_pages < ($opts{num_items}/$opts{items_per_page});
	return '' if $opts{hide_when_single_page} && $num_pages =~ /^(0|1)$/ && get_qs_var('pagination') ne 'off';

	my $viewall_active	= (get_qs_var('pagination') eq 'off') || ($num_pages == 1);
	my $viewall_unclickable	= (get_qs_var('pagination') ne 'off') && ($num_pages == 1);

	my ($link_template) = ($opts{template} =~ m!%%%template:linklist%%%(.+?)%%%end-template:linklist%%%!gs);
	my $link_template_output = '';
	my %pagelinks = ();

	#if($qs =~ /pagination=off/)
	#if($viewall_active)
	if(0)
	{
		my $uri = $ENV{REQUEST_URI};
		$uri =~ s/pagination=off//g;
		defooify('&', $uri);
		$opts{viewall_template} =~ s!%%pageslink%%!$uri!g;
		$opts{viewall_template} =~ s!%%num_items%%!$opts{num_items}!g;
		$opts{viewall_template} =~ s!%%itemname%%!$opts{num_items} == 1 ? $opts{itemname_singular} : $opts{itemname_plural}!eg if $opts{itemname_singular} && $opts{itemname_plural};
		return $opts{viewall_template};
	}
	#elsif($opts{range_start} != 1   ||   $opts{num_items} > $opts{range_end})
	elsif(1)
	{
		my $uri = $ENV{REQUEST_URI};

		# Remove any existing phase/resultmsg, and page number, from the
		# URI, because we don't want to include those on each new page.
		#
		$uri =~ s/(\?|&)page=(\d+)/$1/g;
		$uri =~ s/(\?|&)phase=(\w+)/$1/g;
		$uri =~ s/(\?|&)rsltmsg=(\w+)/$1/g;

		my $uri_for_quicksort_link = my $uri_for_pagination_link = $uri;
		$uri_for_quicksort_link =~ s/(\?|&)quicksort=(on|off)/$1/g;
		$uri_for_pagination_link =~ s/(\?|&)pagination=(on|off)/$1/g;

		for($uri, $uri_for_quicksort_link, $uri_for_pagination_link)
		{
			$_ .= '?' unless $_ =~ /\?/;
			$_ .= '&' if $_ =~ /\?.+/ && $_ !~ /&$/;
			$_ =~ s/&{2,}/&/g;
			$_ =~ s/\?&/?/g;
			$_ =~ s/&/&amp;/g;   # TODO: breakage from this?
		}

		my $current_page = 1;
		for(my $j = 1; $j <= $num_pages; $j++)
		{
			my $is_currentpage = ($ENV{REQUEST_URI} =~ /page=$j/ || ($ENV{REQUEST_URI} !~ /page=\d+/ && $j==1));
			$current_page = $j if $is_currentpage;

			my $link_template_local = $link_template;
			$link_template_local =~ s!%%pagenum%%!$j!g;
			$link_template_local =~ s!%%link%%!${uri}page=$j!g;
			$link_template_local =~ s!%%%ifelse-currentpage%%%(.*?)%%%else%%%(.*?)%%%endelse-currentpage%%%!$is_currentpage ? $1 : $2!egs;
			$pagelinks{$j} = $link_template_local;
		}

		foreach my $page (sort { $a <=> $b } keys %pagelinks)
		{
			$link_template_output .= $pagelinks{$page} if (($page - int($opts{num_pagelinks}/2 + .5)) <= $current_page) && ($current_page <= ($page + int($opts{num_pagelinks}/2 + .5)));
		}

		my $prevlink = $current_page > 1 ? $current_page - 1 : 1;
		my $nextlink = $current_page < $num_pages ? $current_page + 1 : $num_pages;
		$opts{template} =~ s!%%prevlink%%!${uri}page=$prevlink!g;
		$opts{template} =~ s!%%nextlink%%!${uri}page=$nextlink!g;
		$opts{template} =~ s!%%alllink%%!$viewall_unclickable ? qq`<span class="disabled">view all</span>` : $viewall_active ? qq`<a href="${uri_for_pagination_link}">view pages</a>` : qq`<a href="${uri_for_pagination_link}pagination=off">view all</a>`!eg;
		$opts{template} =~ s!%%quicksortlink%%!quicksort_is_active() ? qq`<a href="${uri_for_quicksort_link}quicksort=off">server-sort</a>` : qq`<a href="${uri_for_quicksort_link}quicksort=on">quick-sort</a>`!eg;
		$opts{template} =~ s!%%%if-show_opts_links%%%(.*?)%%%end-show_opts_links%%%!$opts{hide_opts_links} ? '' : $1!egs;
		$opts{template} =~ s!%%%if-show_sort_links%%%(.*?)%%%end-show_sort_links%%%!$opts{hide_sort_links} ? '' : $1!egs;
		$opts{template} =~ s!%%%ifelse-prevlink%%%(.*?)%%%else%%%(.*?)%%%endelse-prevlink%%%!$current_page ne 1 ? $1 : $2!egs;
		$opts{template} =~ s!%%%ifelse-nextlink%%%(.*?)%%%else%%%(.*?)%%%endelse-nextlink%%%!$current_page ne $num_pages ? $1 : $2!egs;
		$opts{template} =~ s!%%%if-multiple_pages%%%(.*?)%%%end-multiple_pages%%%!$num_pages > 1 ? $1 : ''!egs;

		$opts{template} =~ s!%%frstlink%%!${uri}page=1!g;
		$opts{template} =~ s!%%lastlink%%!${uri}page=$num_pages!g;
		$opts{template} =~ s!%%%ifelse-frstlink%%%(.*?)%%%else%%%(.*?)%%%endelse-frstlink%%%!$current_page ne 1 ? $1 : $2!egs;
		$opts{template} =~ s!%%%ifelse-lastlink%%%(.*?)%%%else%%%(.*?)%%%endelse-lastlink%%%!$current_page ne $num_pages ? $1 : $2!egs;

		$opts{template} =~ s!%%%template:linklist%%%(.+?)%%%end-template:linklist%%%!$link_template_output!gs;
		$opts{template} =~ s!%%spc%%!$spacer!g;
		$opts{template} =~ s!%%num_items%%!$opts{num_items}!g;
		$opts{template} =~ s!%%num_pages%%!$num_pages!g;
		$opts{template} =~ s!%%itemname%%!$opts{num_items} == 1 ? $opts{itemname_singular} : $opts{itemname_plural}!eg if $opts{itemname_singular} && $opts{itemname_plural};
		$opts{template} =~ s!%%pagename%%!$num_pages == 1 ? $opts{pagename_singular} : $opts{pagename_plural}!eg if $opts{pagename_singular} && $opts{pagename_plural};

		return $opts{template};
	}
	else
	{
		return '';
	}
}


sub quicksort_is_active
{
	return (get_qs_var('quicksort') eq 'on') || ($PREF{enable_quicksort_by_default} =~ /yes/i && get_qs_var('quicksort') ne 'off');
}


sub apply_column_hiding_from_browser()
{
	my $hiddencols = shift;
	foreach my $col_toggled_by_js (split(/;\s*/, get_cookie('enc_visible_cols')))
	{
		my ($colname,$visible) = ($col_toggled_by_js =~ /$PREF{twochar_app_id}_$QS{action}_col_(\w+)=(\d)/);
		if($visible)	{ $hiddencols =~ s/(^|,)\s*$colname\s*(,|$)/$1$2/g; }
		else		{ $hiddencols .= ",$colname" unless $hiddencols =~ /(^|,)\s*$colname\s*(,|$)/; }
	}
	decommaify($hiddencols);
	return $hiddencols;
}


sub field_structure_managed_by_us
{
	my $field = shift;
	foreach my $table (keys %{$PREF{tables_listing_fields_whose_structure_we_manage}})
	{
		sql_untaint($field,$table);
		die_unless_sqlsafe($field,$table);
		my $query = "SELECT `fieldtype`,`fieldlabel`,`listitems`,`defaultvalue` FROM `$table` WHERE `fieldname` = '$field'";
		#enc_warn "query=$query\n";

		if(my ($fieldtype,$label,$listitems,$defaultvalue) = enc_sql_select($query))
		{
			#enc_warn qq`fieldtype,label,listitems,defaultvalue = $fieldtype,$label,$listitems,$defaultvalue\n`;
			if($fieldtype =~ /^(freeformsingle|freeformmulti|dropdown|checkbox|radio)$/)
			{
				return ($fieldtype,$label,$listitems,$defaultvalue);
			}
			else
			{
				return ();
			}
		}
	}
}


sub is_valid_email_address
{
	return $_[0] =~ /^[\w\.\+-]+\@[\w\.-]+\.\w+$/;
}


sub extract_email_address
{
	my $maybe_address = shift;   # can be a bit of text or a whole line.
	my $email = ($maybe_address =~ /(\S+\@\S+)/)[0];
	$email =~ s!^[\(\[<]+!!;   # remove any leading/trailing parentheses, brackets, etc.
	$email =~ s![\)\]>]+$!!;
	return $email;
}


sub interpolate_vars_from_URL_and_cookies
{
	my $include_undefined = 0;
	my $sql_sanitize = 0;
	for(@_)
	{
		$include_undefined = $_ if $_ eq 'include_undefined';
		$sql_sanitize = $_ if $_ eq 'sql_sanitize';
		next unless m!(%URL{|%COOKIE{)!;
		if($sql_sanitize)
		{
			my %done = ();
			my %url_vars = %QS;
			while(m!%URL\{([^\{\}]+)\}!g)
			{
				my $varname = $1;
				if(exists $url_vars{$varname}   &&   !$done{$varname})
				{
					sql_untaint($url_vars{$varname});
					replace_nonsqlsafe_chars_with('_', $url_vars{$varname});
					die_unless_sqlsafe($url_vars{$varname});
					$done{$varname} = 1;
				}
			}

			%done = ();
			my %cookies = %COOKIE;
			while(m!%COOKIE\{([^\{\}]+)\}!g)
			{
				my $varname = $1;
				if(exists $cookies{$varname}   &&   !$done{$varname})
				{
					sql_untaint($cookies{$varname});
					replace_nonsqlsafe_chars_with('_', $cookies{$varname});
					die_unless_sqlsafe($cookies{$varname});
					$done{$varname} = 1;
				}
			}

			s!%URL\{([^\{\}]+)\}!exists $url_vars{$1} || $include_undefined ? $url_vars{$1} : $&!eg;
			s!%COOKIE\{(.+?)\}!exists $cookies{$1} || $include_undefined ? $cookies{$1} : $&!eg;
		}
		else
		{
			s!%URL\{([^\{\}]+)\}!exists $QS{$1} || $include_undefined ? $QS{$1} : $&!eg;
			s!%COOKIE\{(.+?)\}!exists $COOKIE{$1} || $include_undefined ? $COOKIE{$1} : $&!eg;
		}
	}
}


sub interpolate_vars_from_prefs
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.
	for(@_)
	{
		s/%PREF{(\w+)}/exists $PREF{$1} || $include_undefined ? $PREF{$1} : $&/eg;
		s/%TEXT{(\w+)}/exists $TEXT{$1} || $include_undefined ? $TEXT{$1} : $&/eg;
	}
}


sub interpolate_vars_from_env
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.

	#for(@_)
	#{
	#	s/%ENV{(\w+)}/exists $ENV{$1} || $include_undefined ? $ENV{$1} : $&/eg;
	#}
	#
	# 20130618: the reason we don't necessarily include_undefined is because for prefs,
	# some may be included within other prefs (i.e. nested), yet not defined until after
	# all prefs are loaded.  But this doesn't apply to %ENV: that's fully defined from
	# the instant our app starts.  And delaying this interpolation of undefined ENV vars
	# caused a bug in FC, where this was set:
	#
	#	$PREF{admin_user_present} = '%ENV{PHP_ENC_ISADMIN}';
	#
	# Because check_if_logged_in() happens before the final prefs scan is done (the one
	# where include_undefined is enabled), the $PREF{admin_user_present} setting was
	# evaluating to literally '%ENV{PHP_ENC_ISADMIN}' -- which is a true value -- even
	# when $ENV{PHP_ENC_ISADMIN} was undefined, causing admin_user_present to be set to
	# true when it should have been false.
	#
	# So from now on, we're always going to include undefined %ENV vars -- we're not
	# even going to test for that.
	# 
	for(@_)
	{
		s/%ENV{(\w+)}/$ENV{$1}/g;
	}
}


sub interpolate_vars_from_sql
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.
	for(@_)
	{
		while(m!(%SQL\{\{(.+?)\}\})!g)
		{
			my ($wholething,$sql_statement) = ($1,$2);
			get_db_connection() unless $PREF{dbh};
			interpolate_vars_from_URL_and_cookies($include_undefined, 'sql_sanitize', $sql_statement);
			my $output = enc_sql_select($sql_statement);
			s!\Q$wholething\E!$output!g;
		}
	}
}


sub interpolate_vars_from_date
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.
	my $etime = $_[0] =~ /^etime=(\d+)$/ ? shift : offsettime();
	$etime =~ s/[^\d]//g;
	s!%DATE{(.+?)}{now([\+-]\d+[smhdb])}!strftime($1,localtime(offset_etime($etime,$2)))!eg for @_;
	s!%DATE{(.+?)}!strftime($1,localtime($etime))!eg for @_;
}


sub do_standard_template_conditionals_processing
{
	for(@_)
	{
		s!%%%if-admin_is_logged_in%%%(.*?)%%%end-admin_is_logged_in%%%!$PREF{admin_is_logged_in} ? $1 : ''!egs;
		s!%%%if-admin_not_logged_in%%%(.*?)%%%end-admin_not_logged_in%%%!$PREF{admin_is_logged_in} ? '' : $1!egs;
		s!%%%ifelse-admin_is_logged_in%%%(.*?)%%%else%%%(.*?)%%%endelse-admin_is_logged_in%%%!$PREF{admin_is_logged_in} ? $1 : $2!egs;

		s!%%%if-member_is_logged_in%%%(.*?)%%%end-member_is_logged_in%%%!$PREF{member_is_logged_in} ? $1 : ''!egs;
		s!%%%if-member_not_logged_in%%%(.*?)%%%end-member_not_logged_in%%%!$PREF{member_is_logged_in} ? '' : $1!egs;
		s!%%%ifelse-member_is_logged_in%%%(.*?)%%%else%%%(.*?)%%%endelse-member_is_logged_in%%%!$PREF{member_is_logged_in} ? $1 : $2!egs;

		s!%%%if-member_of_group_([^%]+)%%%(.*?)%%%end-member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $2 : ''!egs;
		s!%%%if-not_member_of_group_([^%]+)%%%(.*?)%%%end-not_member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? '' : $2!egs;

		s!%%%ifelse-member_of_group_([^%]+)%%%(.*?)%%%else%%%(.*?)%%%endelse-member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $2 : $3!egs;
		s!%%%ifelse-not_member_of_group_([^%]+)%%%(.*?)%%%else%%%(.*?)%%%endelse-not_member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $3 : $2!egs;

		s!%%%if-allowed_to_(\w+)%%%(.*?)%%%end-allowed_to_\1%%%!user_is_allowed_to($1) ? $2 : ''!egs;
		s!%%%ifelse-allowed_to_(\w+)%%%(.*?)%%%else%%%(.*?)%%%endelse-allowed_to_\1%%%!user_is_allowed_to($1) ? $2 : $3!egs;

		s!%%%if-login_system_available%%%(.*?)%%%end-login_system_available%%%!$PREF{login_system_available} ? $1 : ''!egs;
		s!%%%if-login_system_not_available%%%(.*?)%%%end-login_system_not_available%%%!$PREF{login_system_available} ? '' : $1!egs;
		s!%%%ifelse-login_system_available%%%(.*?)%%%else%%%(.*?)%%%endelse-login_system_available%%%!$PREF{login_system_available} ? $1 : $2!egs;
	}
}


sub do_standard_template_vars_processing
{
	interpolate_vars_from_sql(@_); # do this one first, so we can SQL-sanitize any nested URL/cookie variables and interpolate them manually, rather than letting the following functions do the regular interpolation with no SQL-sanitization.
	interpolate_vars_from_env(@_);
	interpolate_vars_from_prefs(@_);
	interpolate_vars_from_URL_and_cookies(@_);
	interpolate_vars_from_date(@_);
}


sub do_standard_template_leftover_nulling
{
	# Go in order from most specific to least specific.  For example, %%%set...%%%
	# is near the end, because it can contain spaces, so we need to make the
	# regex a little looser to match it.  And we explicitly match %%\w+%% even
	# though we later have a more generic %%[^%\s]+?%% because removing the
	# simple all-alphanumeric vars first makes it more straightforward to match
	# the more varied possibilities later.

	for(@_)
	{
		s!%%%if-(\S+)%%%.+?%%%end-\1%%%!!gs;
		s!%%%ifelse-(\S+)%%%.*?%%%else%%%.*?%%%endelse-\1%%%!!gs;
		s!%%%calculate:([^%]+)%%%.+?%%%end-calculate%%%!!gs;
		s!%%%customcode(:[^%]+)?%%%.+?%%%end-customcode%%%!!gs;
		s!%%\w+%%!!g;
		#s!%%[^%\s]+?%%!!g;
		s!%%%set[^%]+?%%%!!g;
	}
}


sub do_standard_template_oddeven_processing # make this your last template-processing action, so any %%oddeven%%s present will definitely be present in the output.
{
	for(@_)
	{
		my $i = 0; while(/%%oddeven%%/g) { s!%%oddeven%%!oddeven($i)!e; }
	}
}


# This sub is designed to skip any interpolations that are currently null and/or
# whose values have other raw template variables within them.  This allows the
# template's various operations and variables to be nested in arbitrarily deep
# and complex ways.  Because of this, the sub iterates multiple times, since
# items that were skipped on earlier passes will be able to be processed on
# later passes.
#
sub do_custom_template_processing
{
	my $templatevars = shift; # hashref.
	for(my $i=0; $i<8; $i++)
	{
		for(@_)
		{
			s!%%%if-([^%]+)==([^%]+)%%%(.*?)%%%end-\1==\2%%%!$1 eq $2 ? $3 : ''!egs;

			s!%%%if-is_valid_price_([^%]+)%%%(.*?)%%%end-is_valid_price_\1%%%!item_price_is_valid($1) ? $2 : ''!egs;

			#while(m!\s*%%%set-urlencoded:(\w+)=([^%]*)%%%\s*!g)
			#{
			#	my ($name,$val) = ($1,$2);
			#	enc_urlencode($val);
			#	$$templatevars{$name} = $val;
			#}

			$$templatevars{$1} = $2 while $_ =~ m!\s*%%%set:(\w+)=([^%]*)%%%\s*!g;
			s!%%(\w+?)%%!exists $$templatevars{$1} ? $$templatevars{$1} : $&!eg;
			s!%%(\w+?)_urlencoded%%!exists $$templatevars{$1} ? enc_urlencode_return($$templatevars{$1}) : $&!eg;

			while(m!(%%%calculate:([^%]+)%%%\s*(.+?)\s*%%%end-calculate%%%)!gs)
			{
				#die "code is: '$3', wholething is: '$1'";
				my ($wholething,$options,$code) = ($1,$2,$3);

				next if $code =~ /%%\w+%%/; # skip it if it still has unprocessed variables in it.

				my $output = eval $code;
				exit_with_error($1) if $output =~ /die_from_eval:(.*)/;
				my $outputvarname = '';

				for(split(/\s*,\s*/, $options))
				{
					if(/numdecimals=(\d+)/)
					{
						my $numdec = $1;
						$output =~ s/(\.\d{$numdec})\d+$/$1/;
						$output .= '.' unless $output =~ /\.\d*$/;
						$output .= '0' while length(   ($output =~ /\.(\d*)$/)[0]   ) < $numdec;
					}
					elsif(/varname=(\w+)/)
					{
						$outputvarname = $1;
					}
				}

				s!\Q$wholething\E!%%%set:$outputvarname=$output%%%!s;
			}

			while(m!(%%%customcode(:[^%]+)?%%%\s*(.+?)\s*%%%end-customcode%%%)!gs)
			{
				#die "code is: '$3', wholething is: '$1'";
				my ($wholething,$options,$code) = ($1,$2,$3);

				next if $code =~ /%%\w+%%/; # skip it if it still has unprocessed variables in it.

				my $output = eval $code;

				exit_with_error($1) if $output =~ /die_from_eval:(.*)/;

				s!\Q$wholething\E!!s;
			}

			if(exists $$templatevars{eitemcode} && exists $$templatevars{eitemname} && exists $$templatevars{eitemdesc} && exists $$templatevars{eitemopts} && exists $$templatevars{eitemcost})
			{
				$$templatevars{eitemfingerprint} = get_cart_item_fingerprint(
										$$templatevars{eitemcode},
										$$templatevars{eitemname},
										$$templatevars{eitemdesc},
										$$templatevars{eitemopts},
										$$templatevars{eitemcost}
				);
			}
		}
	}
}


# Create a fingerprint before and after adding the item to the cart, to
# prevent modification of any of the values (particularly the price).
#
sub get_cart_item_fingerprint($$$$$)
{
	return sha256_hex(
			$PREF{database_name} . $PREF{database_username} . $PREF{database_password} . 
			$_[0] . $_[1] . $_[2] . $_[3] . $_[4] . 
			$ENV{DOCUMENT_ROOT} . $ENV{PATH} . $ENV{SCRIPT_FILENAME}
	);
}


sub format_xml_nicely
{
	my $input_xml = shift;
	my $output_xml = '';
	my $depth = 0;
	my $prev_line_was_opener = 0;
	while($input_xml =~ /(<[^<>]+>)/g)
	{
		my $line = $1;
		#print STDERR "Line is: '$line'\n";
		my $opener = 0;
		if($line =~ m!^<\?xml!i)
		{
			$output_xml .= "$line\n";
			next;
		}
		elsif($line =~ m!^<[^<]+/>$!)
		{
			$depth++ if $prev_line_was_opener;
		}
		elsif($line =~ m!^</[^<]+>$!)
		{
			$depth--;
			$opener = 0;
			#$line .= '-';
		}
		elsif($line =~ m!^<[^<]+>$!)
		{
			$depth++;
			$opener = 1;
			#$line .= '+';
		}

		$output_xml .= '  ' x ($depth - 1);
		$output_xml .= "$line\n";

		$prev_line_was_opener = $opener;
	}
	return $output_xml;
}


sub is_zero # to differentiate values from null.
{
	return $_[0] =~ /^0$/;
}


sub dumphash
{
	my ($hashref,$separator) = @_;
	$separator ||= ', ';
	my $output = '';
	foreach my $key (sort keys %$hashref) { $output .= "$key=$$hashref{$key}$separator"; }
	$output =~ s!$separator$!!;
	return $output;
}


sub remove_common_leading_substring
{
	# Pass in an array of strings, and this sub will remove any common leading
	# portion from each of the strings in the array.  Note: this currently has
	# a hard-coded relief valve (the "$done = 1 if $i > N") until it gets more
	# widespread testing, because a malfunction could result in an infinite loop.

	my $done = 0;
	my $i = 0;
	my $longest_common_substring = '';
	while(!$done)
	{
		$i++;
		#print STDERR "increasing \$i to $i\n";
		my $substring = '';
		for(@_)
		{
			#print STDERR "\tprocessing $_ : ";
			if(!length($substring))
			{
				# Set our test string from the first string in the array.  And this is
				# in its own separate if() because there's no sense in testing whether
				# this first string matches itself.
				#
				$substring = substr($_, 0, $i);

				# Also note that, because of this if() and the fact that we only set
				# the LCS variable in the following else(), that means we're technically
				# only removing length(LCS)-1 characters -- but that's what we want,
				# because otherwise we'd be leaving a null string in the event that one
				# of the strings *is* the LCS.  Instead we're leaving one character from
				# the end of the LCS as the first character on all the output strings.
			}
			else
			{
				if(/^$substring/)
				{
					#print STDERR "still matches ('$_' matches '$substring')\n";
					$longest_common_substring = $substring;
				}
				else
				{
					# failed the match, so we need to roll it back by 1 char:
					$longest_common_substring = substr($longest_common_substring, 0, -1);
					#print STDERR "failed match; we're done here. \$longest_common_substring='$longest_common_substring'\n";
					$done = 1; last;
				}
			}
			if(length($substring) >= length($_))
			{
				#print STDERR "\n\tsubstring now as long as the shortest string; we're done here\n";
				$done = 1; last;
			}
		}
		$done = 1 if $i > 100; 
	}
	s!^$longest_common_substring!! for @_;
}


sub date14_to_etime($)
{
	my $date14 = shift;
	if(my ($year, $month, $day, $hour, $minute, $second) = ($date14 =~ m!(\d\d\d\d)(\d\d)(\d\d)\D(\d\d)(\d\d)(\d\d)!)) {
		return timelocal($second, $minute, $hour, $day, ($month - 1), $year);
	}
	return 0;
}


sub date19_to_etime($)
{
	my $date19 = shift;
	if(my ($year, $month, $day, $hour, $minute, $second) = ($date19 =~ m!(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)!)) {
		return timelocal($second, $minute, $hour, $day, ($month - 1), $year);
	}
	return 0;
}


sub datestring8_to_etime($$)
{
	my $d8 = shift;
	my $when = shift;
	$when = $when =~ /start/ ? 'start' : 'end';

	my ($year,$month,$day) = ($d8 =~ /^(\d{4})(\d{2})(\d{2})$/);

	my ($sec,$min,$hour);
	if($when eq 'start')
	{
		($sec,$min,$hour) = (0,0,0);
	}
	else
	{
		($sec,$min,$hour) = (59,59,23);
	}

	return timelocal($sec,$min,$hour,$day,($month - 1),$year);
}


sub num_elapsed_days_between_datestring8_dates($$)
{
	my $earlier_date = shift;
	my $later_date = shift;

	if($earlier_date !~ /^\d{8}$/ || $later_date !~ /^\d{8}$/)
	{
		die_nice qq`datestrings must contain exactly 8 digits and nothing else, but you've passed "$earlier_date" and "$later_date"\n`;
	}

	return 0 if $earlier_date == $later_date;

	if($earlier_date > $later_date)
	{
		my $temp = $earlier_date;
		$earlier_date = $later_date;
		$later_date = $temp;
	}

	# now $earlier_date is smaller/earlier than $later_date.

	my $elapsed_days = 0;
	while($earlier_date < $later_date)
	{
		$later_date = decrement_datestring_8($later_date, 1);
		$elapsed_days++;
	}

	return $elapsed_days;
}


sub increment_datestring_8($$)
{
	my $start = shift;
	my $amount = shift;
	my $i = ();

	die_nice("Error: increment_datestring_8('$start', '$amount'): invalid start date '$start'.\n") unless $start =~ /^\d{8}$/;

	for($i=1; $i<=$amount; $i++)
	{
		my ($year,$month,$day) = ($start =~ /(\d{4})(\d{2})(\d{2})/);
		my ($newmonth,$newday) = ($month,$day);

		s/^0// for($newmonth,$newday);

		# try to inc the day
		eval { timelocal(0,0,0,$newday+1,$newmonth-1,$year); }; # note: timelocal's month is 0..11 so $month-1 = $month
		if($@) # means there was an error.
		{
			# try to inc the month
			eval { timelocal(0,0,0,1,$newmonth,$year); };
			if($@)
			{
				# inc the year
				eval { timelocal(0,0,0,1,0,$year+1); };
				if($@)
				{
					die_nice("Error: increment_datestring_8('$start', '$amount'): can't increment the year: $@\n");
				}
				else
				{
					$year++;
					$start = $year . '0101';
				}
			}
			else
			{
				$newmonth++;
				$newmonth = "0$newmonth" if ($newmonth =~ /^\d$/);
				$start = $year . $newmonth . '01';
			}
		}
		else
		{
			$newday++;
			$newday = "0$newday" if ($newday =~ /^\d$/);
			$start = $year . $month . $newday;
		}
	}

	return $start;
}


sub decrement_datestring_8($$)
{
	my $start = shift;
	my $amount = shift;
	my $i = ();

	die_nice("Error: decrement_datestring_8('$start', '$amount'): invalid start date '$start'.\n") unless $start =~ /^\d{8}$/;

	for($i=1; $i<=$amount; $i++)
	{
		my ($year,$month,$day) = ($start =~ /(\d{4})(\d{2})(\d{2})/);
		my ($newmonth,$newday) = ($month,$day);

		s/^0// for($newmonth,$newday);

		# try to dec the day
		eval { timelocal(0,0,0,$newday-1,$newmonth-1,$year); }; # note: timelocal's month is 0..11 so $month-1 = $month
		if($@ || $newday !~ /[1-9]/) # $@ means there was an error.  also need to make sure $newday is nonzero for servers whose timelocal() is broken, incorrectly reporting 0 as a valid day.
		{
			# try to dec the month
			eval { timelocal(0,0,0,1,$newmonth-2,$year); };
			if($@)
			{
				# month is Jan... dec the year
				eval { timelocal(0,0,0,1,0,$year-1); };
				if($@)
				{
					die_nice("Error: decrement_datestring_8('$start', '$amount'): can't decrement the year: $@\n");
				}
				else
				{
					$year--;
					$start = $year . '1231';
				}
			}
			else
			{
				# we know the month is valid, so find the highest valid day:
				$newday = 32;
				do { $newday--; eval { timelocal(0,0,0,$newday,$newmonth-2,$year); }; } while ($@);

				$newmonth--;
				$newmonth = "0$newmonth" if ($newmonth =~ /^\d$/);
				$start = $year . $newmonth . $newday;
			}
		}
		else
		{
			$newday--;
			$newday = "0$newday" if ($newday =~ /^\d$/);
			$start = $year . $month . $newday;
		}
	}

	return $start;
}


sub increment_datestring_6
{
	my $date = shift;
	die_nice qq`Invalid datestring6 value: '$date'.` unless $date =~ /^\d{6}$/;
	my ($year,$month) = ($date =~ /(\d{4})(\d{2})/);
	$month =~ s!^0!!;
	$month++;
	if($month > 12)
	{
		$month = 1;
		$year++;
	}
	$month = "0$month" if $month =~ /^\d$/;
	return "$year$month";
}


sub decrement_datestring_6
{
	my $date = shift;
	die_nice qq`Invalid datestring6 value: '$date'.` unless $date =~ /^\d{6}$/;
	my ($year,$month) = ($date =~ /(\d{4})(\d{2})/);
	$month =~ s!^0!!;
	$month--;
	if($month < 1)
	{
		$month = 12;
		$year--;
	}
	$month = "0$month" if $month =~ /^\d$/;
	return "$year$month";
}


sub split_path_and_filename
{
	#return ($_[0] =~ m!^(.*?)([^/\\]+)$!);
	#return $_[0] =~ m!^(.*?)([^/\\]+)$! ? ($1, $2) : $_[0] =~ m!/! ? ($_[0], undef) : (undef, $_[0]);
	my $item = shift;
	if($item =~ m!/$!)			{ return ($item, undef); }	# ends in a slash = dir
	elsif($item !~ m!/! && $item !~ m!\.!)	{ return ($item, undef); }	# no slash and no dot = dir
	elsif($item =~ m!^(.*?)([^/\\]+)$!)	{ return ($1, $2); }
	else					{ return (); }
}


sub serialize_filename_if_file_exists
{
	my $fullfile = shift;
	my $separator = shift;		# optional
	my $paddinglength = shift || 2;	# optional

	my ($path,$file) = split_path_and_filename($fullfile);
	$separator ||= $file =~ / / ? ' ' : '_';

	my $i = my $j = 1;
	while(-e $fullfile)
	{
		$j = $i;
		$j = "0$j" while(length($j) < $paddinglength);
		my $tempname = $file;
		$tempname =~ s/(\.[^\.]+)$/$separator$j$1/;
		$fullfile = $path . $tempname;
		$i++;
	}

	return wantarray ? ($fullfile, $separator, $j) : $fullfile;
}


sub generate_nonce   # optionally accepts any number of arguments for extra entropy.
{
	return sha256_hex($ENV{REMOTE_ADDR} . $$ . $ENV{HTTP_USER_AGENT} . $ENV{REMOTE_PORT} . time() . rand() . join('x', @_));
}


sub get_js_std
{

return qq`

// Start-Enc-Common /////////////////////////////////////////////////////////////////

function set_cookie(name, value, hours_to_live, path, domain, secure)
{
	var expireDate = "";
	if(hours_to_live)
	{
		expireDate = (new Date((new Date()).getTime() + hours_to_live*3600000)).toGMTString();
	}

	var curCookie = name + "=" + escape(value) +
	((hours_to_live) ? "; expires=" + expireDate : "") +
	((path) ? "; path=" + path : "") +
	((domain) ? "; domain=" + domain : "") +
	("$PREF{cookie_domain}" ? "; domain=$PREF{cookie_domain}" : "") +
	((secure) ? "; secure" : "");

	document.cookie = curCookie;
}

function get_cookie(name)
{
	var dc = document.cookie;
	var prefix = name + "=";
	var begin = dc.indexOf("; " + prefix);
	if (begin == -1) {
		begin = dc.indexOf(prefix);
		if (begin != 0) return null;
	} else
		begin += 2;
	var end = document.cookie.indexOf(";", begin);
	if (end == -1)
		end = dc.length;
	return unescape(dc.substring(begin + prefix.length, end));
}

function delete_cookie(name, path, domain)
{
	if(get_cookie(name))
	{
		document.cookie = name + "=" + 
		((path) ? "; path=" + path : "") +
		((domain) ? "; domain=" + domain : "") +
		"; expires=Thu, 01-Jan-70 00:00:01 GMT";
	}
	else
	{
		alert('$PREF{no_selections_text}');
	}
}

function gebi(id) { return document.getElementById(id); }

function toggle_display(el,disp)
{
	// pass in a CSS ID, or a node, for "el".
	var togs = typeof el === 'string' ? gebi(el) : el;
	if(togs)
		togs.style.display = disp;
}

function toggle_display_flip(el,disp)
{
	// pass in a CSS ID, or a node, for "el".
	// for disp, pass in something like 'block', or 'inline-block', etc.  or leave null.  don't pass 'none'.
	var togs = typeof el === 'string' ? gebi(el) : el;
	if(togs)
	{
		if(togs.style.display == ''   ||   togs.style.display == 'none') // TODO: test the '' case in IE.
			togs.style.display = disp || 'block';
		else
			togs.style.display = 'none';
	}
}

function encdb_submit(form_id)
{
	if(check_for_required_fields(form_id))
		gebi(form_id).submit();
	else
		return false;
}

function encdb_toggle_all_columns(form_id)
{
	if(gebi('all_cols_toggled').value == 0) {
		var cells = gebi(form_id).getElementsByTagName('td');
		for(var i=0; i<cells.length; i++) {
			cells[i].style.display = 'table-cell';
		}
		gebi('all_cols_toggled').value = 1;
		gebi('toggle_all_cols').value = "$TEXT{database_toggle_cols_reset}";
	}
	else {
		if(window.confirm("This will reload the page; are you sure?"))
			location.reload();
	}
}

function add_css_class(the_el, the_class)
{
	if(the_el.className.indexOf(the_class) == -1)
		the_el.className += ' ' + the_class;
}

function remove_css_class(the_el, the_class)
{
	the_el.className = the_el.className.replace(new RegExp(the_class,'g'), '');
}

function enc_alert(msg)
{
	var div = document.createElement("div");
	div.className = "encpopup";
	div.id = "encpopup";

	div.innerHTML = '<div class="encpopup_inner">' + 
			msg +
			'<div class="encpopup_buttons">' +
			'<input id="enc_popup_closebtn" type="button" value="OK" onclick="enc_alert_cancel()" /> ' +
			'</div></div>';

	document.body.appendChild(div);
	gebi('enc_popup_closebtn').focus();
}

function enc_alert_cancel()
{
	document.body.removeChild(gebi("encpopup"));
}

function enc_confirm(msg, yescallback, nocallback, yestext, notext)
{
	var div = document.createElement("div");
	div.className = "encpopup";
	div.id = "encpopup";

	div.innerHTML = '<div class="encpopup_inner">' + 
		msg +
		'<div class="encpopup_buttons">' +
		'<input id="enc_confirm_yesbtn" type="button" value="' + yestext + '" /> ' +
		'<input id="enc_confirm_nobtn" type="button" value="' + notext +  '" />' +
		'</div></div>';

	document.body.appendChild(div);

	if(gebi("enc_confirm_yesbtn").addEventListener)
	{
		// like using an inline onclick, except more correct, and inline onclick doesn't work in this case anyway.
		gebi("enc_confirm_yesbtn").addEventListener("click", function(){enc_confirm_return(yescallback);}, false);
		gebi("enc_confirm_nobtn").addEventListener("click", function(){enc_confirm_return(nocallback);}, false);
	}
	else if(gebi("enc_confirm_yesbtn").attachEvent) // for older versions of IE.
	{
		gebi("enc_confirm_yesbtn").attachEvent("onclick", function(){enc_confirm_return(yescallback);});
		gebi("enc_confirm_nobtn").attachEvent("onclick", function(){enc_confirm_return(nocallback);});
	}
}

function enc_confirm_return(callback)
{
	document.body.removeChild(gebi("encpopup"));
	callback();
}

function check_for_required_fields(form_id)   // TODO: apparently in IE8, required drop-downs are seen as null even when they're not...
{
	var onlyinputs = gebi(form_id).getElementsByTagName('input');
	var selects = gebi(form_id).getElementsByTagName('select');
	var textareas = gebi(form_id).getElementsByTagName('textarea');
	var inputs = new Array;

	for(var i = 0; i < onlyinputs.length; i++)
		inputs[inputs.length] = onlyinputs[i];

	for(var i = 0; i < selects.length; i++)
		inputs[inputs.length] = selects[i];

	for(var i = 0; i < textareas.length; i++)
		inputs[inputs.length] = textareas[i];

	var items_missing = 0;
	var email_format_incorrect = 0;
	var alpha_format_incorrect = 0;
	var numeric_format_incorrect = 0;
	var alphanum_format_incorrect = 0;
	var email_domain_not_allowed = 0;

	for(var i = 0; i < inputs.length; i++)
	{
		if(inputs[i].className.indexOf('required') != -1)
		{
			var formfield_group___array = inputs[i].className.match(/(formfield_\\d+)/);
			var formfield_group = formfield_group___array ? formfield_group___array[1] : '';

			if(inputs[i].type == 'radio'   &&   document.getElementsByClassName   &&   radio_group_is_unchecked(document.getElementsByClassName(formfield_group)))
			{
				mark_input_error(inputs[i].parentNode, 'input_error_reqd');
				items_missing = 1;
			}
			else if(inputs[i].type == 'checkbox'   &&   !inputs[i].checked)
			{
				mark_input_error(inputs[i].parentNode, 'input_error_reqd');
				items_missing = 1;
			}
			else if(inputs[i].value == '' || inputs[i].value == undefined)
			{
				mark_input_error(inputs[i], 'input_error_reqd');
				items_missing = 1;
			}
			else
			{
				if((inputs[i].type == 'radio') || (inputs[i].type == 'checkbox'))
					unmark_input_error(inputs[i].parentNode, 'input_error_reqd');
				else
					unmark_input_error(inputs[i], 'input_error_reqd');
			}
		}
		if(inputs[i].className.indexOf('emailformat') != -1)
		{
			if(inputs[i].value.length > 0   &&   !inputs[i].value.match( /.+\@.+\\..+/ ))
			{
				mark_input_error(inputs[i], 'input_error_email');
				email_format_incorrect = 1;
			}
			else
				unmark_input_error(inputs[i], 'input_error_email');

			if(inputs[i].value.length > 0   &&   !email_domain_is_allowed(inputs[i]))
			{
				mark_input_error(inputs[i], 'input_error_domain');
				var field_num = inputs[i].className.match(/formfield_(\\d+)/)[1];
				var allowed_domains = gebi('formfield_' + field_num + '_allowed_domains').value;
				var errmsg = "$TEXT{email_domain_not_allowed}".replace(/%%allowed_email_domains%%/, allowed_domains);
				alert(errmsg);
				return 0;
			}
			else
				unmark_input_error(inputs[i], 'input_error_domain');
		}
		if(inputs[i].className.indexOf('numeric') != -1)
		{
			if(!inputs[i].value.match( /^\\d+\$/ ))
			{
				mark_input_error(inputs[i], 'input_error_num');
				numeric_format_incorrect = 1;
			}
			else
				unmark_input_error(inputs[i], 'input_error_num');
		}
		if(inputs[i].className.indexOf('alphabetic') != -1)
		{
			if(!inputs[i].value.match( /^[a-z]*\$/i ))
			{
				mark_input_error(inputs[i], 'input_error_alpha');
				alpha_format_incorrect = 1;
			}
			else
				unmark_input_error(inputs[i], 'input_error_alpha');
		}
		if(inputs[i].className.indexOf('alphanum') != -1)
		{
			if(!inputs[i].value.match( /^[a-z0-9]*\$/i ))
			{
				mark_input_error(inputs[i], 'input_error_alphanum');
				alphanum_format_incorrect = 1;
			}
			else
				unmark_input_error(inputs[i], 'input_error_alphanum');
		}
	}

	if(items_missing)
		alert("$TEXT{Please_fill_in_the_required_items_}");
	else if(email_format_incorrect)
		alert("$TEXT{Please_enter_a_valid_email_address_}");
	else if(alpha_format_incorrect)
		alert("$TEXT{Please_enter_only_letters_}");
	else if(numeric_format_incorrect)
		alert("$TEXT{Please_enter_a_number_}");
	else if(alphanum_format_incorrect)
		alert("$TEXT{Please_enter_only_letters_and_numbers_}");
	else
		return 1;

	return 0;
}

function mark_input_error(the_el, the_err)
{
	if(the_el.className.indexOf(the_err) == -1)
		the_el.className += ' ' + the_err;
}

function unmark_input_error(the_el, the_err)
{
	the_el.className = the_el.className.replace(new RegExp(the_err,'g'), '');
}

function radio_group_is_unchecked(radio_group_list)
{
	var checked = 0;
	for(var i = 0; i < radio_group_list.length; i++)
		if(radio_group_list[i].checked)
			checked = 1;
	return !checked;
}

function email_domain_is_allowed(field)
{
	var user_emails = field.value.split(/[ ,]+/);
	var field_num = field.className.match(/formfield_(\\d+)/)[1];
	var allowed_domains_field = gebi('formfield_' + field_num + '_allowed_domains');
	if(!allowed_domains_field)
		return 1;

	var allowed_domains = allowed_domains_field.value.split(/[ ,]+/);
	var matches = 0, misses = 0;

	for(var i=0; i<user_emails.length; i++)
	{
		var this_email_allowed = 0;
		for(var j=0; j<allowed_domains.length; j++)
		{
			var re = new RegExp('\@' + allowed_domains[j] + '\$');
			if(user_emails[i].match(re))
				this_email_allowed = 1;
		}
		if(this_email_allowed)
			matches++;
		else
			misses++;
	}
	var allowed = matches > 0 && misses == 0;
	return allowed;
}

function encdb_imgpkr_choose(column, filename, css_id)
{
	var block_id = 'encdb_imgpkr_image_' + column + '_' + css_id;
	var actionlink_id = 'encdb_imgpkr_actionlink_' + column + '_' + css_id;
	
	var orig_block = gebi(block_id);
	var new_block = orig_block.cloneNode(true);
	new_block.id = 'encdb_imgpkr_image_chosen_' + column + '_' + css_id;
	
	if(!gebi(new_block.id)) // avoid dupes in the chosen field.
	{
		var links_in_new_block = new_block.getElementsByTagName("a");
		for(i = 0; i < links_in_new_block.length; i++)
		{
			if(links_in_new_block[i].className.indexOf('encdb_imgpkr_actionlink') != -1)
			{
				links_in_new_block[i].innerHTML = "$TEXT{database_image_picker_remove_button}";
				links_in_new_block[i].onclick = Function("encdb_imgpkr_unchoose('" + column + "','" + filename + "','" + css_id + "'); return false");
			}
		}

		var chosen_container = gebi('encdb_imgpkr_chosen_' + column);
		var divs_in_chosen_container = chosen_container.getElementsByTagName("div");
		for(i = 0; i < divs_in_chosen_container.length; i++)
		{
			if(divs_in_chosen_container[i].className.indexOf('empty_placeholder') != -1)
			{
				// Remove the "(none)" placeholder:
				chosen_container.removeChild(divs_in_chosen_container[i]);
			}
		}
		chosen_container.appendChild(new_block);

		var textfield = gebi("encdb_" + column);
		var re = new RegExp('(^|:::::)' + filename + '(:::::|\$)');
		if(!textfield.value.match(re))
		{
			textfield.value = textfield.value ? textfield.value + ":::::" + filename : filename;
		}
	}
}

function encdb_imgpkr_unchoose(column, filename, css_id)
{
	var block_id = 'encdb_imgpkr_image_chosen_' + column + '_' + css_id;
	var block_to_remove = gebi(block_id);
	var chosen_container = gebi('encdb_imgpkr_chosen_' + column);
	chosen_container.removeChild(block_to_remove);

	var textfield = gebi("encdb_" + column);
	var re = new RegExp('(^|:::::)' + filename + '(:::::|\$)');
	if(textfield.value.match(re))
	{
		textfield.value = textfield.value.replace(re, '\$1\$2');
		textfield.value = textfield.value.replace(/^:::::/g, '');
		textfield.value = textfield.value.replace(/:::::\$/g, '');
		textfield.value = textfield.value.replace(/::::::::::/g, ':::::');
	}
	
	if(!textfield.value || textfield.value == "")
	{
		chosen_container.innerHTML = '<div class="empty_placeholder">$TEXT{database_image_picker_no_images_label}</div>';
	}
}

function encdb_filpkr_choose(column, filename, css_id)
{
	var block_id = 'encdb_filpkr_file_' + column + '_' + css_id;
	var actionlink_id = 'encdb_filpkr_actionlink_' + column + '_' + css_id;
	
	var orig_block = gebi(block_id);
	var new_block = orig_block.cloneNode(true);
	new_block.id = 'encdb_filpkr_file_chosen_' + column + '_' + css_id;
	
	if(!gebi(new_block.id)) // avoid dupes in the chosen field.
	{
		var links_in_new_block = new_block.getElementsByTagName("a");
		for(i = 0; i < links_in_new_block.length; i++)
		{
			if(links_in_new_block[i].className.indexOf('encdb_filpkr_actionlink') != -1)
			{
				links_in_new_block[i].innerHTML = "$TEXT{database_file_picker_remove_button}";
				links_in_new_block[i].onclick = Function("encdb_filpkr_unchoose('" + column + "','" + filename + "','" + css_id + "'); return false");
			}
		}

		var chosen_container = gebi('encdb_filpkr_chosen_' + column);
		var divs_in_chosen_container = chosen_container.getElementsByTagName("div");
		for(i = 0; i < divs_in_chosen_container.length; i++)
		{
			if(divs_in_chosen_container[i].className.indexOf('empty_placeholder') != -1)
			{
				// Remove the "(none)" placeholder:
				chosen_container.removeChild(divs_in_chosen_container[i]);
			}
		}
		chosen_container.appendChild(new_block);

		var textfield = gebi("encdb_" + column);
		var re = new RegExp('(^|:::::)' + filename + '(:::::|\$)');
		if(!textfield.value.match(re))
		{
			textfield.value = textfield.value ? textfield.value + ":::::" + filename : filename;
		}
	}
}

function encdb_filpkr_unchoose(column, filename, css_id)
{
	var block_id = 'encdb_filpkr_file_chosen_' + column + '_' + css_id;
	var block_to_remove = gebi(block_id);
	var chosen_container = gebi('encdb_filpkr_chosen_' + column);
	chosen_container.removeChild(block_to_remove);

	var textfield = gebi("encdb_" + column);
	var re = new RegExp('(^|:::::)' + filename + '(:::::|\$)');
	if(textfield.value.match(re))
	{
		textfield.value = textfield.value.replace(re, '\$1\$2');
		textfield.value = textfield.value.replace(/^:::::/g, '');
		textfield.value = textfield.value.replace(/:::::\$/g, '');
		textfield.value = textfield.value.replace(/::::::::::/g, ':::::');
	}
	
	if(!textfield.value || textfield.value == "")
	{
		chosen_container.innerHTML = '<div class="empty_placeholder">$TEXT{database_file_picker_no_files_label}</div>';
	}
}

function create_ajax_object()
{
	var myRequest = false;

	if(window.XMLHttpRequest)
	{
		myRequest = new XMLHttpRequest();
		if(myRequest.overrideMimeType)
		{
			myRequest.overrideMimeType('text/xml');
		}
	}
	else if(window.ActiveXObject)
	{
		try
		{
			myRequest = new ActiveXObject("Msxml2.XMLHTTP");
		} catch (e) {
			try
			{
				myRequest = new ActiveXObject("Microsoft.XMLHTTP");
			} catch (e) {}
		}
	}

	if(!myRequest)
		alert('Error: could not create AJAX object.');

	return myRequest;
}

function do_ajax_request(url_to_get, callback_function, method, body)
{
	method = method || 'GET';
	var ajax_request = create_ajax_object();
	if(ajax_request)
	{
		ajax_request.onreadystatechange = function()
		{
			if(ajax_request)
			{
				if(ajax_request.readyState == 4)
				{
					if(ajax_request.status == 200)
					{
						//var rawdata = ajax_request.responseText.match(/<data>(.+)<\\/data>/); // NOTE: in JS, the dot doesn't match newlines, so use ((.|\\n)+) if you want to match those too.
						//callback_function(rawdata ? rawdata[1] : "");

						var rawdata = ajax_request.responseText.match(/<data>((.|\\n)+)<\\/data>/); // NOTE: in JS, the dot doesn't match newlines, so use ((.|\\n)+) if you want to match those too.
						if(rawdata)
						{
							var varstrings = new Array();
							varstrings = rawdata[1].split(':::::');
							var datahash = new Object;
							for(i = 0; i < varstrings.length; i++)
							{
								// Fails if there's more than 1 equal sign on the RHS
								//var vars = varstrings[i].split('=');
								//if(vars[0])
								//	datahash[vars[0]] = vars[1];

								var vars = varstrings[i].match(/(.+?)=(.+)/);
								if(vars)
									datahash[vars[1]] = vars[2];
							}

							callback_function(rawdata[1], datahash);
						}
						else
						{
							callback_function(ajax_request.responseText);
						}
					}
				}
			}
		}
		ajax_request.open(method, url_to_get, true);
		if(method == 'POST')
			ajax_request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
		ajax_request.send(body);
	}
}

function set_up_human_test()
{
	var htimg = gebi("encht0");
	var htfield1 = gebi("encht1");
	var htfield2 = gebi("encht2");
	var encht3 = gebi("encht3");
	var encht4 = gebi("encht4");
	if(htfield1 && htfield2)
	{
		htimg.src = htimg.src.replace(/\\w+\\.jpg/, encht3.value+'.jpg');

		htfield1.value = encht3.value;

		if(gebi("ht_is_invisible"))
			htfield2.value = encht4.value;
	}
}

function check_humanity()
{
	num_submit_checks_still_pending++;

	submitbutton_text_default = gebi("$PREF{submitbutton_id}").value;
	gebi("$PREF{submitbutton_id}").value = "$TEXT{Please_wait}";
	gebi("$PREF{submitbutton_id}").disabled = true;

	var url_to_get = '$ENV{SCRIPT_NAME}?ajax_do_humantest&encht1=' + gebi("encht1").value + '&encht2=' + gebi("encht2").value;
	do_ajax_request(url_to_get, check_humanity__finish);
}

function check_humanity__finish(req_output)
{
	num_submit_checks_still_pending--;

	gebi("$PREF{submitbutton_id}").value = submitbutton_text_default;
	gebi("$PREF{submitbutton_id}").disabled = false;

	if(req_output.match(/passed=true/))
		submit_user_form_final();
	else
		alert("$TEXT{Error__failed_human_test__please_try_again_}");
}

function parse_kvp_data(datastring)
{
	var rawvars = datastring.split('__KVPSEP__');
	var thevars = new Object;
	for(var i = 0; i < rawvars.length; i++)
	{
		var vars = rawvars[i].split('=');
		if(vars[0])
		{
			thevars[vars[0]] = vars[1];
			thevars[vars[0]] = thevars[vars[0]].replace(/::AJXNWL::/g, '\\n');
		}
	}
	return thevars;
}

function getvars(datastring)
{
	var rawvars = datastring.split(':::::');
	var thevars = {};   // new Object;   // same thing.
	for(var i = 0; i < rawvars.length; i++)
	{
		var vars = rawvars[i].match(/(\\w+?)=(.*)/)
		if(vars && vars[1])
		{
			thevars[vars[1]] = vars[2].replace(/::AJXNWL::/g, '\\n');
		}
	}
	return thevars;
}

function schedule_onload_action(newfunc)
{
	var already_scheduled = window.onload;
	if(typeof window.onload != 'function')
	{
		window.onload = newfunc;
	}
	else
	{
		window.onload = function()
		{
			already_scheduled();
			newfunc();
		}
	}
}

function overlay_msg(style, mode, hide, msg)
{
	// style is "A", "B", etc; mode is append or replace; msg is the content to display.
	var div = gebi("encoverlay") || document.createElement("div");
	div.className = "encoverlay" + style;
	div.id = "encoverlay";
	var old_content = gebi("encoverlay_msg") ? gebi("encoverlay_msg").innerHTML + '<br />' : '';
	if(mode == 'replace')
		old_content = '';
	div.innerHTML	= '<div id="encoverlay_inner" class="' + div.className + '_inner">'
			+ '<div id="encoverlay_ctrl" class="' + div.className + '_ctrl"><a href="#" onclick="remove_overlay(); return false">X</a></div>'
			+ '<div id="encoverlay_msg" class="' + div.className + '_msg">'
			+ old_content + msg
			+ '</div></div>';
	if(!gebi("encoverlay"))
		document.body.appendChild(div);
	if(hide == 'autohide')
	{
		window.setTimeout("fade_out('encoverlay')", 2000);
		window.setTimeout("remove_overlay()", 4000);
	}
}

function remove_overlay()
{
	var overlay = gebi("encoverlay");
	overlay.parentNode.removeChild(overlay);
}

function fade_out(el)
{
	el = gebi(el) || el;
	var op = 1;
	var timer = setInterval(function () {
		if(op <= 0.1)
		{
			op = 0;
			clearInterval(timer);
		}
		el.style.opacity = op;
		el.style.filter = 'alpha(opacity=' + op * 100 + ')';
		op -= op * 0.1;
	}, 40);
}

function get_pw_strength(pw)
{
	var has_upper	= pw.match(/[A-Z]/) ? 1 : 0;
	var has_lower	= pw.match(/[a-z]/) ? 1 : 0;
	var has_num	= pw.match(/[0-9]/) ? 1 : 0;
	var has_special	= pw.match(/\\W/) ? 1 : 0;

	var good_attrs = 0;
	if(has_upper)
		good_attrs++;
	if(has_lower)
		good_attrs++;
	if(has_num)
		good_attrs++;
	if(has_special)
		good_attrs++;

	var strength = '';
	if( (pw.length > 22) || ((pw.length > 18) && (good_attrs > 2)) )
	{
		strength = 'very strong';
	}
	else if( (pw.length > 18) || ((pw.length > 13) && (good_attrs > 2)) )
	{
		strength = 'strong';
	}
	else if( (pw.length > 13) || ((pw.length > 10) && (good_attrs > 2)) )
	{
		strength = 'decent';
	}
	else if(pw.length < 8)
	{
		strength = 'very weak';
	}
	else
	{
		strength = 'weak';
	}

	//gebi('pw_strength').innerHTML += '<br />length:' + pw.length + '<br />has_upper:' + has_upper + '<br />has_lower:' + has_lower + '<br />has_num:' + has_num + '<br />has_special:' + has_special;
	return strength;
}

function set_visible_cols_cookie(col, col_is_hidden)
{
	var visible_cols_cookie = get_cookie('enc_visible_cols');
	var newstatus = col_is_hidden ? 0 : 1;

	var page_id_array = location.search.match(/action=(\\w+)/);
	var page_id = page_id_array[1] || 'unknown';
	page_id = '$PREF{twochar_app_id}_' + page_id;
	var thecol = page_id + '_' + col;

	var re = new RegExp(thecol + '=\\\\d');
	if(visible_cols_cookie && visible_cols_cookie.match(re))
		visible_cols_cookie = visible_cols_cookie.replace(re, thecol+'='+newstatus);
	else
		visible_cols_cookie =
			visible_cols_cookie
			? visible_cols_cookie + thecol + '=' + newstatus + '; '
			: thecol + '=' + newstatus + '; ';

	set_cookie('enc_visible_cols', visible_cols_cookie, 2400, '/');
}

function reset_visible_cols_cookie_for_this_page()
{
	var visible_cols_cookie = get_cookie('enc_visible_cols');

	var page_id_array = location.search.match(/action=(\\w+)/);
	var page_id = page_id_array[1] || 'unknown';
	page_id = '$PREF{twochar_app_id}_' + page_id;

	var re = new RegExp(page_id + '_col_\\\\w+=\\\\d; ', 'g');
	if(visible_cols_cookie && visible_cols_cookie.match(re))
	{
		visible_cols_cookie = visible_cols_cookie.replace(re, '');
		set_cookie('enc_visible_cols', visible_cols_cookie, 2400, '/');
		location.reload();
	}
	else
	{
		alert("You haven't toggled any of the columns on this page.");
	}
}

function save_webconfig_pref(prefnum)
{
	gebi("prefresult_"+prefnum).innerHTML = 'Saving...';

	if(gebi("prefvalue_"+prefnum).value.match(/^['"].*['"]\$/))
		alert("Warning: most prefs here should not be enclosed in quotes.");

	var prefname = gebi("prefname_"+prefnum).value;
	prefname = prefname.replace(/\\\$PREF\{/, '');
	prefname = prefname.replace(/\\}/, '');
	gebi("prefname_"+prefnum).value = prefname;
	prefname = encodeURIComponent(prefname);

	var preftype  = encodeURIComponent(gebi("preftype_"+prefnum).value);
	var prefvalue = encodeURIComponent(gebi("prefvalue_"+prefnum).value);
	var parameters="prefnum="+prefnum+"&preftype="+preftype+"&prefname="+prefname+"&prefvalue="+prefvalue;

	var url_to_get = '$ENV{SCRIPT_NAME}?action=savewebconfigprefajax';
	do_ajax_request(url_to_get, save_webconfig_pref__finish, 'POST', parameters);
}

function save_webconfig_pref__finish(req_output)
{
	if(req_output.match(/setpref_success=/))
	{
		var rawdata = req_output.match(/setpref_success=(.*?):::::prefnum=(.*?):::::msg=(.*)/);
		var success = rawdata[1];
		var prefnum = rawdata[2];
		var msg = rawdata[3];
		var cssclass = success == 1 ? 'success' : 'warning';
		display_msg_fadeout("prefresult_"+prefnum, "<span class='wcfg_" + cssclass + "'>"+msg+"</span>");
	}
	else
	{
		alert("Error: failed to set webconfig pref.");
	}
}

function show_webconfig_not_saved_msg(el)
{
	gebi(el).innerHTML="<span class='wcfg_warning'>$TEXT{wcfg_not_saved}</span>";
}

function display_msg_fadeout(el,msg)
{
	if(gebi(el))
	{
		gebi(el).innerHTML = msg;
		window.setTimeout("fadeout_element('" + el + "')", 3000);
	}
}

function fadeout_element(el)
{
	if(gebi(el))
	{
		add_css_class(gebi(el), 'encfadeout');
		gebi(el).style.opacity = 0;
		window.setTimeout("empty_element_after_fadeout('" + el + "')", 3000);   // also clear the element after fading out.
	}
}

function empty_element_after_fadeout(el)
{
	if(gebi(el))
	{
		gebi(el).innerHTML = '';
		remove_css_class(gebi(el), 'encfadeout');
		gebi(el).style.opacity = 1;
	}
}

function test_db_connection()
{
	do_ajax_request('$ENV{SCRIPT_NAME}?action=testdbconnajax', test_db_connection__finish);
}

function test_db_connection__finish(req_output)
{
	if(req_output.match(/dbtest_result=/))
	{
		req_output = req_output.replace(/dbtest_result=/, '');
		gebi('db_test_output').innerHTML = req_output;
	}
	else
	{
		alert("Error: couldn't test the database connection. Output was: " + req_output);
	}
}

function send_test_email()
{
	var email_to   = gebi("email_to") ? encodeURIComponent(gebi("email_to").value) : '';
	var email_from = gebi("email_from") ? encodeURIComponent(gebi("email_from").value) : '';
	var parameters="email_to="+email_to+"&email_from="+email_from;
	gebi('email_test_output').innerHTML = '$TEXT{sending_please_wait}';
	do_ajax_request('$ENV{SCRIPT_NAME}?action=send_test_email_ajax', send_test_email__finish, 'POST', parameters);
}

function send_test_email__finish(req_output)
{
	if(req_output.match(/emailtest_result=/))
	{
		var rawdata = req_output.match(/emailtest_result=(.*)/);
		var result = rawdata[1];
		result = result.replace(/::NEWLINE::/g, '\\n');
		gebi('email_test_output').innerHTML = result;
	}
	else
	{
		alert("Error: couldn't send test email.");
	}
}

function show_pw_hash_popup(el)
{
	var div = document.createElement("div");
	div.className = "encpopup";
	div.id = "encpopup";

	div.innerHTML = '<div class="encpopup_inner">' + 
			'Enter your new password:<br /><input type="password" name="wcfg_newpw_1" id="wcfg_newpw_1" class="wcfg_newpw" /><br /><br />' +
			'Enter the password again:<br /><input type="password" name="wcfg_newpw_2" id="wcfg_newpw_2" class="wcfg_newpw" /><br /><br />' +
			'<input type="button" value="Create Hash" onclick="create_new_pw_hash()" class="wcfg_newpw_button" /><br /><br />' +
			'<input type="hidden" name="wcfg_newpw_orig_field" id="wcfg_newpw_orig_field" />' +
			'<div id="wcfg_newpw_output"></div>' +
			'<div class="encpopup_buttons">' +
			'<input id="enc_pw_popup_closebtn" type="button" value="OK" onclick="show_pw_hash_popup___finish()" /> ' +
			'</div></div>';

	document.body.appendChild(div);
	gebi('wcfg_newpw_orig_field').value = el;
}

function show_pw_hash_popup___finish()
{
	document.body.removeChild(gebi("encpopup"));
}

function create_new_pw_hash()
{
	if(gebi("wcfg_newpw_1").value == '')
	{
		gebi("wcfg_newpw_output").innerHTML = 'Password is blank.';
	}
	else if(gebi("wcfg_newpw_1").value != gebi("wcfg_newpw_2").value)
	{
		gebi("wcfg_newpw_output").innerHTML = 'Passwords do not match.';
	}
	else
	{
		var plaintextpw = encodeURIComponent(gebi("wcfg_newpw_1").value);
		var parameters="ptpw="+plaintextpw;
		do_ajax_request('$ENV{SCRIPT_NAME}?action=create_pw_hash_ajax', create_new_pw_hash__finish, 'POST', parameters);
	}
}

function create_new_pw_hash__finish(req_output)
{
	if(req_output.match(/newhash=/))
	{
		var rawdata = req_output.match(/newhash=(.*)/);
		var result = rawdata[1];
		gebi('wcfg_newpw_output').innerHTML = '<p>Your new hash is:</p><textarea style="width: 96%; height: 4em;">' + result + '</textarea>' +
							'<p>This hash has now been placed into the box for your pref, so click OK below, then click Update on that pref.</p>';
		var orig_textarea_id = gebi('wcfg_newpw_orig_field').value;
		gebi(orig_textarea_id).value = result;
	}
	else
	{
		alert("Error: failed to create password hash.");
	}
}

function urlvar(varname)
{
	var re = new RegExp('(?:^|&)' + varname + '=([^&]+)');
	var matches = location.search.substring(1).match(re);   // substring(1) to remove the "?" from the start of location.search
	if(matches)
		return matches[1];
	else
		return '';
}

// Call like this: var newqs = new_qs(location.search, "foo=bar");
// Returns the input qs except with any previous foo=* removed, and foo=bar added.
function new_qs(oldqs,newvar)
{
	var varname = newvar.match(/^(\\w+)/)[1];

	var qs = oldqs;
	qs = qs.replace(/^\\?/, '');
	qs = qs.replace(new RegExp(varname+'=[^&]*','g'), '');
	qs = qs.replace(/&+/g, '&');
	qs = qs.replace(/(^&|&\$)/, '');
	if(qs)
		qs += '&' + newvar;
	else
		qs = newvar;

	return qs;
}

function redirect_here_with_new_qs(newqs)
{
	newqs = newqs ? '?'+newqs : '';
	location.href = location.protocol + '//' + location.host + location.pathname + newqs;
}

function retag_even_and_odd_rows(elname,tagname)
{
	if(!gebi(elname))
		return;
	var rows = gebi(elname).getElementsByTagName(tagname);
	for(var i=0; i<rows.length; i++)
	{
		remove_css_class(rows[i], 'even');
		remove_css_class(rows[i], 'odd');
		if(i%2 == 0)
			add_css_class(rows[i], 'even');
		else
			add_css_class(rows[i], 'odd');
	}
}

function select_boxes(elname,elval)
{
	if(!gebi(elname))
		return;
	var inputs = gebi(elname).getElementsByTagName('input');
	for(var i=0; i<inputs.length; i++)
		if(inputs[i].type == 'checkbox')
			inputs[i].checked = elval;
}

document.write("<scr" + "ipt type='text/javascript' src='$PREF{app_base_folder}/js/js_table_sort.js'></scr" + "ipt>");
document.write("<scr" + "ipt type='text/javascript' src='$PREF{app_base_folder}/js/getElementsByClassName.js'></scr" + "ipt>");

// End-Enc-Common /////////////////////////////////////////////////////////////////


$PREF{custom_js_code}


`;

}


sub get_css_std()
{
	$PREF{css} =~ s!/\* %%custom_css_rules%% \*/!$PREF{custom_css_rules}!;
	$PREF{css} =~ s!/\* %%shared_css_rules%% \*/!$PREF{css_shared}!;
	$PREF{css} =~ s!/\* %%light_or_dark_rules%% \*/!$PREF{default_app_style} eq 'dark' ? $PREF{css_dark}.$PREF{css_shared_dark} : $PREF{css_light}.$PREF{css_shared_light}!e;
	$PREF{css} =~ s!/\* %%upload_bar_rules%% \*/!$PREF{using_upload_hook} eq 'yes' ? $PREF{css_for_upload_progress_table___hook} : $PREF{css_for_upload_progress_table___nonhook}!e;
	return $PREF{css} . "\n\n" . $PREF{css_extra};
}


sub start_html_output_std
{
	return if $PREF{start_html_output_called};
	$PREF{start_html_output_called} = 1;

	expand_custom_vars_in_prefs() unless $PREF{expand_vars_called};

	my $subtitle = shift;

	if($PREF{internal_appname} eq 'filechucker'   &&   $PREF{on_page} =~ /popupstatus|uploader/)
	{
		print_http_headers({ nocache => 1, nokeepalive => 1 });
	}
	else
	{
		print_http_headers();
	}

	if($PREF{internal_appname} eq 'userbase') { return if $qs =~ /format=mini/; }
	my $cs_stripe_js = qq`<script type="text/javascript" src="https://js.stripe.com/v2/"></script>\n` if $PREF{internal_appname} eq 'cornerstore' && $PREF{enable_stripe_checkout} =~ /yes/i;

	$PREF{extra_header_output} .= $PREF{jquery_tag} if $PREF{use_jquery} =~ /yes/i;
	$PREF{extra_header_output} .= $PREF{jstree_tag} if $PREF{enable_treestyle_download_page} =~ /yes/i;
	$PREF{extra_header_output} .= $PREF{fontawesome_tag} if $PREF{fontawesome_tag};

	$PREF{title} = $PREF{"title_$PREF{on_page}"} if exists $PREF{"title_$PREF{on_page}"};
	my $show_app_pagetitle = $PREF{"hide_app_pagetitle_on_$PREF{on_page}_page"} !~ /yes/i;
	my $show_app_subtitle  = $PREF{"hide_app_subtitle_on_$PREF{on_page}_page"} !~ /yes/i;
	my $title_for_titlebar = exists $PREF{"titlebar_title___$PREF{on_page}"} ? $PREF{"titlebar_title___$PREF{on_page}"} : exists $PREF{titlebar_title} ? $PREF{titlebar_title} : $PREF{title};
	$title_for_titlebar =~ s!%%subtitle%%!$subtitle!g;
	$title_for_titlebar =~ s!<[^>]*>!!g;

	my $styleclass = $PREF{current_app_style} ? $PREF{current_app_style} . '_style' : '';
	$styleclass .= " altmode_$QS{altmode}" if $QS{altmode};
	my $body_details = qq`id="$PREF{twochar_app_id}body" class="encapp $PREF{on_page}body $PREF{csswrapperclass} $styleclass ` . ($PREF{we_are_embedded} ? qq`$PREF{twochar_app_id}body_embedded` : qq`$PREF{twochar_app_id}body`) . qq`"`;

	if($PREF{we_are_embedded})
	{
		print	  $PREF{extra_header_output};
		print	  $PREF{body_container_start} || qq`<div $body_details>\n`;
	}
	elsif($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file})
	{
		my $title   = $PREF{title_for_template_file} || $title_for_titlebar || $subtitle;
		my $css_url = -e $PREF{static_css_real} ? $PREF{static_css_url} : "$ENV{SCRIPT_NAME}?css";
		my $js_url  = -e $PREF{static_js_real}  ? $PREF{static_js_url}  : "$ENV{SCRIPT_NAME}?js";
		my $css = qq`<link rel="stylesheet" type="text/css" media="all" href="$css_url">`;
		my $js  = qq`$cs_stripe_js<script type="text/javascript" src="$js_url"></script>`;

		open(HEADERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
		my $infh = \*HEADERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $infh, 1;
		seek $infh, 0, 0;
		my $content = '';
		while(<$infh>)
		{
			s!<title>.*?</title>!<title>$title</title>!si if $PREF{title_for_template_file};
			s#<head>#<head>\n$js#		if $PREF{encodable_app_template_js_insertion_point} =~ /top/i;
			s#</head>#$js\n</head>#		if $PREF{encodable_app_template_js_insertion_point} =~ /bottom/i;
			s#<head>#<head>\n$css#		if $PREF{encodable_app_template_css_insertion_point} =~ /top/i;
			s#</head>#$css\n</head>#	if $PREF{encodable_app_template_css_insertion_point} =~ /bottom/i;

			if(/^(.*?)(?:<!--\s*)?%%encodable_app_output%%/i)
			{
				$content .= $1; last;
			}
			else
			{
				$content .= $_;
			}
		}
		close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";
		do_template_replacements($content);
		print $content;

		print	  $PREF{extra_header_output};
		print	  $PREF{body_container_start} || qq`<div $body_details>\n`;
	}
	else
	{
		my $css = -e $PREF{static_css_real} ? qq`<link rel="stylesheet" type="text/css" media="all" href="$PREF{static_css_url}">` : qq`<style type="text/css">` . get_css() . qq`</style>`;
		my $js  = -e $PREF{static_js_real}  ? qq`<script type="text/javascript" src="$PREF{static_js_url}"></script>` : qq`<script type="text/javascript">\n/* <![CDATA[ */ \n\n` . get_js() . qq`\n\n/* ]]> */  \n</script>`;

		print	  qq`<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">`
			. qq`\n<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">`
			. qq`\n<head>\n<meta name="viewport" content="width=device-width, initial-scale=1">`
			. ($PREF{meta_content_type} || qq`\n<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />`)
			. qq`\n<title>$title_for_titlebar</title>`
			. qq`\n$cs_stripe_js$js`
			. qq`\n$css`
			. $PREF{extra_header_output}
			. qq`\n</head>`
			. qq`\n<body $body_details>`
			. qq`\n`;
	}

	$PREF{app_output_template} =~ s!%%title%%!$PREF{title}!g;
	$PREF{app_output_template} =~ s!%%subtitle%%!$subtitle ? qq`<div id="encsubtitle">$subtitle</div>` : ''!eg;
	$PREF{app_output_template} =~ s!%%%if-pagetitle%%%(.*?)%%%end-pagetitle%%%!$PREF{title} && $show_app_pagetitle ? $1 : ''!egs;
	$PREF{app_output_template} =~ s!%%%if-pagesubtitle%%%(.*?)%%%end-pagesubtitle%%%!$subtitle && $show_app_subtitle ? $1 : ''!egs;
	$PREF{app_output_template} =~ s!%%on_page%%!$PREF{on_page}!g;
	$PREF{app_output_template} =~ s!%%wide_page_css_wrapper_id%%!$PREF{on_a_wide_page} ? "$PREF{twochar_app_id}wrapper_widepage" : ''!egs;
	$PREF{app_output_template} =~ s!%%%if-onpage_(\w+)%%%(.*?)%%%endif-onpage_\1%%%!$PREF{on_page} eq $1 ? $2 : ''!egs;
	$PREF{app_output_template} =~ s!%%%ifelse-onpage_(\w+)%%%(.*?)%%%else%%%(.*?)%%%endelse-onpage_\1%%%!$PREF{on_page} eq $1 ? $2 : $3!egs;
	do_standard_template_vars_processing('include_undefined', $PREF{app_output_template});
	do_standard_template_conditionals_processing($PREF{app_output_template});

	my $output_tophalf = ($PREF{app_output_template} =~ /(.*)%%app_output_body%%/s)[0];
	my $linkbar = get_linkbar(@_);
	$output_tophalf =~ s!%%linkbar_top%%!$linkbar!g;
	print $output_tophalf;

	if($PREF{internal_appname} eq 'userbase') { print_admin_toolbar(); if(-e $PREF{default_account_temp_file}) { print qq`<div style="margin: 20px auto; max-width: 400px;">To determine your default admin account, login to your server via your normal method (FTP, etc) and then read the file $PREF{default_account_temp_file} (within your cgi-bin folder or login folder by default).&nbsp; This message will be displayed until you delete that file.</div>\n`; } }
}


sub finish_html_output_std
{
	return if $PREF{finish_html_output_called};
	$PREF{finish_html_output_called} = 1;

	if($PREF{internal_appname} eq 'userbase') { return if $qs =~ /format=mini/; }

	my $linkbar = get_linkbar(@_);
	my $output_bottomhalf = ($PREF{app_output_template} =~ /%%app_output_body%%(.*)/s)[0];
	$output_bottomhalf =~ s!%%linkbar_bottom%%!$linkbar!g;
	$output_bottomhalf =~ s!%%powered_by%%!$PREF{hide_poweredby} eq 'yes' ? '' : get_powered_by()!eg;
	print $output_bottomhalf;

	if($PREF{enable_debug} =~ /yes/i)
	{
		print qq`<div style="margin: 20px auto; min-width: 400px; max-width: 600px; padding: 5px; background: #fff; color: #444; border: 1px solid #999;">`
			. qq`Warning: you've set \$PREF{enable_debug} to 'yes'.&nbsp; If you're not having problems, you should disable this.&nbsp; And if you are having problems, you should still disable this, because in some cases it can cause features not to work.&nbsp; Only enable this temporarily.`
			. qq`\n</div>\n`;
	}

	if(($CGI::VERSION ne '')   &&   ($CGI::VERSION < 3.03)   &&   ($PREF{ignore_ancient_CGI_module} !~ /yes/i))
	{
		print qq`<div style="margin: 20px auto; min-width: 400px; max-width: 600px; padding: 5px; background: #fff; color: #444; border: 1px solid #999;">`
			. qq`Warning: your server's version of the CGI.pm Perl module is $CGI::VERSION, which is extremely outdated.&nbsp; `
			. qq`Some features like uploading may not work at all, or may be unreliable.&nbsp; To fix this, `
			. qq`<a href="http://encodable.com/sharedfaq/#oldcgi" target="_blank">update your CGI module</a>.&nbsp; `
			. qq`To ignore this problem (not recommended), add this line to the end of your prefs file: `
			. qq`\$PREF{ignore_ancient_CGI_module}='yes';</div>\n`;
	}

	print get_enc_visitor_id_iframe();
	send_event_calendar_reminders() if $PREF{internal_appname} eq 'userbase';
	check_runtime();
	#encdebughi "done app.";
	print get_extra_debug_output();

	print qq`
	<p style="max-width: 500px; font-style: italic; color: #777;">
	Thanks for trying the trial version of UserBase.&nbsp; This trial is designed for testing
	on your own website, and it has several features removed or disabled, including paid
	accounts, all app-based emails, and others.&nbsp; It also has a 4-character limit on all
	usernames and passwords.&nbsp; The <a href="http://encodable.com/userbase/">full version</a>
	doesn't have these limitations.
	</p>
	`;

	if($PREF{we_are_embedded})
	{
		print	  $PREF{body_container_end} || qq`</div><!-- end #$PREF{twochar_app_id}body -->\n`;
		print	  $PREF{extra_footer_output};
	}
	elsif($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file})
	{
		print	  $PREF{body_container_end} || qq`</div><!-- end #$PREF{twochar_app_id}body -->\n`;
		print	  $PREF{extra_footer_output};

		open(FOOTERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
		my $infh = \*FOOTERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $infh, 1;
		seek $infh, 0, 0;
		my $found_token = 0;
		my $content = '';
		while(<$infh>)
		{
			if($found_token)					{ $content .= $_; }
			elsif(/%%encodable_app_output%%(?:\s*-->)?(.*?)$/i)	{ $content .= $1; $found_token = 1; }
		}
		close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";
		do_template_replacements($content);
		print $content;
	}
	else
	{
		print	  $PREF{extra_footer_output};
		print	  qq`</body>\n</html>\n`;
	}
}


sub do_template_replacements($)
{
	return unless $_[0] =~ /<!--EncReplace\d+Start-->/;
	foreach my $pref (sort keys %PREF)
	{
		if($pref =~ /encodable_app_template_replacement_(\d+)/)
		{
			my $num = $1;
			if(exists($PREF{"encodable_app_template_replacement_${num}_test"}))
			{
				my $passed = $PREF{"encodable_app_template_replacement_${num}_test"};   # must evaluate to true.
				next unless $passed;
			}

			my $replacement = $PREF{"encodable_app_template_replacement_${num}"};
			$_[0] =~ s#<!--EncReplace${num}Start-->(.*)<!--EncReplace${num}End-->#$replacement#gs;   # the /g probably isn't really necessary...
		}
	}
}


sub check_image_modules
{
	exit_with_needprivs() unless user_is_allowed_to('do_app_administration');

	my $separator = qq`<br /><br /><hr><br />\n`;

	start_html_output("Check Image Modules");
	print qq`\n<div style="text-align: left; margin: 30px auto;">$PREF{internal_appname_nice} uses image modules in order to enable image-based features like rotation, resizing/thumbnails, etc.&nbsp; It supports 3 different methods for this: the GD Perl module, the ImageMagick Perl module, and the ImageMagick convert/identify commands; and usually only one of these is necessary.&nbsp; This page will show whether your server supports these modules.&nbsp; See <a href="http://encodable.com/filechucker/faq/#image">this FAQ</a> for more details.$separator`;

	unless($PREF{already_tested_for_im})
	{
		eval { require Image::Magick; }; $PREF{imagemagick_error} = $@;
	}
	unless($PREF{already_tested_for_gd})
	{
		eval { require GD; require GD::Simple; }; $PREF{gd_error} = $@;
	}
	foreach my $module ('ImageMagick', 'GD')
	{
		my $error = $PREF{lc($module) . "_error"};
		print qq`Attempting to load the $module Perl module... `;
		print !$error	? qq`success.`
			: qq`failed.&nbsp; The error was: <div style="margin: 20px 40px;">$error</div>`
			. qq`This means that <strong>the $module Perl module is not installed, or not installed <em>properly</em>, on your server</strong>.&nbsp; `
			. qq`This is a server error, not a $PREF{internal_appname_nice} error.&nbsp; <a href="http://encodable.com/filechucker/faq/#image">This FAQ</a> may help, `
			. qq`but you'll need to contact your hosting company if you want to get the $module Perl module installed properly.&nbsp; Or, if you have `
			. qq`root/Administrator access to your server, then we may be able to install it for you; the cost is typically 1 hour of labor.&nbsp; `
			. qq`<a href="http://encodable.com/contact/">Contact us</a> if you'd like us to look into this.`;
		print $separator;
	}

	print "Attempting to locate a 'convert' command:<br />\n";
	print "\nExecuting 'which convert': ";
	my $which_output = `which convert`;
	print $which_output && $which_output !~ /no convert in/ ? "found one or more convert commands: $which_output" : "command produced no output; no 'convert' in PATH.";
	print "<br />\n";
	print "Manually checking /usr/bin/convert: " . (-e '/usr/bin/convert' ? 'exists.' : 'does not exist.') . "<br />\n";
	print "Manually checking /usr/local/bin/convert: " . (-e '/usr/local/bin/convert' ? 'exists.' : 'does not exist.') . "<br />\n";
	print "<br />\nIf a convert command was found here, you can set \$PREF{convert_command} to it, and then enable the \$PREF{try_to_use_convert_*} settings (and probably also the \$PREF{try_to_use_identify_*} settings because an identify command probably exists in the same location).\n";
	# Note: on some hosts (GoDaddy), a file containing the string "find" followed by a space and then a slash, even if the line
	# is commented out, will trigger a malware blocker that prevents the file from being uploaded via FTP.  So use $PREF{find_cmd}
	# instead, to prevent having that particular string in the file, and thus avoid this false-positive detection.
	#print "\nExecuting '$PREF{find_cmd} / -name convert':<br />\n";
	#print `$PREF{find_cmd} / -name convert -type f`;
	print $separator;

	if($PREF{im_and_gd_disabled_internally})
	{
		print qq`Because neither the ImageMagick nor GD Perl modules are properly installed on your server, $PREF{internal_appname_nice} has internally disabled the \$PREF{try_to_use_*} prefs for them.&nbsp; You may be able to use the \$PREF{try_to_use_convert_*} settings instead.&nbsp; See <a href="http://encodable.com/filechucker/faq/#image">this FAQ</a> for more details.$separator`;
	}

	print qq`Note that this only affects the image-based features like rotation, thumbnails, etc.&nbsp; It does not affect $PREF{internal_appname_nice}'s core functionality.&nbsp; So $PREF{internal_appname_nice} itself will work just fine even if your server does not support these image modules.`;
	print qq`</div>\n`;

	print $TEXT{enc_apps_note};
	finish_html_output();
}


sub try_to_load_image_modules()
{
	# TODO: find a reliable way to test whether the jpegtran and convert binaries are available.
	# For now, just hardcode the $PREF{(jpegtran|convert)_available} = 'yes'; and use the try_to_*
	# PREF to switch it off.
	#
	#if(!jpegtran_is_available()   &&   ($PREF{try_to_use_jpegtran_for_rotation} =~ /yes/i))
	#{
	#	die_nice qq`$PREF{internal_appname}: jpegtran is not available on your server, so you must either install it, or else disable the following setting in PREFs Section 15: <br /><br />\n\$PREF{try_to_use_jpegtran_for_rotation}`;
	#}
	$PREF{jpegtran_available} = 'yes';
	$PREF{convert_available} = 'yes';
	$PREF{identify_available} = 'yes';

	# Note: the call to *_is_available() MUST come last in these if()s, so that on
	# servers where the module is corrupt, we can prevent even trying to load it,
	# by setting the PREFs to 'no'.
	#
	my $tried_im_and_failed = 1 if(($PREF{try_to_use_imagemagick_for_rotation} =~ /yes/i || $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i || $PREF{try_to_use_imagemagick_for_humantest} =~ /yes/i)   &&   !imagemagick_is_available());
	my $tried_gd_and_failed = 1 if(($PREF{try_to_use_gd_for_rotation} =~ /yes/i || $PREF{try_to_use_gd_for_resizing} =~ /yes/i || $PREF{try_to_use_gd_for_humantest} =~ /yes/i)   &&   !gd_is_available());
	if($tried_im_and_failed   &&   $tried_gd_and_failed)
	{
		$PREF{im_and_gd_disabled_internally} = 1;
		for('rotation', 'resizing', 'humantest', 'dimensions', 'tiff_webview')
		{
			$PREF{'try_to_use_imagemagick_for_' . $_} = 'no';
			$PREF{'try_to_use_gd_for_' . $_} = 'no';
		}
	}
}

sub jpegtran_is_available()
{
	$PREF{jpegtran_test_command} = 'jpegtran </dev/null >/dev/null 2>&1';
	my ($success,$msg) = enc_sys_call($PREF{jpegtran_test_command});
	if($success)	{ $PREF{jpegtran_available} = 'yes';	$PREF{jpegtran_error} = ''; }
	else		{ $PREF{jpegtran_available} = 'no';	$PREF{jpegtran_error} = "Failed to execute jpegtran: $msg"; }
	return !$PREF{jpegtran_error};
}


sub imagemagick_is_available()
{
	unless($PREF{already_tested_for_im})
	{
		$PREF{already_tested_for_im} = 1;
		eval { require Image::Magick; }; $PREF{imagemagick_error} = $@;
		$PREF{imagemagick_available} = !$PREF{imagemagick_error};
	}
	return $PREF{imagemagick_available};
}


sub gd_is_available()
{
	unless($PREF{already_tested_for_gd})
	{
		$PREF{already_tested_for_gd} = 1;
		eval { require GD; require GD::Simple; }; $PREF{gd_error} = $@;
		$PREF{gd_available} = !$PREF{gd_error};
	}
	return $PREF{gd_available};
}


sub image_humantest_possible() { return ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_humantest} =~ /yes/i   ||   $PREF{gd_available} && $PREF{try_to_use_gd_for_humantest} =~ /yes/i   ||   $PREF{convert_available} =~ /yes/i && $PREF{try_to_use_convert_for_humantest} =~ /yes/i); }


sub do_automatic_resizing($)
{
	my $files = shift;
	# hashref, formatted like this:
	# $$files{01}{name} = 'foo.jpg',
	# $$files{01}{realpath} = '/full/path/to/imagedir',
	# $$files{01}{force_overwrite} = 1 (optional).

	my @results = ();
	my $filecount = scalar keys %$files;

	if($PREF{resize_uploaded_images} =~ /yes/i   ||   $PREF{create_resized_copies_of_uploaded_images} =~ /yes/i)
	{
		foreach my $pref (sort keys %PREF)
		{
			if($pref =~ /^create_resized_copies_(\d+)__imagemagick_size$/)
			{
				my $num = $1;
				foreach my $file (sort keys %$files)
				{
					if(is_image($$files{$file}{name}))
					{
						my $file_id_for_status = $filecount == 1 ? $$files{$file}{name} : "#$file ($$files{$file}{name})";

						my $input_file_full = $$files{$file}{realpath} . '/' . $$files{$file}{name};
						condense_slashes('leave_leading_UNC', $input_file_full);

						if($PREF{create_resized_copies_of_uploaded_images} =~ /yes/i)
						{
							my $smallsize = ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) || $PREF{try_to_use_convert_for_resizing} =~ /yes/i ? $PREF{"create_resized_copies_${num}__imagemagick_size"} : gd_is_available() ? $PREF{"create_resized_copies_${num}__gd_size"} : '';

							if(-s $input_file_full > $PREF{"create_resized_copies_${num}__skip_if_bigger_than"})
							{
								push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: skipping because input file is bigger than the limit ($PREF{"create_resized_copies_${num}__skip_if_bigger_than"} bytes).`;
								next;
							}

							my $output_dir = $PREF{"create_resized_copies_${num}__location_type"} eq 'absolute' ? $PREF{"create_resized_copies_${num}__folder_name"} . $$files{$file}{localpath} : $$files{$file}{realpath};
							$output_dir .= '/' . $PREF{"create_resized_copies_${num}__folder_name"} if $PREF{"create_resized_copies_${num}__folder_name"} && $PREF{"create_resized_copies_${num}__location_type"} eq 'relative';
							condense_slashes('leave_leading_UNC', $output_dir);
							create_dir_if_DNE($output_dir,$PREF{writable_dir_perms},'make_parents');

							my $output_file = $PREF{"create_resized_copies_${num}__new_filename"};
							my ($origname,$ext) = ($$files{$file}{name} =~ /(.+)\.(.+)/);
							$output_file =~ s!%%orig%%!$origname!g;
							$output_file =~ s!%%ext%%!$ext!g;

							my $output_file_full = $output_dir . '/' . $output_file;
							#unless($PREF{overwrite_existing_files} =~ /yes/i)
							if($PREF{"create_resized_copies_${num}__serialize_or_overwrite"} eq 'serialize')
							{
								$output_file_full = serialize_filename_if_file_exists($output_file_full);

								# Make sure to do the skip-if-exists check before the image-dims check, because
								# the latter is expensive.
								# Update 20121030: but only do this check if we're in 'serialize' mode; otherwise
								# we're in 'overwrite' mode so we don't care whether the output file already exists.
								#
								if(-e $output_file_full && !$$files{$file}{force_overwrite})
								{
									push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: skipping because output file already exists.`;
									next;
								}
							}

							my ($origw,$origh) = get_image_dims($input_file_full);
							my ($thumbw,$thumbh) = ($smallsize =~ /^(\d*)x?(\d*)$/i);
							if($origw > $thumbw || $origh > $thumbh || !$origw || !$thumbw)
							{
								#resize_image($input_file_full, $output_file_full, $smallsize);
								my ($success,$msg) = resize_image___withtimeout($PREF{image_resizing_timeout}, $input_file_full, $output_file_full, $smallsize);
								push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: error: $msg` unless $success;
								push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: OK.` if -e $output_file_full;
								push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: failed (output file does not exist afterwards).` unless -e $output_file_full;
							}
							else
							{
								copy($input_file_full, $output_file_full) or die_nice "couldn't copy image file '$input_file_full' to thumbnail file '$output_file_full': $!\n";
								push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: OK (copied from original because original was already small enough).` if -e $output_file_full;
								push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: failed (tried to copy from original because original was already small enough).` unless -e $output_file_full;
							}
							chmod $PREF{writable_file_perms}, $output_file_full;

							if($PREF{"create_resized_copies_${num}__store_in_db"} =~ /yes/i)
							{
								my $image_data = cat($output_file_full);
								my $ext = lc(   ($output_file_full =~ m!\.(\w+)$!)[0]   );
								my $col = $PREF{"create_resized_copies_${num}__db_column_name"};
								my $statement = "UPDATE `$PREF{upload_log_table}` SET `$col` = ?, `${col}_type` = ? WHERE `id` = $$files{$file}{upload_info_db_record_id}";
								my $sth = $PREF{dbh}->prepare($statement);
								$sth->execute($image_data, $ext) or die_nice qq`Failed to insert image data into database for column '$col': $DBI::errstr`;
							}
						}

						if($PREF{resize_uploaded_images} =~ /yes/i)
						{
							next if -s $input_file_full > $PREF{resize_uploaded_images__skip_if_bigger_than};

							my $smallsize = ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) || $PREF{try_to_use_convert_for_resizing} =~ /yes/i ? $PREF{resize_uploaded_images__imagemagick_size} : gd_is_available() ? $PREF{resize_uploaded_images__gd_size} : '';
							my ($origw,$origh) = get_image_dims($input_file_full);
							my ($thumbw,$thumbh) = ($smallsize =~ /^(\d*)x?(\d*)$/i);
							if($origw > $thumbw || $origh > $thumbh || !$origw || !$thumbw)
							{
								#resize_image($input_file_full, $input_file_full, $smallsize);
								my ($success,$msg) = resize_image___withtimeout($PREF{image_resizing_timeout}, $input_file_full, $input_file_full, $smallsize);
								push @results, qq`Resizing $file_id_for_status to ${smallsize}px: error: $msg` unless $success;
								push @results, qq`Resizing $file_id_for_status to ${smallsize}px: OK.` if -e $input_file_full;
								chmod $PREF{writable_file_perms}, $input_file_full;
							}
						}
					}
				}
			}
		}
	}

	return @results;
}


sub do_batch_resizing($)
{
	my $optsref = shift; my %opts = %$optsref;

	my ($input_dir_full,$input_file_name) = split_path_and_filename($opts{input_file_full});
	$opts{skip_files_bigger_than} ||= 100*1024*1024;
	my @results = ();

	if(!is_image($input_file_name))
	{
		push @results, qq`Error: not an image file: '$input_file_name'.  Skipping.`;
		return @results;
	}

	if(-s $opts{input_file_full} > $opts{skip_files_bigger_than})
	{
		push @results, qq`Error: not resizing $input_file_name because input file is bigger than the limit ($opts{skip_files_bigger_than} bytes).`;
		return @results;
	}

	my $i = 80;   # start high to avoid clobbering anything.
	foreach my $size (split(/\s*,\s*/, $opts{other_sizes}))
	{
		$opts{"create_resized_copy_${i}_size"} = $size;
		if($opts{create_resized_copy_01_output_dir_full} =~ /^(.+?)\d+px(.*)$/)
		{
			$opts{"create_resized_copy_${i}_output_dir_full"} = $1 . $size . 'px' . $2;
		}
		else
		{
			exit_with_error qq`Error: couldn't determine output dir for other_size image ($size) from create_resized_copy_01_output_dir_full ($opts{create_resized_copy_01_output_dir_full}).`;
		}
		$i++;
	}

	foreach my $opt (sort keys %opts)
	{
		if($opt =~ /^create_resized_copy_(\d+)_size$/)
		{
			my $num = $1;

			my $smallsize = $opts{"create_resized_copy_${num}_size"};
			$smallsize = ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) || $PREF{try_to_use_convert_for_resizing} =~ /yes/i ? "${smallsize}x${smallsize}" : gd_is_available() ? $smallsize : '';

			my $output_dir = $opts{"create_resized_copy_${num}_output_dir_full"};
			create_dir_if_DNE($output_dir,$PREF{writable_dir_perms},'make_parents');

			my $output_file_full = $output_dir . '/' . $input_file_name;
			if($opts{"create_resized_copy_${num}_output_already_exists_action"} eq 'serialize')
			{
				$output_file_full = serialize_filename_if_file_exists($output_file_full);
			}
			if($opts{"create_resized_copy_${num}_output_already_exists_action"} eq 'skip'   &&   -e $output_file_full)
			{
				push @results, qq`Creating ${smallsize}px resized copy of $input_file_name: skipping because output file already exists.`;
				next;
			}
			# else we'll overwrite any existing file.

			my ($origw,$origh) = get_image_dims($opts{input_file_full});
			my ($neww,$newh) = ($smallsize =~ /^(\d*)x?(\d*)$/i);
			if($origw > $neww || $origh > $newh || !$origw || !$neww)
			{
				my ($success,$msg) = $opts{use_timeout} ? resize_image___withtimeout($PREF{image_resizing_timeout}, $opts{input_file_full}, $output_file_full, $smallsize) : resize_image($opts{input_file_full}, $output_file_full, $smallsize);
				push @results, qq`Creating ${smallsize}px resized copy of $input_file_name: error: $msg` unless $success;
				push @results, qq`Creating ${smallsize}px resized copy of $input_file_name: OK.` if -e $output_file_full;
				push @results, qq`Creating ${smallsize}px resized copy of $input_file_name: failed (output file does not exist afterwards).` unless -e $output_file_full;
			}
			else
			{
				copy($opts{input_file_full}, $output_file_full) or die_nice "couldn't copy image file '$opts{input_file_full}' to output file '$output_file_full': $!\n";
				push @results, qq`Creating ${smallsize}px resized copy of $input_file_name: OK (copied from original because original was already small enough).` if -e $output_file_full;
				push @results, qq`Creating ${smallsize}px resized copy of $input_file_name: failed (tried to copy from original because original was already small enough).` unless -e $output_file_full;
			}
			chmod $PREF{writable_file_perms}, $output_file_full;
		}
	}

	if($opts{resize_the_original_to_this_size})
	{
		my $smallsize = ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) || $PREF{try_to_use_convert_for_resizing} =~ /yes/i ? "$opts{resize_the_original_to_this_size}x$opts{resize_the_original_to_this_size}" : gd_is_available() ? $opts{resize_the_original_to_this_size} : '';
		my ($origw,$origh) = get_image_dims($opts{input_file_full});
		my ($neww,$newh) = ($smallsize =~ /^(\d*)x?(\d*)$/i);
		if($origw > $neww || $origh > $newh || !$origw || !$neww)
		{
			my ($success,$msg) = $opts{use_timeout} ? resize_image___withtimeout($PREF{image_resizing_timeout}, $opts{input_file_full}, $opts{input_file_full}, $smallsize) : resize_image($opts{input_file_full}, $opts{input_file_full}, $smallsize);
			push @results, qq`Resizing $input_file_name to ${smallsize}px: error: $msg` unless $success;
			push @results, qq`Resizing $input_file_name to ${smallsize}px: OK.` if -e $opts{input_file_full};
			chmod $PREF{writable_file_perms}, $opts{input_file_full};
		}
	}

	return @results;
}


sub get_image_dims
{
	my $filename = shift;
	my ($width, $height, $xres, $yres) = ();
	my $decpoints = $PREF{num_decimal_points_for_image_details} =~ /^(\d+)$/ ? $1 : 2;
	if($PREF{identify_available} =~ /yes/i && $PREF{try_to_use_identify_for_dimensions} =~ /yes/i)
	{
		my $info = `$PREF{identify_command} -verbose "$filename"`;
		($width,$height) = ($1,$2) if $info =~ /^\s*Geometry:\s*(\d+)x(\d+)/m;
		($xres,$yres) = ($1,$2) if $info =~ /^\s*Resolution:\s*(\d+)x(\d+)/m;

		# This works, and doesn't require reading the whole image into memory so it's
		# quicker, but it can only get a few image attributes, not all of them.
		#
		#my $info = `$PREF{identify_command} "$filename"`;
		#($width,$height) = ($1,$2) if $info =~ /^$filename [A-Z]+ (\d+)x(\d+) /   ||   $info =~ /^$filename [A-Z]+ (\d+)x(\d+)\+\d+\+\d+ /;
	}
	elsif($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_dimensions} =~ /yes/i)
	{
		my $image = new Image::Magick;
		my $x = $image->Read($filename);
		#die_nice "ImageMagick Read() error: $x" if "$x"; # seems to die too easily, i.e. for unknown meta tags in an otherwise OK image.
		($width, $height, $xres, $yres) = $image->Get('width', 'height', 'x-resolution', 'y-resolution');

		# This works, and doesn't require reading the whole image into memory so it's
		# quicker, but it can only get a few image attributes, not all of them.
		#
		#my $image = new Image::Magick;
		#my ($width, $height, $size, $format) = $image->Ping($filename);
		#return ($width, $height);

		# This works, but the output goes directly to STDOUT/STDERR instead of into @details.
		#
		#my $image = new Image::Magick;
		#my $x = $image->Read($filename);
		#die_nice "ImageMagick Read() error: $x" if "$x";
		#my @details = $image->Identify();
		##die_nice (qq`Details: \n<br />` . join("\n<br /><br />", @details));
	}
	elsif(gd_is_available() && $PREF{try_to_use_gd_for_dimensions} =~ /yes/i)
	{
		my $image = GD::Image->new($filename);
		($width,$height) = ($image->width, $image->height) if $image;
	}

	# Some (corrupt?) images report screwy resolutions, e.g. "72/10000" instead of "72/1"; when
	# that happens, try to correct it from the other dimension's resolution:
	$xres = $yres if $xres < 1 && $yres > 1;
	$yres = $xres if $yres < 1 && $xres > 1;

	my $width_inches  = $width  && $xres ? $width/$xres  : '';
	my $height_inches = $height && $yres ? $height/$yres : '';

	for($xres, $yres, $width_inches, $height_inches)
	{
		s!(\.\d{$decpoints}).+!$1!; $_ = int($_) unless $decpoints;
	}

	return ($width, $height, $xres, $yres, $width_inches, $height_inches);
}


sub resize_image___withtimeout
{
	my $timeout = shift;
	my $ignore_other_errors	= $_[0] eq 'ignore_other_errors' ? shift : '';
	my $timeouts_are_errors	= $_[0] eq 'timeouts_are_errors' ? shift : '';
	my ($success, $msg) = ();

	#use Time::HiRes 'gettimeofday';
	#my $starttime = gettimeofday();

	if($timeout)
	{
		my $ipc_msg_id = generate_nonce();

		if(0) # eval method: (doesn't always work; for exaple with timeout set to 8, a certain image still takes 100+ seconds??)
		{
			eval {
				local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
				alarm $timeout;
				my ($success, $msg) = resize_image(@_);
				alarm 0;
				die $msg unless $success;
			};
			if($@)
			{
				if($@ eq "alarm\n")	{ $timeouts_are_errors	&& die_nice("Timed out while trying to resize image.\n");	} # timed out.
				else			{ $ignore_other_errors	|| die_nice("Error while trying to resize image: $@\n");	} # propagate unexpected errors.
			}
			# else it didn't time out.
		}
		else # fork method:
		{
			my $pid = fork;
			defined $pid or die_nice "Could not fork: $!\n";
			unless ($pid) {
				# child:
				local $SIG{ALRM} = 'DEFAULT';
				alarm $timeout;
				my ($success, $msg) = resize_image(@_);
				alarm 0;
				#die $msg unless $success; # must be die, not die_nice, in the child.
				pass_child_error_to_parent($ipc_msg_id, $msg) unless $success;
				exit; # exit the child.
			}
			waitpid $pid, 0;
			
			# The $? and ${^CHILD_ERROR_NATIVE} seem to require the child to die() in order
			# to be set, but they don't actually contain the string passed to die(), and the
			# client still sees the ugly die() output, so this isn't really a great solution.
			#
			#die_nice $? if $?;
			#die_nice ${^CHILD_ERROR_NATIVE} if ${^CHILD_ERROR_NATIVE};

			($success, $msg) = read_child_error($ipc_msg_id);
		}
	}
	else { ($success, $msg) = resize_image(@_); }

	#print STDERR "resize_image___withtimeout: timeout set to $timeout; actual time was " . int(gettimeofday() - $starttime) . "\n";
	
	return ($success, $msg);
}


# 20110911: APICHANGE: previously this sub returned nothing; now it returns
# ($success, $message).  This change means that any existing code calling
# this sub must now check for success itself, and die if success=0.
#
sub resize_image
{
	my $infile = shift;
	my $outfile = shift;
	my $newW = shift;
	my $newH = shift;

	return unless -s $infile;

	my $geom = ();
	if($newW =~ /(\d*)x(\d*)[!^]?/i)
	{
		$geom = $newW;
		($newW,$newH) = ($1,$2);
	}
	else
	{
		$geom = $newW . 'x' . $newH;
	}

	unless($newW =~ /[1-9]/ || $newH =~ /[1-9]/)
	{
		my $errormsg = "can't resize image because at least one of the dimensions must be specified (\$newW='$newW', \$newH='$newH')\n";
		encdebug $errormsg;
		return(0, $errormsg);
	}

	if($PREF{convert_available} =~ /yes/i   &&   $PREF{try_to_use_convert_for_resizing} =~ /yes/i)
	{
		#enc_warn qq`using convert: geom=$geom\n`;

		my $cmd = $PREF{convert_resize_template};
		$cmd =~ s!%%size%%!${newW}x${newH}!g;
		$cmd =~ s!%%geom%%!$geom!g;
		$cmd =~ s!%%infile%%!$infile!g;
		$cmd =~ s!%%outfile%%!$outfile!g;
		my ($success,$msg) = enc_sys_call($cmd);
		unless($success) { return(0, "failed: $msg"); }
	}
	elsif($PREF{imagemagick_available}   &&   $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i)
	{
		#enc_warn qq`using IM: geom=$geom\n`;

		my $image = new Image::Magick;
		my $retval = ();

		$retval = $image->Read($infile);
		if($retval)	{ printd "error: \$image->Read()   returned $retval.\n"; return;	}

		$retval = $image->Resize(geometry=>$geom, filter=>'Lanczos');
		if($retval)	{ printd "error: \$image->Resize() returned $retval.\n"; return;	}

		$image->Set(quality=>95);
		$image->Write($outfile);
	}
	elsif(gd_is_available()   &&   $PREF{try_to_use_gd_for_resizing} =~ /yes/i)
	{
		#enc_warn qq`using GD\n`;

		my $inputimage = GD::Image->new($infile);
		if(!$inputimage)	{ printd "error: GD::Image->new($infile) returned null...\n"; return;	}

		my $oldW = $inputimage->width;
		my $oldH = $inputimage->height;

		return(0, "can't resize image because a dimension is missing (\$oldW='$oldW', \$oldH='$oldH')\n") unless $oldW =~ /[1-9]/ && $oldH =~ /[1-9]/;

		if(!$newW)
		{
			$newW = ($newH * $oldW) / $oldH;
			$newW =~ s/\..*//;
		}
		if(!$newH)
		{
			$newH = ($newW * $oldH) / $oldW;
			$newH =~ s/\..*//;
		}

		my $outputimage = GD::Image->newTrueColor($newW,$newH);
		$outputimage->copyResampled($inputimage,0,0,0,0,$newW,$newH,$oldW,$oldH);
		open(RESIMG, ">$outfile") or return(0, "couldn't create file '$outfile': $!\n");
		my $fh = \*RESIMG; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		binmode $fh;
		   if($outfile =~ /\.jpe?g$/i)	{ print $fh $outputimage->jpeg(95);	}
		elsif($outfile =~ /\.png$/i)	{ print $fh $outputimage->png(3);	}
		elsif($outfile =~ /\.gif$/i)	{ print $fh $outputimage->gif();	}
		else				{ return(0, "image format not supported by GD.\n"); }
		close $fh or return(0, "couldn't close file '$outfile' after creating it: $!\n");
	}
	else
	{
		return(0, "no image-resizing library available.");
	}

	my $errormsg = qq`Output file does not exist after resizing; try adjusting or disabling \$PREF{image_resizing_timeout} and other image/video timeouts.`;
	encdebug $errormsg;
	return(0, $errormsg) unless -f $outfile;
}


sub image_orientation_is_resettable($)
{
	my $filename = shift;
	return 0 unless $filename =~ /\.(jpg|jpe|jpeg)$/i;
	return command_is_available("exiftool") || command_is_available("exifautotran");
}


sub reset_image_orientation($)
{
	my $filename_with_path = shift;
	exit_with_error qq`file doesn't exist: '$filename_with_path'.` unless -e $filename_with_path;
	if(command_is_available("exiftool"))
	{
		system("exiftool -q -n -P -Orientation=1 \"$filename_with_path\"");
	}
	elsif(command_is_available("exifautotran"))
	{
		system("exifautotran \"$filename_with_path\"");
	}
	else
	{
		exit_with_error qq`no image-orientation-resetting program available.`;
	}
	chmod $PREF{writable_file_perms}, $filename_with_path;
}


# Prereqs: the passed command must be *just* a command; it must
# not contain any arguments.  (But because of systems with dumb
# setups (i.e. Windows), the command may still contain spaces.)
# The reason is that we'll actually execute whatever command is
# passed in, so including arguments on it will make the command
# actually do stuff, as opposed to just executing and quitting,
# as most commands will do when no arg is passed.
#
sub command_is_available($)
{
	my $cmd = shift;
	my $retval = $^O =~ /MSWin/ ? system("$cmd >NUL 2>NUL") : system("$cmd >/dev/null 2>&1");
	my $failed = 0;
	$failed = 1 if $? == -1;
	#$failed = 1 if $? & 127;
	$failed = 1 if $retval != 0;
	return $failed ? 0 : 1;
}


sub it_is_time_for_periodic_task($)
{
	# Usage: create a task in your prefs like this:
	#
	#	$PREF{periodic_tasks}{01}{name}		= 'some_task';
	#	$PREF{periodic_tasks}{01}{enabled}	= 'yes';
	#	$PREF{periodic_tasks}{01}{period}	= 60*10; # in seconds; or Mon/Tue/Wed/Thu/Fri/Sat/Sun for weekly tasks (can specify multiple days, comma-separated).
	#	$PREF{periodic_tasks}{01}{weekly_init}	= 'yes'; # for weekly tasks, if they've never been run before, this will run them one time immediately even if today isn't the right day.
	#
	# Then in the code, do this:
	#
	#	do_the_some_task_function() if it_is_time_for_periodic_task('some_task');

	my $taskname = shift;
	my $period = '';
	my $enabled = 0;
	my $weekly_init = 0;
	foreach my $i (sort { $a <=> $b } keys %{$PREF{periodic_tasks}})
	{
		if($PREF{periodic_tasks}{$i}{name} eq $taskname)
		{
			$period = $PREF{periodic_tasks}{$i}{period};
			$enabled = $PREF{periodic_tasks}{$i}{enabled} =~ /yes/i;
			$weekly_init = $PREF{periodic_tasks}{$i}{weekly_init} =~ /yes/i;
		}
	}
	return unless $taskname && $enabled;
	my $task_is_weekly = $period =~ /(mon|tue|wed|thu|fri|sat|sun)/i;
	exit_with_error qq`Error: missing or invalid period setting for periodic task "$taskname".  You must create a \$PREF{periodic_tasks}{NN}{period} setting, and set it to either a number, indicating the number of seconds to wait between executions of this particular task, or else a 3-char weekday abbreviation (Mon, Tue, Wed, Thu, Fri, Sat, or Sun [or a comma-separated list of multiple days]) indicating a weekly task.` unless $task_is_weekly || $period =~ /^\d+$/;

	my $taskslist = $PREF{datadir} . "/periodic_tasks_log.cgi";
	create_file_if_DNE($taskslist, $PREF{writable_file_perms});
	open(my $iofh, "+<$taskslist") or die_nice qq`couldn't open taskslist file '$taskslist' for I/O: $!`;
	flock $iofh, 2;
	seek $iofh, 0, 0;
	my @contents = ();
	my $time_of_last_execution = '';
	while(<$iofh>)
	{
		chomp;
		if(/^(\d+):$taskname$/)
		{
			$time_of_last_execution = $1;
		}
		else
		{
			push @contents, "$_\n";
		}
	}

	my $it_is_time = 0;
	if($task_is_weekly)
	{
		foreach my $day (split(/\s*,\s*/, $period))
		{
			my $today_is_the_day = lc($day) eq lc(strftime("%a",localtime(offsettime())));
			my $task_already_ran_today = strftime("%Y%m%d",localtime($time_of_last_execution)) eq $PREF{today};

			if(!$time_of_last_execution)
			{
				if($today_is_the_day || $weekly_init)
				{
					$it_is_time = 1;
					encdebug qq`This weekly task has never been executed before, and today is $day (or weekly_init is true), so we will run it now [$taskname].`;
					last;
				}
				else
				{
					encdebug qq`This weekly task has never been executed before, but today isn't $day, and weekly_init is false, so we won't run it now [$taskname].`;
				}
			}
			elsif($today_is_the_day && !$task_already_ran_today)
			{
				$it_is_time = 1;
				encdebug qq`This weekly task hasn't run yet today, and today is the day, so we will run it now [$taskname].`;
				last;
			}
			elsif($task_already_ran_today)
			{
				encdebug qq`This weekly task already ran today, so we won't run it [$taskname].`;
				last;
			}
			else
			{
				encdebug qq`This weekly task is scheduled for $day, not today, so we won't run it [$taskname].`;
				# no last here, in case task is scheduled on multiple days of the week.
			}
		}
	}
	else
	{
		if(!$time_of_last_execution)
		{
			$it_is_time = 1;
			encdebug qq`This task has never been executed before, so it IS time for task $taskname.`;
		}
		elsif((offsettime() - $time_of_last_execution) > $period)
		{
			$it_is_time = 1;
			encdebug qq`offsettime() - $time_of_last_execution = ` . (offsettime() - $time_of_last_execution) . qq`, which exceeds the period of $period, so it IS time for task $taskname.`;
		}
		else
		{
			encdebug qq`offsettime() - $time_of_last_execution = ` . (offsettime() - $time_of_last_execution) . qq`, which is less than $period, so it is not time for task $taskname.`;
		}
	}

	if($it_is_time)
	{
		push (@contents, offsettime() . ":" . $taskname . "\n");
		seek $iofh, 0, 0; print $iofh @contents; truncate $iofh, tell $iofh;
	}

	close $iofh or die_nice qq`couldn't close taskslist file '$taskslist' after I/O: $!`;

	return $it_is_time;
}


sub create_periodic_task($)
{
	my $optsref = shift; my %opts = %$optsref if $optsref;
	my $taskn = 50; $taskn++ while exists $PREF{periodic_tasks}{$taskn};
	$PREF{periodic_tasks}{$taskn}{name}	= $opts{name};
	$PREF{periodic_tasks}{$taskn}{enabled}	= $opts{enabled};
	$PREF{periodic_tasks}{$taskn}{period}	= $opts{period};   # in seconds.
}


sub update_static_css_and_js_files
{
	my $force = shift; $force = 1 if $PREF{admin_is_logged_in} && $QS{updatestatic} eq 'yes';

	$PREF{static_css_url}	||= "$PREF{appdir_url}/$PREF{twochar_app_id}.css";
	$PREF{static_js_url}	||= "$PREF{appdir_url}/$PREF{twochar_app_id}.js";
	$PREF{static_css_real}	||= "$PREF{appdir_real}/$PREF{twochar_app_id}.css";
	$PREF{static_js_real}	||= "$PREF{appdir_real}/$PREF{twochar_app_id}.js";

	create_periodic_task({	name => 'update_static_css_and_js_files',
				enabled => $PREF{update_static_css_and_js_files_at_regular_interval} ? 'yes' : 'no',
				period  => $PREF{update_static_css_and_js_files_at_regular_interval} || 60*60*12 });

	my $it_is_time = it_is_time_for_periodic_task('update_static_css_and_js_files');

	my $css_missing = my $js_missing = 0;
	my $css_outdated = my $js_outdated = 0;
	if(!$force && !$it_is_time)   # if either of those is true, don't bother with these other tests, to avoid the unnecessary filesystem checks.
	{
		if($PREF{create_static_css_and_js_files_automatically} =~ /yes/i)
		{
			$css_missing = 1 unless -f $PREF{static_css_real};
			$js_missing  = 1 unless -f $PREF{static_js_real};
		}

		if($PREF{update_static_css_and_js_files_when_prefs_file_changes} =~ /yes/i)
		{
			foreach my $prefs_or_script_file ($ENV{SCRIPT_FILENAME}, split(/[,\s]+/, $PREF{loaded_prefs_files}), $PREF{webconfig_file})
			{
				$css_outdated = 1 if (-M $PREF{static_css_real}) > (-M $prefs_or_script_file);
				$js_outdated  = 1 if (-M $PREF{static_js_real})  > (-M $prefs_or_script_file);
			}
		}
	}

	if($force || $it_is_time || $css_missing || $css_outdated)
	{
		encdebug "updating CSS (it_is_time=$it_is_time; missing=$css_missing; outdated=$css_outdated)";
		create_file_if_DNE($PREF{static_css_real}, $PREF{writable_file_perms});
		add_text_to_file(qq`/* This file is created/updated automatically and should not be changed in most cases; edit \$PREF{css} instead. */\n`.get_css(), $PREF{static_css_real}, 'clobber');
	}

	if($force || $it_is_time || $js_missing || $js_outdated)
	{
		encdebug "updating JS (it_is_time=$it_is_time; missing=$js_missing; outdated=$js_outdated)";
		create_file_if_DNE($PREF{static_js_real},  $PREF{writable_file_perms});
		add_text_to_file(qq`// This file is created/updated automatically and should not be changed in most cases; edit \$PREF{custom_js_code} instead.\n`.get_js(),  $PREF{static_js_real},  'clobber');
	}
}


sub cat($)
{
	my $file = shift;
	open(my $infh, $file) or die_nice "couldn't open file '$file' for reading: $!\n";
	flock $infh, 1;
	seek $infh, 0, 0;
	my @contents = <$infh>;
	close $infh or die_nice "couldn't close file '$file' after reading: $!\n";
	return wantarray ? @contents : join('', @contents);
}


sub enc_head
{
	my $file = shift;
	my $numlines = shift || 10;
	open(my $infh, $file) or die_nice "couldn't open file '$file' for reading: $!\n";
	flock $infh, 1;
	seek $infh, 0, 0;
	my $i = 0;
	my @contents = ();
	while(<$infh>)
	{
		push @contents, $_;
		$i++;
		last if $i == $numlines;
	}
	close $infh or die_nice "couldn't close file '$file' after reading: $!\n";
	return wantarray ? @contents : join('', @contents);
}


sub enc_param
{
	my $varname = shift;
	my $query = shift;   # optional
	my $value = $query ? $query->param($varname) : param($varname);

	# Block potential XSS attempts.
	die "Invalid form data\n" if xss_match($value);

	return $value;
}


sub xss_match
{
	return (
			(   $_[0] =~ m!(<script|script>|%3Cscript|script%3E)!i   )
		||	(   enc_urldecode_return($_[0]) =~ m!(<script|script>|%3Cscript|script%3E)!i   )

		||	(   $_[0] =~ m!(<svg|svg>|%3Csvg|svg%3E)!i   )
		||	(   enc_urldecode_return($_[0]) =~ m!(<svg|svg>|%3Csvg|svg%3E)!i   )

		||	(   $_[0] =~ m!(^|&)(action|phase)=([^&]+)!   &&   $2 =~ /\W/   )   # the ?action/?phase URL vars should only accept word-chars in their values.
		||	(   $_[0] =~ m!(^|&)whence=(.+)!   &&   $1 =~ /[<>]/   )   # don't allow gt/lt in the ?whence URL var.
	);
}


sub check_input_data
{
	my $hashref = shift;
	foreach my $name (keys %$hashref)
	{
		die "Invalid form data\n" if xss_match($name) || xss_match($$hashref{$name});
	}
}


sub dump_db_table
{
	my $table = shift;
	die_unless_sqlsafe($table);
	my $output = '';
	my %fieldnames = ();
	my $data = enc_sql_select_multi("SELECT * FROM `$table` ORDER BY `id`");
	foreach my $row (sort { $a <=> $b } keys %$data)
	{
		$output .= qq`<tr>`;
		my $i = 1;
		foreach my $field (sort keys %{$$data{$row}})
		{
			$fieldnames{$i} = $field if $row == 1;
			$output .= qq`<td>$$data{$row}{$field}</td>`;
			$i++;
		}
		$output .= qq`</tr>\n`;
	}
	my $fieldname_list = '<tr>';
	foreach my $fieldname (sort { $a <=> $b } keys %fieldnames)
	{
		$fieldname_list .= qq`<th>$fieldnames{$fieldname}</th>`;
	}
	$fieldname_list .= "</tr>\n";
	$output = qq`<table>\n$fieldname_list\n$output\n</table>\n`;
	return $output;
}


sub write_to_filehandle
{
	my $fh			= shift;
	my $position		= shift;   # start, end, or null for no seek.
	my $lock_and_unlock	= shift;   # bool
	my $truncate		= shift;   # bool; sometimes required in order to flush the fh in realtime.
	my $data		= shift;

	flock($fh, 2) if $lock_and_unlock;
	seek($fh, 0, 0) if $position eq 'start';
	seek($fh, 0, 2) if $position eq 'end';
	print $fh $data;
	truncate($fh, tell $fh) if $truncate;
	flock($fh, 8) if $lock_and_unlock;
}


sub check_runtime
{
	my $runtime = time - $PREF{app_start_time};   # in seconds.
	my $limit = $PREF{perpage_runtime_limit} || $PREF{runtime_emailalert_time_limit};

	return unless $limit;
	return unless $runtime > $limit;
	return if $PREF{skip_runtime_check_on_this_page};

	my $custom_output = '';
	foreach my $cmd (split(/\s*,\s*/, $PREF{runtime_emailalert_custom_commands}))
	{
		my $output = `$cmd`;
		$custom_output .= qq`\nCommand: $cmd\nOutput:\n$output\n__________\n`;
	}

	my $subject = $PREF{runtime_emailalert_subject};
	my $message = $PREF{runtime_emailalert_body};

	for($subject, $message)
	{
		s!%%runtime%%!$runtime!g;
		s!%%custom_output%%!$custom_output!g;
	}

	foreach my $recipient(split(/\s*,\s*/, $PREF{runtime_emailalert_recipients}))
	{
		send_email({ to => $recipient, from => $PREF{runtime_emailalert_sender}, subject => $subject, message => $message, mimetype => $PREF{runtime_emailalert_type}, die_on_error => $PREF{runtime_emailalert_failure_action} });
	}
}


sub get_content_type_from_ext($)
{
	my $ext = shift; $ext = lc($ext);
	my $content_type = '';
	eval { require MIME::Types; }; $PREF{MIME_Types_error} = $@;
	if($PREF{MIME_Types_error} || $PREF{dont_use_the_mime_types_module} =~ /yes/i)
	{
		$content_type = $PREF{"mimetype_for_${ext}"};
	}
	else
	{
		my $mimetypes = MIME::Types->new;
		#my MIME::Type $the_type = $mimetypes->mimeTypeOf($ext);
		my $the_type = $mimetypes->mimeTypeOf($ext);
		$content_type = $the_type;
	}
	$content_type ||= 'application/octet-stream';
	return $content_type;
}


sub create_sent_mail_table_if_DNE
{
	my $table = $PREF{sent_mail_table};
	unless(db_table_exists($table))
	{
		enc_warn "table $table does not exist; attempting to create it now.\n";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `timestamp_sent` BIGINT UNSIGNED NOT NULL, "
				. " `to` VARCHAR(255) NOT NULL, "
				. " `from` VARCHAR(255) NOT NULL, "
				. " `subject` VARCHAR(255) NOT NULL, "
				. " `body` TEXT NOT NULL, "
				. " `methods_tried` TEXT NOT NULL, "
				. " `result` TEXT NOT NULL, "
				. " `username_or_type` VARCHAR(100) NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr\n");

		enc_warn "created table '$table' successfully.\n";
	}
}


sub print_ajax   # this is the new one.  use it.
{
	my $msg = shift;
	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	# In JS, the dot doesn't match newlines, and newlines tend to screw stuff up, so we just replace
	# them here, and then we undo it in the client.  The alternative is to use ((.|\\n)+) when parsing
	# the output in the browser, but that's annoying.
	$msg =~ s!\n!::AJXNWL::!g;
	print $msg;
	print qq`</data>\n`;
}


sub ajax_print   # this is the old one; probably don't use this?
{
	my ($success, $msg, $encode_newlines) = @_;
	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	print $success ? 'ajaxsuccess=1' : 'ajaxsuccess=0';
	$msg =~ s!\n!::AJXNWL::!g if $encode_newlines;
	print ':::::' . $msg;
	# NOTE: in JS, the dot doesn't match newlines, so use ((.|\\n)+) when parsing this output if your $msg might contain newlines.
	print qq`</data>\n`;
}


sub ajax_exit
{
	ajax_print(@_);
	exit;
}


sub json_print
{
	print "Content-Type: application/json; charset=utf-8\n\n";
	print @_;
}


sub json_exit
{
	json_print(@_);
	exit;
}


sub get_expandable_list
{
	my $optsref = shift; my %opts = %$optsref;
	my @list = @{$opts{list}};
	if($opts{item_limit} && $#list > $opts{item_limit})
	{
		my @abbreviated_list = ();
		for(my $m=0; $m<=$#list; $m++)
		{
			if($m == $opts{item_limit}) { push @abbreviated_list, qq`<a href="#" onclick="toggle_display('$opts{html_id}','inline'); return false">More...</a> <span id="$opts{html_id}" class="hidden_by_default">`; }
			push @abbreviated_list, $list[$m];
		}
		push @abbreviated_list, qq`<a href="#" onclick="toggle_display('$opts{html_id}','none'); return false">...Less</a></span>`;
		@list = @abbreviated_list;
	}
	return join($opts{separator}, @list);
}


sub get_human_test_form
{
	my $number = $PREF{humantest_code};
	die_nice "problem creating number; got '$number'." unless $number =~ /^\d{$PREF{human_test_num_digits}}$/;

	my $hash = sha256_hex($number . $PREF{human_test_salt_value});
	my ($width, $height) = create_human_test_image($number,$hash);
	my $dims = $PREF{netpbm_command_for_humantest} ? '' : qq`width="$width" height="$height"`;

	my $image_leafname = $hash . '.jpg';
	my $dir_url = $PREF{human_test_image_directory___url};
	$dir_url .= '/' unless $dir_url =~ m!/$!;

	my $style = $PREF{human_test_is_invisible} =~ /yes/i ? qq`style="display: none;"` : '';

	my $output	= qq`<div id="enc-humantest" $style>$TEXT{Human_test__type_the_numbers_in_the_box_}`
			. qq`<br /><img src="$dir_url$image_leafname" id="encht0" $dims alt="human test image" style="margin: $PREF{human_test_margin};" />`
			. qq`<input type="hidden" name="encht1" id="encht1" value="$hash" />`
			. qq`<br /><input type="text" name="encht2" id="encht2" maxlength="300" class="default text required" />`
			. qq`</div>\n`;
}


sub create_human_test_image($$)
{
	my ($number,$hash) = @_;

	my $dir_url	= $PREF{human_test_image_directory___url};
	my $dir_real	= $PREF{human_test_image_directory___real};
	$dir_url	.= '/' unless $dir_url =~ m!/$!;
	$dir_real	.= '/' unless $dir_real =~ m!/$!;

	my $image_leafname = $hash . '.jpg';
	my $image_filename = $dir_real . $image_leafname;

	my ($width,$height) = ($PREF{human_test_image_width},$PREF{human_test_image_height});
	my $wave_amplitude = 4;
	my $wavelength = $width/2;
	my $final_width = $width;
	my $final_height = $height;

	my $method_used = '';
	if($PREF{netpbm_command_for_humantest})
	{
		printd qq`create_human_test_image(): using netpbm\n`;
		$method_used = 'netpbm';

		my $cmd = $PREF{netpbm_command_for_humantest};
		$cmd =~ s!%%output_filename%%!$image_filename!g;
		$cmd =~ s!%%random_number%%!$number!g;
		my ($success,$msg) = enc_sys_call($cmd);
		unless($success) { die_nice(qq`failed: $msg`); }
	}
	elsif($PREF{convert_available} =~ /yes/i   &&   $PREF{try_to_use_convert_for_humantest} =~ /yes/i)
	{
		printd qq`create_human_test_image(): using convert\n`;
		$method_used = 'convert';

		$final_width = $width + $PREF{human_test_border_size} * 2;
		$final_height = $height + $wave_amplitude * 2 + $PREF{human_test_border_size} * 2;

		my $cmd = qq`$PREF{convert_command} -background $PREF{human_test_background_color} -fill $PREF{human_test_text_color} -size ${width}x$height -pointsize $PREF{human_test_text_size} -gravity center -wave ${wave_amplitude}x$wavelength -border $PREF{human_test_border_size} -bordercolor $PREF{human_test_border_color} -quality 85 label:$number "$image_filename"`;
		my ($success,$msg) = enc_sys_call($cmd);
		unless($success) { die_nice(qq`failed: $msg`); }
	}
	elsif($PREF{imagemagick_available}   &&   $PREF{try_to_use_imagemagick_for_humantest} =~ /yes/i)
	{
		$method_used = 'ImageMagick';

		$final_width = $width + $PREF{human_test_border_size} * 2;
		$final_height = $height + $wave_amplitude * 2 + $PREF{human_test_border_size} * 2;

		my $image = Image::Magick->new;

		$image->Set(size=>"${width}x$height");
		$image->ReadImage("xc:$PREF{human_test_background_color}");

		$image->Annotate(font=>$PREF{human_test_font_name}, fill=>$PREF{human_test_text_color}, pointsize=>$PREF{human_test_text_size}, gravity=>'center', text=>$number);
		$image->Wave(amplitude=>$wave_amplitude, wavelength=>$wavelength);
		$image->Border(color=>$PREF{human_test_border_color}, width=>$PREF{human_test_border_size}, height=>$PREF{human_test_border_size});
		$image->Set(quality=>85);

		my $return_value = $image->Write($image_filename); # creates the image file, but still returns undef??
		if(! -e $image_filename)
		{
			die_nice("couldn't write image: $! (return value from \$image->Write() was '$return_value')\n");
		}
	}
	elsif(gd_is_available()   &&   $PREF{try_to_use_gd_for_humantest} =~ /yes/i)
	{
		$method_used = 'GD';

		my $img = GD::Simple->new($width,$height);

		$img->bgcolor($PREF{human_test_background_color});
		$img->fgcolor($PREF{human_test_border_color});
		$img->setThickness($PREF{human_test_border_size});
		$img->rectangle(0,0,$width-1,$height-1) if $PREF{human_test_border_size};
		$img->fgcolor($PREF{human_test_text_color});
		$img->fontsize($PREF{human_test_text_size});
		$img->moveTo(5,15);
		$img->string($number);

		open(IMAGEFH, ">$image_filename") or die_nice("$PREF{internal_appname}: couldn't create human test image '$image_filename': $!\n");
		my $fh = \*IMAGEFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $fh, 2;
		seek $fh, 0, 0;
		print $fh $img->jpeg(85);
		close $fh or die_nice("$PREF{internal_appname}: couldn't close image '$image_filename': $!\n");
	}
	else
	{
		die_nice "no image-creating library available...\n";
	}

	if(! -e $image_filename)
	{
		die_nice qq`image file does not exist after we attempted to create it.  Method used was: $method_used.  <br /><br />\n\n($image_filename)`;
	}
	if(! -s $image_filename)
	{
		die_nice qq`image file has a filesize of zero after we attempted to create it.  Method used was: $method_used.  <br /><br />\n\n($image_filename)`;
	}

	chmod $PREF{writable_file_perms}, $image_filename;

	return ($final_width, $final_height);
}


sub do_human_test
{
	my $original_hash = shift;
	my $user_input = shift;
	printd "do_human_test: user_input=$user_input, original_hash=$original_hash";

	my $user_hash = sha256_hex($user_input . $PREF{human_test_salt_value});
	printd "do_human_test: human_test_salt_value=$PREF{human_test_salt_value}, user_hash=$user_hash";

	# Also make sure that the image file actually (still) exists, to
	# protect against replay attacks.
	#
	my $dir_real = $PREF{human_test_image_directory___real};
	$dir_real .= '/' unless $dir_real =~ m!/$!;
	my $image_leafname = $user_hash . '.jpg';
	my $image_filename = $dir_real . $image_leafname;
	#printd "human: image_filename=$image_filename";
	printd "human: file exists = " . -e $image_filename;

	my $passed_test = ($user_hash eq $original_hash   &&   -e $image_filename);
	printd "do_human_test(): passed=$passed_test";
	return $passed_test;
}


sub delete_files_and_folders_older_than
{
	my $ttl = shift;
	my $dir = shift;
	my $regex = shift; # optional; if present, only matching files will be deleted.
	my $type = shift || 'files_and_folders'; # optional: files, folders, or files_and_folders.

	return unless -d $dir;

	my ($files, $subfolders) = get_items($dir);
	my (@files_to_delete, @folders_to_delete) = ();

	# first delete the files.
	#
	if($type =~ /files/)
	{
		foreach my $file (@$files)
		{
			$file = enc_untaint($file, 'keep_path');

			# Note: $file includes the full path.
			next if ($regex && $file !~ /$regex/);

			# can never be too safe...
			if($file =~ /^(\Q$PREF{uploaded_files_realpath}\E|\Q$PREF{datadir}\E|\Q$PREF{appdir_real}\E)/)
			{
				if($PREF{uploaded_files_realpath} =~ /^\Q$PREF{DOCROOT}\E/   ||   $PREF{uploaded_files_dir_is_in_docroot} =~ /no/i)
				{
					if(item_is_older_than($file, $ttl))
					{
						push @files_to_delete, $file;
					}
				}
				else
				{
					die_nice qq`refusing to unlink "$file" because \$PREF{uploaded_files_realpath} ($PREF{uploaded_files_realpath}) does not appear to be within \$PREF{DOCROOT} ($PREF{DOCROOT}).\n`;
				}
			}
			else
			{
				die_nice qq`refusing to unlink "$file" because it doesn't appear to be within \$PREF{uploaded_files_realpath} ($PREF{uploaded_files_realpath}), \$PREF{datadir} ($PREF{datadir}), or \$PREF{appdir_real} ($PREF{appdir_real}).\n`;
			}
		}
	}

	# next delete the folders.
	# start with the longest pathname to ensure we delete subdirectories before parent directories.
	# TODO: this part doesn't currently apply to any app other than FC, but might be useful in
	# some of them in the future.
	#
	if($type =~ /folders/)
	{
		foreach my $folder (sort { length($b) <=> length($a) } @$subfolders)
		{
			$folder = enc_untaint($folder, 'keep_path');

			next if ($regex && $folder !~ /$regex/);

			# can never be too safe...
			if($folder =~ /^\Q$PREF{uploaded_files_realpath}\E/)
			{
				if($PREF{uploaded_files_realpath} =~ /^\Q$PREF{DOCROOT}\E/   ||   $PREF{uploaded_files_dir_is_in_docroot} =~ /no/i)
				{
					if(item_is_older_than($folder, $ttl))
					{
						push @folders_to_delete, $folder;
					}
				}
				else
				{
					die_nice(qq`refusing to rmdir "$folder" because \$PREF{uploaded_files_realpath} ($PREF{uploaded_files_realpath}) does not appear to be within \$PREF{DOCROOT} ($PREF{DOCROOT}).\n`);
				}
			}
			else
			{
				die_nice(qq`refusing to rmdir "$folder" because it doesn't appear to be within \$PREF{uploaded_files_realpath} ($PREF{uploaded_files_realpath}).\n`);
			}
		}
	}

	# Do the actual deletions only after we've found all the old files & folders, because
	# otherwise the act of deleting the old files will update the timestamps on the old
	# folders, causing old folders to live for 2x$max_age instead of $max_age.
	#
	foreach my $file (@files_to_delete)
	{
		encdebug "unlinking $file\n";
		unlink($file) or die_nice qq`couldn't unlink (delete) file "$file": $!\n`;
	}
	foreach my $folder (@folders_to_delete)
	{
		my $numitems = count_items___raw($folder);
		if($numitems > 0)
		{
			encdebug qq`won't attempt to rmdir directory "$folder" because it isn't empty.\n`;
		}
		else
		{
			encdebug "rmdir-ing $folder\n";
			rmdir($folder) or die_nice qq`couldn't rmdir (delete) directory "$folder": $!\n`;
		}
	}
}


sub item_is_older_than
{
	my $item = shift;
	my $allowed_hours = shift;

	my $mtime = (stat($item))[9];
	my $current_time = time;
	return unless ($mtime =~ /^\d{2,}$/   &&   $current_time =~ /^\d{2,}$/);

	my $age_in_seconds = $current_time - $mtime;
	my $age_in_hours = $age_in_seconds / 3600;

	if($age_in_hours > $allowed_hours)	{ return 1; }
	else					{ return 0; }
}


sub count_items___raw
{
	my $dir = shift;
	opendir(DIRFH, $dir) or die_nice "couldn't open directory '$dir': $!\n";
	my $dirh = \*DIRFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
	my @items = grep { !/^\.{1,2}$/ } readdir($dirh);
	closedir $dirh or die_nice "couldn't close directory '$dir': $!\n";
	return scalar @items;
}


sub get_items
{
	my $dir = shift;
	return scan_dir_for_contents($dir, 'return_the_items_themselves');
}


sub scan_dir_for_contents
{
	my $dir = shift;
	my $mode = shift;
	my $ignore_hidden_items = shift; $ignore_hidden_items = $ignore_hidden_items && $ignore_hidden_items eq 'ignore_hidden_items' ? 1 : 0;
	my @all_dirs = ($dir);

	my @all_subdirs = get_all_subdirs($dir);
	for(@all_subdirs) { push @all_dirs, $dir . '/' . $_; }

	my @all_files = ();
	foreach my $subdir (@all_dirs)
	{
		# don't use images from our own thumbnail folders, etc.
		next if $ignore_hidden_items && item_is_hidden($subdir);
		next unless -r $subdir; # if we encounter an unreadable subdir, don't die, just skip it.

		if(opendir(SCANDIRFH, $subdir))
		{
			my $dirh = \*SCANDIRFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
			my @files = grep {  ! -d "$subdir/$_" } readdir($dirh);
			closedir $dirh or die "$0: couldn't close directory $subdir: $!\n";
			for(@files) { push @all_files, $subdir . '/' . $_; }
		}
		else { enc_warn "couldn't open directory '$subdir' -- readability test (-r) succeeds but opendir() fails with error: $!\n"; }   # nonsense needed for some strange corner cases, such as a Mac user uploading a "folder" onto a Windows server.
	}

	if($mode eq 'return_the_items_themselves')
	{
		my @all_subdirs_with_paths = ();
		for(@all_subdirs) { push @all_subdirs_with_paths, $dir . '/' . $_; }
		return (\@all_files, \@all_subdirs_with_paths);
	}
	elsif($mode eq 'return_the_item_counts')
	{
		my ($numfiles, $numdirs) = ($#all_files + 1, $#all_subdirs + 1);
		return ($numfiles, $numdirs);
	}
}


sub get_all_subdirs
{
	my %opts = ();
	if(ref($_[0]) eq 'HASH')	{ %opts = %{$_[0]}; }    # new way
	else				{ $opts{dir} = shift; }  # old way
	exit_with_error qq`Received "$opts{dir}" which is not a directory...` unless -d $opts{dir};

	my @dirs = ();
	if(opendir(DIRHFORSUBS, $opts{dir}))
	{
		@dirs = $opts{skip_unwritable}
			 ? sort { lc($a) cmp lc($b) } grep {  -d "$opts{dir}/$_"  &&  !/^\.$/  &&  !/^\.{2}$/  &&  -w "$opts{dir}/$_"  } readdir(DIRHFORSUBS)
			 : sort { lc($a) cmp lc($b) } grep {  -d "$opts{dir}/$_"  &&  !/^\.$/  &&  !/^\.{2}$/  } readdir(DIRHFORSUBS);
		closedir DIRHFORSUBS or die_nice "couldn't close directory '$opts{dir}': $!\n";
	}
	else { enc_warn "couldn't open directory '$opts{dir}' -- readability test (-r) succeeds but opendir() fails with error: $!\n"; }   # nonsense needed for some strange corner cases, such as a Mac user uploading a "folder" onto a Windows server.

	my @subdirs = ();
	# now recurse through everything below this point.
	foreach my $level1dir (@dirs)
	{
		foreach my $level2dir (get_all_subdirs("$opts{dir}/$level1dir"))
		{
			push @subdirs, "$level1dir/$level2dir";
		}
	}
	push @dirs, @subdirs;

	return sort { lc($a) cmp lc($b) } @dirs;
}


sub get_all_files
{
	my $dir = shift;
	opendir(DIRH, $dir) or die_nice "couldn't open directory '$dir': $!\n";
	my @files = sort { lc($a) cmp lc($b) } grep {  -f "$dir/$_"  &&  -r "$dir/$_"  &&  !/^\.$/  &&  !/\.{2}/  } readdir(DIRH);
	closedir DIRH or die_nice "couldn't close directory '$dir': $!\n";
	return @files;
}


sub find_files
{
	my %opts = %{$_[0]};

	my @all_dirs = ($opts{dir});
	for(get_all_subdirs($opts{dir}))
	{
		push @all_dirs, $opts{dir} . '/' . $_;
	}

	my @files = ();
	foreach my $dir (@all_dirs)
	{
		opendir(DIRH, $dir) or die_nice "couldn't open directory '$dir': $!\n";
		#@files = sort { lc($a) cmp lc($b) } grep {  -f "$dir/$_"  &&  -r "$dir/$_"  &&  !/^\.$/  &&  !/\.{2}/  } readdir(DIRH);

		while(my $file = readdir(DIRH))
		{
			next unless -f $dir . '/' . $file;

			my $regex_mismatch = 0;
			foreach my $i (1..5)
			{
				if(($opts{"regex$i"} && $file !~ /$opts{"regex$i"}/)   ||   ($opts{"neg_regex$i"} && $file =~ /$opts{"neg_regex$i"}/))
				{
					$regex_mismatch = 1;
					last;
				}
			}
			next if $regex_mismatch;

			if($opts{hide_base_dir})
			{
				my $item = $dir . '/' . $file;
				$item =~ s!^$opts{dir}!!;
				push @files, $item;
			}
			elsif($opts{hide_all_dirs})
			{
				push @files, $file;
			}
			else
			{
				push @files, $dir . '/' . $file;
			}
		}

		closedir DIRH or die_nice "couldn't close directory '$dir': $!\n";
	}
	return sort { lc($a) cmp lc($b) } @files;
}


sub show_raw_file
{
	# To add files to this viewer, create sets of prefs like this:
	# 	
	# 	$PREF{file_viewer_01_path}			= '%PREF{DOCROOT}/cgi-bin/some_file.cgi';
	# 	$PREF{file_viewer_01_label}			= 'afile';
	# 	$PREF{file_viewer_01_groups_allowed_to_view}	= 'admin';
	#
	# ...then create a link to $ENV{SCRIPT_NAME}?action=rawfile&file=afile

	my $file_label = shift;
	my $file = '';
	my $groups_allowed = '';
	foreach my $pref (keys %PREF)
	{
		if($pref =~ /^file_viewer_(\d+)_label$/   &&   $PREF{$pref} eq $file_label)
		{
			$file = $PREF{"file_viewer_${1}_path"};
			$groups_allowed = $PREF{"file_viewer_${1}_groups_allowed_to_view"};
			last;
		}
	}

	if(!user_is_member_of_one_of_these_groups($groups_allowed))
	{
		exit_with_error("Access Denied.");
	}
	elsif(   !(-f $file && -r $file)   )
	{
		exit_with_error("That file does not exist, or is not readable.");
	}
	else
	{
		print "Content-type: text/plain\n\n";
		print(cat($file));
	}
}


sub load_perl_module
{
	my $module = shift;
	eval "require $module";
	if($@)	{ $MISC{load_perl_module_errors}{$module} = $@; return 0; }
	else	{ return 1; }
}


sub load_base64_module
{
	eval { require MIME::Base64; };
	if($@)
	{
		$MISC{load_perl_module_errors} .= "Failed to load Perl module MIME::Base64; error was: '$@'.  Trying MIME::Base64::Perl instead... <br /><br />";
		eval { require MIME::Base64::Perl; };
		if($@)
		{
			$MISC{load_perl_module_errors} .= "Failed to load Perl module MIME::Base64::Perl; error was: '$@'.<br /><br />";
			return 0;
		}
		else
		{
			import MIME::Base64::Perl qw(encode_base64);
			return 1;
		}
	}
	else
	{
		import MIME::Base64 qw(encode_base64);
		return 1;
	}
}


sub get_enc_perl_modules
{
	my $with_status = shift;
	my @modules = ('Authen::SASL', 'DBI', 'GD', 'GD::Simple', 'Image::Magick', 'MIME::Base64', 'MIME::Base64::Perl', 'MIME::Lite', 'Net::SMTP', 'Net::SMTP::TLS');
	if($with_status)
	{
		my @modules_with_status = ();
		for(@modules)
		{
			push (@modules_with_status, load_perl_module($_) ? "$_ - installed" : "$_ - not installed");
		}
		return @modules_with_status;
	}
	else
	{
		return @modules;
	}
}


sub show_installed_perl_modules
{
	start_html_output("Installed Perl Modules");
	print qq`<div id="perlmodulespage"><p class="intro">The following Perl modules are used by $PREF{internal_appname_nice} for certain features;
	 this page shows whether the modules are currently installed on your server or not:</p>\n`;

	for(get_enc_perl_modules())
	{
		print "<p><strong>$_</strong> - ";
		eval "require $_";
		print $@ ? "not installed" : "installed";
		print "</p>\n";
	}

	print qq`
		<p>
		To install a missing Perl module, you have two options: either ask your hosting company
		or sysadmin to install the Perl module server-wide, or else install it yourself within
		your own website, in the "perlmodules" folder.&nbsp; This folder is normally at
		/cgi-bin/perlmodules but it may be at $PREF{app_base_folder}/perlmodules instead.&nbsp;
		Some Perl modules cannot be installed within your own website this way (for example
		Authen::SASL cannot, nor can ImageMagick nor GD) but most of them can be.
		</p>

		<p>
		To install a Perl module into your perlmodules folder, you just need to download the
		zipped module from <a href="http://search.cpan.org/" target="_blank">CPAN</a>, unzip it,
		find the module inside the unzipped "lib" folder, and then upload the module into
		your server's perlmodules folder.
		</p>

		<p>
		For example, to install MIME::Lite, you would 
		<a href="http://search.cpan.org/~rjbs/MIME-Lite-3.030/lib/MIME/Lite.pm" target="_blank">download the module</a>
		(the module filename is something like MIME-Lite-3.030.tar.gz) and unzip it.&nbsp; 
		When you unzip it, you'll see a bunch of files and folders, one of which is called
		"lib".&nbsp; In there, you'll see a subfolder called "MIME".&nbsp; This is the
		folder that you'll need to upload to your server, so that you then have the file
		/cgi-bin/perlmodules/MIME/Lite.pm on your server when finished.
		</p>
	`;

	print "</div>\n";
	finish_html_output();
}


sub add_db_column_if_DNE($$$)
{
	my ($table, $column, $details) = @_;
	if(!db_column_exists($column, $table))
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `$column` $details;");
		$sth->execute() or die_nice "could not add column '$column' to table '$table': $DBI::errstr\n";
		enc_warn "added column '$column' to table '$table'.\n";
	}
}


##############################################################################
### Login-UB: ################################################################
##############################################################################


sub do_ub_login
{
	$PREF{admin_is_logged_in} = 0;
	$PREF{member_is_logged_in} = 0;

	# Get the user's entered username and password:
	my $input_username	= enc_param($PREF{userbase_user_fieldname}) || ($PREF{on_failed_login_redirect_to} ? enc_redirect($PREF{on_failed_login_redirect_to}) : exit_with_error($TEXT{empty_username_error}));
	my $input_password	= enc_param($PREF{userbase_pass_fieldname}) || ($PREF{on_failed_login_redirect_to} ? enc_redirect($PREF{on_failed_login_redirect_to}) : exit_with_error($TEXT{empty_password_error})); $input_username =~ s/^(....).*/$1/; $input_password =~ s/^(....).*/$1/;
	my $ref = enc_param("ref");
	my ($expiry) = ();

	if($PREF{strip_leading_and_trailing_spaces_from_usernames_during_login} =~ /yes/i) { $input_username =~ s!^\s+!!; $input_username =~ s!\s+$!!; }
	if($PREF{strip_leading_and_trailing_spaces_from_passwords_during_login} =~ /yes/i) { $input_password =~ s!^\s+!!; $input_password =~ s!\s+$!!; }

	$input_username = lc($input_username) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
	$input_username = uc($input_username) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;
	check_username_for_sql_safeness($input_username);

	if(enc_param("remember_me") eq "on")
	{
		if($PREF{num_days_rememberme_cookie_lasts} !~ /^\d+$/)
		{
			$PREF{num_days_rememberme_cookie_lasts} = 7;
		}
		$expiry = "+$PREF{num_days_rememberme_cookie_lasts}d";
	}

	my $restrict_ip = (   ($PREF{enable_ip_address_restriction} =~ /yes/i && enc_param("restrict_ip") =~ /on/i)   ||   ($PREF{force_ip_address_restriction} =~ /yes/i)   ) ? 1 : 0;
	$restrict_ip = 0 if $ENV{HTTP_USER_AGENT} =~ /AOL/ && $PREF{disable_ip_restriction_for_AOL_users} =~ /yes/i;


	my $account_locked = enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");
	if($account_locked)
	{
		my $lock_expired = ! account_exceeds_failed_login_limit($input_username);
		if($PREF{lock_expires_automatically} =~ /yes/i   &&   $lock_expired)
		{
			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = FALSE WHERE `username` = '$input_username';");
			die_nice("Error: do_ub_login(input_username='$input_username'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
		}
		else
		{
			sleep $PREF{num_seconds_to_sleep_on_failed_login};
			enc_redirect("$PREF{login_url}?phase=eacctlck");
		}
	}


	# Get the crypted version of the input password:
	#
	# Actually, we can't die on this here, because we don't yet know if their input username exists,
	# which we can't know until we get the salt to get the crypted password... and we can't check 
	# based on JUST the username, because then erroring would be a security leak revealing whether
	# that username exists.  So, given that this is for such ancient installations, we'll just skip it.
	#die_nice qq`Error: no salt on this account.  Please contact us.` if !$salt;   # from an ancient (pre-2007) version of UB.
	#
	my $crypted_input_password = hash_this_password({ plaintext_password=>$input_password, username=>$input_username });


	my $go = '';
	if(account_exists($input_username, $crypted_input_password))
	{
		if(enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `username` = '$input_username';"))
		{
			enc_redirect("$PREF{login_url}?phase=eacctdis");
		}

		$PREF{member_is_logged_in} = 1; # technically true, but can still be revoked by later tests.
		$PREF{logged_in_userid} = my $userid = get_user_id($input_username);

		enc_redirect("$PREF{login_url}?phase=eacctpndvrf&uid=$userid&user=$input_username") if account_is_pending_email_verification($PREF{logged_in_userid});
		enc_redirect("$PREF{login_url}?phase=eacctpndpmt&uid=$userid") if account_is_pending_payment($PREF{logged_in_userid});
		enc_redirect("$PREF{login_url}?phase=eacctpndadm") if account_is_pending_admin_approval($PREF{logged_in_userid});

		my $session_id = generate_nonce($input_username, $crypted_input_password);
		if(my $shared_session_id = check_for_multiple_logins($userid, $input_username))
		{
			$session_id = $shared_session_id;
		}
		update_loggedin_count_for_this_user($userid);

		my $secure_cookie = $PREF{require_encrypted_connection_for_login_cookie} =~ /yes/i;
		set_cookie($PREF{site_session_cookie}, $session_id, $expiry, $secure_cookie, 1);

		unless(enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `id` = $userid;") eq '')
		{
			my $statement = "UPDATE `$PREF{user_table}` SET `failed_logins` = NULL WHERE `id` = $userid;";
			my $success = enc_sql_update($statement);
			die_nice("Error: do_ub_login(id='$userid'): SQL returned '$success' instead of '1' while updating failed_logins.  SQL was: [[$statement]]") unless $success == 1;
		}

		log_user_into_db($userid, $session_id, offsettime(), $restrict_ip);
		update_logins_table($userid, $session_id);
		$PREF{logged_in_username} = $input_username;
		$PREF{admin_is_logged_in} = is_admin_acct($PREF{logged_in_userid});

		update_stored_password_hash_if_necessary($userid, $input_password, $crypted_input_password);
		send_login_notification_email($userid, $input_username);

		my %REDIRS = ();
		if(force_pw_change($userid))
		{
			$REDIRS{force_pw_change} = $PREF{login_url_qsready} . "action=edituser&id=$userid";
		}
		if(   (my $return = enc_param('loginreturn'))   &&   $PREF{loginreturn}{ enc_param('loginreturn') }   )
		{
			$REDIRS{loginreturn} = $PREF{loginreturn}{$return};
		}
		foreach my $pref (sort keys %PREF)
		{
			if($pref =~ /^on_(.+?)_login_redirect_to$/i)
			{
				my $group = $1;
				if(   user_is_member_of_group($PREF{logged_in_userid}, $group)   &&   $PREF{$pref}   &&   !($PREF{admin_is_logged_in} && ($group eq $PREF{member_group_name}))   )
				{
					$REDIRS{redirect} = $PREF{$pref};
					#last; # Actually, don't skip out after the first one; process them all so only the last one applies.
				}
			}
		}
		$REDIRS{redirect} = $PREF{on_paidmemberacct_login_redirect_to} if $PREF{on_paidmemberacct_login_redirect_to} && user_belongs_to_a_paid_group($userid);
		$REDIRS{referer} = determine_default_login_destination($ref);

		$REDIRS{redirect} =~ s/%%username%%/$input_username/g;
		$REDIRS{redirect} =~ s/%%uidtoken%%/make_token_for_remote_login()/eg;

		foreach my $redir_type (split(/\s*,\s*/, "force_pw_change, $PREF{login_destination_precedence_list}"))
		{
			if($REDIRS{$redir_type})
			{
				$go = $REDIRS{$redir_type};
				last;
			}
		}

		my $orig_qs = enc_param('qstr');
		if($orig_qs && $PREF{preserve_URL_variables_through_login_process} =~ /yes/i) { $go .= $go =~ /\?/ ? "&$orig_qs" : "?$orig_qs"; }

		enc_redirect($go);
	}

	# Else they tried to log in but failed.
	else
	{
		# Be sure that we do the sleep before the email, so that any
		# potential email errors don't cause us to abort early thereby
		# skipping the sleep and possibly giving away the fact that the
		# login failed.
		#
		sleep $PREF{num_seconds_to_sleep_on_failed_login};

		my $account_locked = account_exceeds_failed_login_limit($input_username, 'increment');
		if($account_locked)
		{
			unless(enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `username` = '$input_username'"))
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = TRUE WHERE `username` = '$input_username';");
				die_nice("Error: do_ub_login(input_username='$input_username'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
			}
		}

		update_failed_logins_table($input_username, $input_password);
		email_failed_logins_to_webmaster($input_username, $input_password);

		if($PREF{on_failed_login_redirect_to})
		{
			$go = $PREF{on_failed_login_redirect_to};

			if($account_locked)
			{
				$go .= $go =~ /\?/ ? '&account_locked=1' : '?account_locked=1';
			}
		}
		else
		{
			if($account_locked)	{ $go = "$PREF{login_url}?phase=eacctlck"; }
			else			{ $go = "$PREF{login_url}?phase=ebadauth"; }
		}

		enc_redirect($go);
	}
}


sub do_encauth_login
{
	my $whence = ($qs =~ /(?:^|&)whence=(.+)/)[0]; $whence = '' if $whence =~ /(log(ged)?out|smsg=|kmsg=|noautoredirect=true)/i;
	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		smsg_redirect('encauthfailedlogin') if enc_param('encauthpw') !~ /\S/;
		my ($hashed_pw_base, $hashed_pw_is_correct) = hash_and_check_encauthpw(enc_param('encauthpw'));
		smsg_redirect('encauthfailedlogin') unless $hashed_pw_is_correct;

		my $expiry = enc_param('persist') eq 'on' ? "+$PREF{num_days_login_lasts}d" : '';
		set_encauth_login_cookie($hashed_pw_base, $expiry);
		my $ref = enc_param('ref'); $ref = '' if $ref =~ /(log(ged)?out|smsg=|kmsg=|noautoredirect=true|\?newpw|\?login|action=login)/i;
		$whence =~ s!_THEQS_!?!g; $whence =~ s!_ANAMP_!&!g;
		enc_redirect($ref || $whence || $PREF{here});
	}
	else
	{
		if($PREF{all_admin_password_hashes} || $PREF{all_member_password_hashes})
		{
			my $action = $PREF{internal_appname} eq 'visitorlog' ? 'action=vllogin' : 'action=login';
			$action .= $PREF{default_url_vars};
			$action .= "&amp;whence=$whence" if $whence;
			start_html_output($PREF{subtitle___login});
			print	  qq`<form accept-charset="UTF-8" method="post" id="encauth_login" action="$ENV{SCRIPT_NAME}?$action">`
				. qq`\n<p>$TEXT{Enter_the_password}</p>\n<input type="password" name="encauthpw" id="encauthpw" maxlength="200" class="default text" /><input type="hidden" name="ref" value="$ENV{HTTP_REFERER}" />`
				. ($PREF{show_keep_me_logged_in_checkbox_on_login_page} !~ /yes/i ? '' : qq`\n<br /><br /><input type="checkbox" name="persist" id="persist" /><label for="persist"> $TEXT{Keep_me_logged_in_for} $PREF{num_days_login_lasts} $TEXT{days}</label>`)
				. qq`\n<br /><br /><input type="submit" value="$TEXT{Login}" class="default button submit" />\n</form>\n`;
			print $TEXT{Forgot_password_};
			finish_html_output();
		}
		else
		{
			$TEXT{password_not_set} =~ s!%%newpw_link%%!$PREF{here_login_qsready}newpw!g;
			exit_with_output($TEXT{password_not_set});
		}
	}
}


sub check_if_logged_in()
{
	my %cookies = $MISC{cookies} ? %{$MISC{cookies}} : ();
	($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_realname}, $PREF{logged_in_email}, $PREF{logged_in_userid}, $PREF{login_is_via_encauth}) = (0,0,'','','','', 0);

	if($PREF{integrate_with_existing_login_system} =~ /yes/i   &&   $PREF{integrate_with_userbase} !~ /yes/i)
	{
		$PREF{login_system_available} = 1;

		if($PREF{enable_username_from_apache_auth} =~ /yes/i)
		{
			if(my $username = $ENV{REMOTE_USER})
			{
				$PREF{logged_in_username}	= $username;
				$PREF{member_is_logged_in}	= 1;
				$PREF{admin_is_logged_in}	= $PREF{admin_user_present} || $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
				$PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
			}
		}
		elsif($PREF{enable_username_from_cookie} =~ /yes/i)
		{
			my $username = '';
			if(exists($cookies{$PREF{username_cookie_name}})   &&   ($username = $cookies{$PREF{username_cookie_name}}->value))
			{
				$PREF{logged_in_username}	= $username;
				$PREF{member_is_logged_in}	= 1;
				$PREF{admin_is_logged_in}	= $PREF{admin_user_present} || $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
				$PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
			}
		}
		elsif($PREF{enable_username_from_environment_variable} =~ /yes/i)
		{
			my $username = '';
			if(exists($ENV{$PREF{username_envvar_name}})   &&   ($username = $ENV{$PREF{username_envvar_name}}))
			{
				$PREF{logged_in_username}	= $username;
				$PREF{member_is_logged_in}	= 1;
				$PREF{admin_is_logged_in}	= $PREF{admin_user_present} || $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
				$PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
			}
		}
		elsif($PREF{enable_username_from_cgi_script} =~ /yes/i)
		{
			my ($cgi_script, $cgi_qs) = $PREF{username_cgi_script_command} =~ /(.+)\?(.+)/ ? ($1, $2) : ($PREF{username_cgi_script_command}, undef);
			my $cgi_output = `export QUERY_STRING="$cgi_qs" && export SCRIPT_NAME="$cgi_script" && "$PREF{DOCROOT}$cgi_script"`;
			#
			# Update: may need these extra var definitions?
			#my $cgi_output = `export QUERY_STRING="$cgi_qs" && export SCRIPT_NAME="$cgi_script" && export SCRIPT_FILENAME="$ENV{DOCUMENT_ROOT}$cgi_script" && export PWD="$PREF{DOCROOT}/cgi-bin" && export suppress_http_headers="1" && "$PREF{DOCROOT}$cgi_script"`;

			my ($admin,$member,$username) = ($cgi_output =~ /admin=(\d):::::member=(\d):::::username=(.*?):::::/s);

			if($member   &&   $username)
			{
				$PREF{logged_in_username}	= $username;
				$PREF{member_is_logged_in}	= 1;
				$PREF{admin_is_logged_in}	= $admin || $PREF{admin_user_present} || $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
				$PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
			}
		}
		elsif($PREF{enable_username_from_php_session} =~ /yes/i)
		{
			my $username = '';
			if(exists $ENV{PHP_ENC_USERNAME}) # must use if(exists $foo) rather than just if($foo) so that we properly unset the variable when a user has logged out; otherwise we'd just pull it from our php-var-cache even though the user had already logged out.
			{
				$username = $ENV{PHP_ENC_USERNAME}; save_php_var_to_cache('username',$username);
			}
			else # we were POSTed to?
			{
				$username = get_php_var_from_cache('username');
			}

			if($username)
			{
				$PREF{logged_in_username}	= $username;
				$PREF{member_is_logged_in}	= 1;
				$PREF{admin_is_logged_in}	= $PREF{admin_user_present} || $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
				$PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
			}
		}
		else
		{
			exit_with_error qq`To use \$PREF{integrate_with_existing_login_system}, you must also enable either \$PREF{enable_username_from_cookie}, \$PREF{enable_username_from_environment_variable}, \$PREF{enable_username_from_php_session}, or \$PREF{enable_username_from_apache_auth}.`;
		}
	}
	elsif($PREF{integrate_with_userbase_method_b} =~ /yes/i   &&   $PREF{path_to_userbase})
	{
		$PREF{login_system_available} = 1;

		# Won't work on many IIS configurations where executing external commands
		# from within IIS is prevented by user account policy.  But the eval method
		# in the following block works on IIS.
		#
		my $userbase_output = `export QUERY_STRING="action=chklogin" && export SCRIPT_NAME="$PREF{userbase_local_scriptname}" && "$PREF{path_to_userbase}" 2>&1`;

		if($userbase_output !~ /\w+/)
		{
			# Use "package" to create a separate namespace for this block.  This is because we're going to use
			# "eval" as a way to execute another Perl script, but we only want that script's output; we don't
			# want its globals and subroutines being imported into our namespace.  In particular we don't want
			# functions such as start_html_output() "overwriting" our own copy of that function in the main
			# namespace.
			# 
			package CALLTOUBFORLOGINCHECK;

			# Don't die/die_nice anywhere in here; we want to let the next if() check whether $userbase_output
			# is valid and then print a more useful error if not.
			#
			my $file = $PREF{path_to_userbase};
			my $file_contents = ();
			open(IN,"<$file");
			flock IN, 1;
			seek IN, 0, 0;
			while(<IN>) { $file_contents .= $_; }
			close IN;

			$file_contents =~ /(.*)/s;
			$file_contents = $1; # cheap untaint since this is our own file.

			my ($real_qs, $real_sn) = ($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME});
			($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME}) = ("action=chklogin&print=false", $PREF{userbase_local_scriptname});
			$userbase_output = eval $file_contents;
			($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME}) = ($real_qs, $real_sn);
		}

		if($userbase_output =~ /admin=(\d):::::member=(\d):::::username=(.*?):::::userid=(\d*?):::::group_memberships=(.*?):::::realname=(.*?):::::email=(.*?):::::(.*)/s)
		{
			($PREF{admin_is_logged_in},$PREF{member_is_logged_in},$PREF{logged_in_username},$PREF{logged_in_userid},$PREF{logged_in_group_memberships},$PREF{logged_in_realname},$PREF{logged_in_email})
			= ($1,$2,$3,$4,$5,$6,$7);

			$PREF{ub_var_username}	= $PREF{logged_in_username};
			$PREF{ub_var_userid}	= $PREF{logged_in_userid};
			$PREF{ub_var_realname}	= $PREF{logged_in_realname};
			$PREF{ub_var_email}	= $PREF{logged_in_email};

			if(my $other_ub_vars = $8)
			{
				while($other_ub_vars =~ /(.+?)=(.+?):::::/g)
				{
					$PREF{"ub_var_$1"} = $2;
					$PREF{"logged_in_$1"} = $2 unless $PREF{"logged_in_$1"};
				}
			}
		}
		else
		{
			exit_with_error("integrate_with_userbase_method_b failed: UserBase output was: "
				. ($userbase_output ? 'null' : "[[ $userbase_output ]] ")
				. qq`<br /><br />\n\nMake sure you've got UserBase itself running properly before trying this.`
			);
		}
	}
	elsif(userbase_available())
	{
		$PREF{login_system_available} = 1;

		if(my $session_id = get_cookie($PREF{site_session_cookie}))
		{
			check_sessionid_for_sql_safeness($session_id);

			my ($username,$realname,$email,$id,$ip) = enc_sql_select("SELECT username,name,email,id,ip FROM `$PREF{user_table}` WHERE `mrsession` = '$session_id';");

			if($username   &&   $id   &&   !account_is_pending($id))
			{
				if(enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$id';"))
				{
					enc_redirect("$PREF{login_url}?phase=eacctdis");
				}

				my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$id';");
				if(($numusers > 1) && $PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i)
				{
					# If there's already >1 user logged in under this username (for example, because we
					# didn't enable prevent_multiple_simultaneous_logons_per_username until after some
					# usage had already occurred), then we can't really do a one-by-one check to try and
					# decide which logins to kill, so kill them all.

					log_user_out_of_db($username, 'force');
					enc_redirect("$PREF{login_url}?phase=emultkicked");
				}

				# The IP check MUST come *after* the multiple_simultaneous_logons check, because if the
				# multiple_simultaneous_logons check fails, we need to take an action in response (namely
				# logging all the users out of the db) -- but if the IP check also fails (which is likely
				# to happen when the multiple_simultaneous_logons check fails) then we simply return, so
				# the multiple_simultaneous_logons check would never get a chance to do its db-logouts
				# if the IP check came first (and failed).
				#
				if(($PREF{enable_ip_address_restriction} =~ /yes/i && $ip) || ($PREF{force_ip_address_restriction} =~ /yes/i))
				{
					enc_redirect("$PREF{login_url}?phase=eipmismatch") unless $ip eq $PREF{ip};
				}

				$PREF{logged_in_username} = $username;
				$PREF{logged_in_realname} = $realname;
				$PREF{logged_in_email} = $email; $PREF{logged_in_email} = $PREF{logged_in_username} if ($PREF{logged_in_email} !~ /.+\@.+\..+/ && $PREF{logged_in_username} =~ /.+\@.+\..+/);
				$PREF{logged_in_userid} = $id;
				$PREF{member_is_logged_in} = 1;

				if(is_admin_acct($PREF{logged_in_userid}))
				{
					$PREF{admin_is_logged_in} = 1;
				}

				$PREF{ub_var_username}	= $PREF{logged_in_username};
				$PREF{ub_var_userid}	= $PREF{logged_in_userid};
				$PREF{ub_var_realname}	= $PREF{logged_in_realname};
				$PREF{ub_var_email}	= $PREF{logged_in_email};

				foreach my $customfield (get_custom_userbase_field_names($PREF{user_table}))
				{
					my $value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}'");
					$PREF{"ub_var_$customfield"} = $value;
					$PREF{"logged_in_$customfield"} = $value unless $PREF{"logged_in_$customfield"};
				}

				# This depends on $PREF{logged_in_userid}, so must come after that is set; but since
				# this is an acct-disabled check, it should still come *before* we officially mark the
				# user as logged in (i.e. before we update the database).
				#
				if((my $subgroup_manager_username = user_is_part_of_a_subgroup($id)) && ($PREF{subgroup_owned_users_get_disabled_when_their_manager_does} =~ /yes/i))
				{
					my $subgroup_manager_userid = get_user_id($subgroup_manager_username);
					if(enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$subgroup_manager_userid';"))
					{
						enc_redirect("$PREF{login_url}?phase=eacctdis");
					}
				}

				check_and_update_login_session($PREF{logged_in_userid});

				if(force_pw_change($PREF{logged_in_userid}))
				{
					if($PREF{internal_appname} eq 'userbase')
					{
						if(($qs !~ /^(ublogout|ublogoutall|action=commitedituser)$/)   &&   ($qs !~ /(format=justlink|format=mini)/))
						{
							print_user_form('edit', $PREF{logged_in_userid});
							exit;
						}
					}
					else
					{
						# Redirect to UB's change-your-pw page, unless we're on a page where that would break
						# something (e.g. the AJAX queries in DBB).
						unless($PREF{internal_appname} eq 'databaseboss' && (get_qs_var('action') eq 'query'))
						{
							enc_redirect("$PREF{login_url_qsready}action=edituser&id=$PREF{logged_in_userid}");
						}
					}
				}
			}
		}
	}
	else
	{
		check_if_logged_in_with_encauth();
	}
	encdebug "admin=$PREF{admin_is_logged_in}, member=$PREF{member_is_logged_in}, user=$PREF{logged_in_username}, uid=$PREF{logged_in_userid}, login_is_via_encauth=$PREF{login_is_via_encauth}";
}


sub check_if_logged_in_with_encauth
{
	if($PREF{all_admin_password_hashes} || $PREF{all_member_password_hashes})
	{
		my $hashed_password_in_cookie = get_cookie($PREF{encauth_login_cookie});

		if($hashed_password_in_cookie   &&   $PREF{all_admin_password_hash_bases}{$hashed_password_in_cookie})
		{
			($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}, $PREF{login_is_via_encauth}) = (1, 1, '', -3, 1);
		}
		elsif($hashed_password_in_cookie   &&   $PREF{all_member_password_hash_bases}{$hashed_password_in_cookie})
		{
			($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}, $PREF{login_is_via_encauth}) = (0, 1, '', -2, 1);
		}
		# TODO: explicitly set 0/0/''/-1 for public?
	}
}


sub check_and_update_login_session($)
{
	my $userid = shift;
	my $my_session_id = get_cookie($PREF{site_session_cookie});
	my ($session_id_in_db,$login_time) = enc_sql_select("SELECT `mrsession`,`loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid;");

	if(   ($my_session_id == $session_id_in_db)   &&   (!login_session_expired($login_time))   )
	{
		update_loggedin_time($userid, $my_session_id, offsettime());
	}
	else
	{
		do_logout() if $PREF{idle_timeout} > 0;
	}

	if(account_has_reached_daily_access_limit($userid))
	{
		enc_redirect("$PREF{login_url}?phase=eacctlimit");
	}
}


sub update_loggedin_time
{
	my ($userid, $my_session_id, $newtime) = @_;

	die_unless_numeric($userid,'userid');
	die_unless_numeric($newtime,'newtime');
	check_sessionid_for_sql_safeness($my_session_id);

	my $value_is_unchanged = $newtime == enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
	unless($value_is_unchanged) # prevent the 0E0 error, which isn't actually an error in the case that the value was unchanged.
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = $newtime WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
		die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating loggedin.") unless $success == 1;
	}

	$value_is_unchanged = $newtime == enc_sql_select("SELECT `lastactive` FROM `$PREF{user_table}` WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
	unless($value_is_unchanged) # prevent the 0E0 error, which isn't actually an error in the case that the value was unchanged.
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `lastactive` = $newtime WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
		die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating lastactive.") unless $success == 1;
	}

	my $first_visit_today = enc_sql_select("SELECT `first_visit_today` FROM `$PREF{user_table}` WHERE `id` = $userid");
	unless($first_visit_today =~ /^$PREF{today}/)
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `first_visit_today` = '$PREF{date14}' WHERE `id` = $userid");
		die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating first_visit_today.") unless $success == 1;
	}
}


sub login_session_expired($)
{
	my $loggedin_time = shift;
	return (

		(   ($PREF{idle_timeout} > 0)   &&   (offsettime() - $loggedin_time > $PREF{idle_timeout})   )

		||

		(
			($PREF{num_days_rememberme_cookie_lasts} > 0)
			&&
			(   offsettime()   >   ($loggedin_time + ($PREF{num_days_rememberme_cookie_lasts} * 86400))   )
		)
	);
}


sub log_user_out_of_db
{
	my ($username, $my_session_id) = @_;

	check_username_for_sql_safeness($username);
	check_sessionid_for_sql_safeness($my_session_id) unless $my_session_id eq 'force';

	# It's possible (and probably not particularly uncommon) that a user logs in at one location, then leaves
	# that location and his session goes idle, and then he logs in at another location with the same account.  In
	# that case, a call to log_user_out_of_db() from the first location should not actually do the db logout, 
	# because the session does not belong to him anymore.  But note that this is not an error condition, so we
	# should just silently return.
	#
	my $session_id_in_db = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");

	if(($my_session_id == $session_id_in_db)   ||   ($my_session_id eq 'force'))
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = 0 WHERE LOWER(`username`) = LOWER('$username');");
		die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting loggedin to zero.") unless $success == 1;

		$success = enc_sql_update("UPDATE `$PREF{user_table}` SET `mrsession` = '' WHERE LOWER(`username`) = LOWER('$username');");
		die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting mrsession to null.") unless $success == 1;

		my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");
		if($numusers) # this check only required because of crappy old MySQL versions that fail to ever set numusers properly in the DB (??).
		{
			$success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers` = 0 WHERE LOWER(`username`) = LOWER('$username');");
			die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting numusers to zero.") unless $success == 1;
		}
	}
}


sub do_logout
{
	if($PREF{internal_appname} eq 'userbase')
	{
		my $force_logout_all = shift; $force_logout_all = $force_logout_all eq 'all' ? 1 : 0;

		if($PREF{we_are_virtual})
		{
			print_http_headers({ nocache => 1, nokeepalive => 1 });
			$PREF{forced_logout_link} =~ s/%%logout_url%%/$PREF{logout_url}/g;
			print $PREF{forced_logout_link};
			exit;
		}
		else
		{
			my $ref = $ENV{HTTP_REFERER};
			if($ref)
			{
				# Remove the "logout" from the referrer, otherwise we'll get stuck
				# in an infinite logout loop with this Location: call.
				$ref =~ s/\?.*(ub)?log(ged)?out.*//;

				$ref = '' if $ref =~ /(smsg=|kmsg=|noautoredirect=true)/i; # don't redirect to any static/keyed messages that probably no longer apply now that the login state has changed.
			}

			# Delete the login cookie regardless of $PREF{member_is_logged_in}, because
			# it may be that the user has the cookie but it's invalid (expired, wrong IP,
			# etc) in which case we didn't set $PREF{member_is_logged_in}.  In that case,
			# we still want to allow the user to force a logout (i.e. delete his cookie).
			#
			delete_login_cookie();

			my $whence = '';
			if($PREF{member_is_logged_in})
			{
				if($PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i   ||   $force_logout_all)
				{
					log_user_out_of_db($PREF{logged_in_username}, get_cookie($PREF{site_session_cookie}));
				}
				else
				{
					die_unless_numeric($PREF{logged_in_userid}, 'logged_in_userid');
					my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';");
					if($numusers > 1)
					{
						my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers`=GREATEST((`numusers`-1),0) WHERE `id` = '$PREF{logged_in_userid}';");
						die_nice("Error: do_logout(): SQL returned '$success' instead of '1' while decrementing numusers column.") unless $success == 1;
					}
					else
					{
						log_user_out_of_db($PREF{logged_in_username}, get_cookie($PREF{site_session_cookie}));
					}
				}

				my $logout_redirect = '';
				foreach my $pref (sort keys %PREF)
				{
					if($pref =~ /^on_(.+?)_logout_redirect_to$/i)
					{
						my $group = $1;
						if(   user_is_member_of_group($PREF{logged_in_userid}, $group)   &&   $PREF{$pref}   &&   !($PREF{admin_is_logged_in} && ($group eq $PREF{member_group_name}))   )
						{
							$logout_redirect = $PREF{$pref};
							$logout_redirect =~ s/%%username%%/$PREF{logged_in_username}/g;
							#last; # Actually, don't skip out after the first one; process them all so only the last one applies.
						}
					}
				}
				if($logout_redirect)
				{
					enc_redirect($logout_redirect);
				}
				else
				{
					$whence = $ref;
				}
			}
			else
			{
				if($PREF{on_fake_logout_redirect_to})
				{
					enc_redirect($PREF{on_fake_logout_redirect_to});
				}
				else
				{
					$whence = $ref;
				}
			}

			if($whence && $PREF{redirect_to_referer_on_logout} =~ /yes/i)
			{
				enc_redirect($whence);
			}
			else
			{
				$whence =~ s!^https?://$ENV{HTTP_HOST}!!; # some servers don't like extra "http://"s in URLs.
				enc_urlencode($whence);
				$whence = '' if $PREF{server_bug_prohibits_use_of_whence} =~ /yes/i;
				enc_redirect("$PREF{login_url_qsready}action=loggedout&whence=$whence");
			}
		}
	}
	else
	{
		if($PREF{integrate_with_userbase} =~ /yes/i   ||   $PREF{integrate_with_userbase_method_b} =~ /yes/i   ||   $PREF{integrate_with_existing_login_system} =~ /yes/i)
		{
			enc_redirect($PREF{logout_url});
		}
		else
		{
			do_encauth_logout();
		}
	}
}


sub set_encauth_login_cookie($$)
{
	my ($hashed_pw_base, $expiry) = @_;
	my $secure_cookie = $PREF{require_encrypted_connection_for_login_cookie} =~ /yes/i;
	my $httponly_cookie = 1;
	set_cookie($PREF{encauth_login_cookie}, $hashed_pw_base, $expiry, $secure_cookie, $httponly_cookie);
}


sub do_encauth_logout
{
	delete_encauth_login_cookie();
	my $whence = $ENV{HTTP_REFERER};
	$whence =~ s!^https?://$ENV{HTTP_HOST}!!; # some servers don't like extra "http://"s in URLs.
	$whence =~ s/\?logout$//; # Remove "logout" from the ref so we don't get stuck in an infinite loop.
	my $go = "$PREF{here_login_qsready}action=loggedout&whence=$whence";
	enc_redirect($go);
}


sub delete_encauth_login_cookie
{
	set_encauth_login_cookie(0, '-1M');
}


sub delete_login_cookie
{
	my $secure_cookie = $PREF{require_encrypted_connection_for_login_cookie} =~ /yes/i;
	set_cookie($PREF{site_session_cookie}, 0, '-1M', $secure_cookie, 1);
}


sub show_loggedout_page
{
	my $ref = shift;
	enc_urldecode($ref);
	$ref = '' if $ref =~ /(log(ged)?out|smsg=|kmsg=|phase=|noautoredirect=true)/i;
	my $message = $PREF{loggedout_page_template__no_referer};
	if($ref)
	{
		$message = $PREF{loggedout_page_template__with_referer};
		$message =~ s/%%ref%%/$ref/g;
	}
	exit_with_success($message);
}


sub get_logout_url
{
	return $PREF{integrate_with_userbase} =~ /yes/i || $PREF{integrate_with_userbase_method_b} =~ /yes/i || $PREF{integrate_with_existing_login_system} =~ /yes/i ? $PREF{logout_url} : ($ENV{SCRIPT_NAME} . ($ENV{SCRIPT_NAME} =~ /\?/ ? '&' : '?') . "logout");
}


sub get_login_url
{
	return $PREF{integrate_with_userbase} =~ /yes/i || $PREF{integrate_with_userbase_method_b} =~ /yes/i || $PREF{integrate_with_existing_login_system} =~ /yes/i ? $PREF{login_url} : "$PREF{here_login_qsready}action=login";
}


sub account_is_pending
{
	return 0 if !userbase_available();
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending()");
	return (account_is_pending_email_verification($userid) || account_is_pending_admin_approval($userid) || account_is_pending_payment($userid));
}


sub account_is_pending_email_verification
{
	my $userid = shift;
	return ($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i) && ($PREF{require_email_verification_for_new_signups} =~ /yes/i) && account_is_pending_email_verification_in_db($userid);
}


sub account_is_pending_email_verification_in_db
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending_email_verification_in_db()");
	return enc_sql_select("SELECT `pending_email_verification` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_has_completed_email_verification
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_has_completed_email_verification()");
	return enc_sql_select("SELECT `completed_email_verification` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_is_pending_admin_approval
{
	my $userid = shift;
	return ($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i) && ($PREF{require_admin_approval_for_new_signups} =~ /yes/i) && account_is_pending_admin_approval_in_db($userid);
}


sub account_is_pending_admin_approval_in_db
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending_admin_approval_in_db()");
	return enc_sql_select("SELECT `pending_admin_approval` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_is_pending_payment
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending_payment()");
	my $pending_payment_flag_is_set = enc_sql_select("SELECT `pending_payment` FROM `$PREF{user_table}` WHERE `id` = $userid");

	#return $pending_payment_flag_is_set;
	#
	# 20170114: when a user makes a payment to join a paid group, we add the user to the group,
	# which triggers an email notification, and then we clear the pending_payment flag on his
	# account.  But on some terrible hosts (GoDaddy), the server kills the script between the
	# add-to-group and clear-flag steps; so even though the user has paid, he's still set to
	# pending, so we always force him to the payment page again.  This is obviously wrong, and
	# frustrating for the users.  So, to work around this, and because the pending_payment flag
	# is kind of redundant with user_belongs_to_a_paid_group() anyway, we'll check that too,
	# before declaring that the user is really pending.
	#
	# This is kind of weird now, since this sub was originally meant to be just a test, and not
	# meant to actually update the database.  But given that it really is an error condition when
	# pending_payment and belongs_to_paid_group are both true, we do want to correct that right
	# away as soon as we notice it, which means doing it here and now.
	#
	if($pending_payment_flag_is_set) {
		if(user_belongs_to_a_paid_group($userid)) {
			encdebuglog qq`userid=$userid: pending_payment flag is set, but user belongs to a paid group, so clearing pending_payment flag now.`;
			clear_pending_payment_flag($userid);
			return 0;
		}
		return 1;
	}

	return 0;
}


sub clear_pending_payment_flag
{
	my $uid = shift;
	die_unless_numeric($uid, "user ID in clear_pending_payment_flag()");
	my $retval = enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $uid");
	$retval == 1 or die_nice("SQL returned something other than 1 ('$retval') while trying to set pending_payment to 0 [uid=$uid].");
	encdebuglog qq`userid=$uid: cleared the pending_payment flag.`;
}


sub account_has_completed_payment
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_has_completed_payment()");
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{payments_table}` WHERE `userid` = $userid");
}


sub account_has_reached_daily_access_limit
{
	return 0 if is_admin();
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_has_reached_daily_access_limit()");
	my $groups = get_groups_hash($userid);
	foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
	{
		next unless $$groups{$group}{is_member};
		next unless $$groups{$group}{daily_access_limit};

		my $first_visit_today = enc_sql_select("SELECT first_visit_today FROM `$PREF{user_table}` WHERE id = $userid;");
		my $minutes_since_first_visit_today = (offsettime() - date14_to_etime($first_visit_today)) / 60;
		return 1 if $minutes_since_first_visit_today > $$groups{$group}{daily_access_limit};
	}
	return 0;
}


sub get_custom_userbase_field_names
{
	my $which_user_table = shift;
	my $include_disabled_fields = shift;

	my (@custom_fields, %custom_fields) = ();
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
	{
		my ($fieldname,$fieldlabel,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT fieldname,fieldlabel,enabled FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
		$sth->execute() or die_nice("$PREF{internal_appname}: Error: get_custom_userbase_field_names(): $DBI::errstr\n");
		$sth->bind_columns(\$fieldname,\$fieldlabel,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			next unless db_column_exists($fieldname, $which_user_table);
			next if (!$enabled   &&   !$include_disabled_fields);
			$custom_fields{$fieldname} = 1;
			push @custom_fields, $fieldname;
		}
	}

	return wantarray ? @custom_fields : \%custom_fields;
}


sub is_admin_acct($)
{
	#printd "is_admin_acct('$_[0]')\n";

	my $userid = shift;
	return 0 unless $userid;

	return 1 if (!userbase_available()   &&   $userid == -3);

	# don't bother checking the validity of $userid here,
	# because user_is_member_of_group() will do it.
	return user_is_member_of_group($userid,$PREF{admin_group_name});
}


sub is_admin() { return $PREF{admin_is_logged_in}; }   # 20160405: is_admin() is now just a shortcut for $PREF{admin_is_logged_in}.


sub force_pw_change($)
{
	my $userid = shift;
	my $force_pw_change = 0;

	if(		$PREF{enable_forced_password_change} =~ /yes/i
			&&
			enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';")
			&&
			(
				!is_admin_acct($userid)
				||
				(is_admin_acct($userid) && $PREF{admins_can_be_forced_to_change_their_own_pws} =~ /yes/i)
			)
	)
	{
		$force_pw_change = 1;
	}

	if(password_has_expired())
	{
		$force_pw_change = 1;
	}

	return $force_pw_change;
}


sub password_has_expired
{
	my $expired = 0;
	if($PREF{force_pw_chng_after_this_many_hours} =~ /^\d+$/ && $PREF{force_pw_chng_after_this_many_hours} > 0)
	{
		unless($PREF{admin_is_logged_in} && $PREF{admins_can_be_forced_to_change_their_own_pws} =~ /no/i)
		{
			my $time_now = offsettime();
			die_unless_numeric($PREF{logged_in_userid}, '$PREF{logged_in_userid}');
			my $time_of_last_pw_change = enc_sql_select("SELECT MAX(`timestamp`) FROM `$PREF{password_activity_table}` WHERE `user_id` = $PREF{logged_in_userid}");
			$expired = 1 if ($time_now - $time_of_last_pw_change) > ($PREF{force_pw_chng_after_this_many_hours} * 3600);
		}
	}
	return $expired;
}


sub get_group_id($)
{
	printd "get_group_id($_[0])\n";
	my $group = shift;

	if(userbase_available())
	{
		check_groupname_for_uniqueness($group); # checks for sql safeness too.
		return enc_sql_select("SELECT `id` FROM `$PREF{group_table}` WHERE `group` = '$group'");
	}
	else
	{
		   if($group =~ /^$PREF{public_group_name}$/i)	{ return -1; }
		elsif($group =~ /^$PREF{member_group_name}$/i)	{ return -2; }
		elsif($group =~ /^$PREF{admin_group_name}$/i)	{ return -3; }
		else { die_nice("invalid group name '$group'.\n"); }
	}
}


sub check_uid_for_uniqueness($)
{
	#die_unless_numeric($_[0], 'user ID'); # UIDs can be negative, so this test doesn't work here; and check_id_for_sql_safeness takes care of it anyway.
	check_id_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $_[0]")   >   1)
	{
		die_nice("more than one user record with id=$_[0]!\n");
	}
}


sub check_gid_for_uniqueness($)
{
	return unless userbase_available();
	printd "check_gid_for_uniqueness: '$_[0]'\n";

	check_id_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `id` = $_[0]")   >   1)
	{
		die_nice("more than one group record with id=$_[0]!\n");
	}
}


sub check_username_for_uniqueness($)
{
	#printd "check_username_for_uniqueness: '$_[0]'\n";

	check_username_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$_[0]')")   >   1)
	{
		die_nice("more than one user record with username='$_[0]'!\n");
	}
}


sub check_groupname_for_uniqueness
{
	return unless userbase_available();
	printd "check_groupname_for_uniqueness($_[0])\n";

	check_groupname_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$_[0]')")   >   1)
	{
		die_nice("more than one user record with groupname='$_[0]'!\n");
	}
}


sub user_is_member_of_group
{
	my $userid = shift;
	my $group = shift;
	my $not_checking_loggedin_user = shift;

	if($PREF{integrate_with_userbase_method_b} =~ /yes/i   &&   $PREF{logged_in_group_memberships}   &&   !$not_checking_loggedin_user)
	{
		return $PREF{logged_in_group_memberships} =~ /(^|,)$group(,|$)/;
	}
	if(userbase_available()   &&   (($PREF{member_is_logged_in} && !$PREF{login_is_via_encauth}) || $not_checking_loggedin_user))   # TODO: this is ridiculous; it shouldn't matter if a member is logged in; we have an explicit userid...
	{
		check_groupname_for_sql_safeness($group);
		die_unless_numeric($userid,'userid');

		return 1 if $group =~ /^$PREF{public_group_name}$/i;
		return 1 if $group =~ /^$PREF{member_group_name}$/i && enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $userid;");

		# special internal groups:
		return 1 if $group eq 'encwhitelisted' && $PREF{user_is_encwhitelisted};
		return 1 if $group eq 'encblacklisted' && $PREF{user_is_encblacklisted};

		return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group') AND `members` REGEXP '(^|,)$userid(,|\$)'");
	}
	else
	{
		# special internal groups:
		return 1 if $group eq 'encwhitelisted' && $PREF{user_is_encwhitelisted};
		return 1 if $group eq 'encblacklisted' && $PREF{user_is_encblacklisted};

		return 1 if $group =~ /^$PREF{public_group_name}$/i;
		return 1 if $group =~ /^$PREF{member_group_name}$/i && $userid =~ /^-(2|3)$/;
		return 1 if $group =~ /^$PREF{admin_group_name}$/i && $userid == -3;
	}
}


sub user_is_member_of_one_of_these_groups
{
	my $groups = shift;   # comma-separated list of group names.
	my $userid = shift || $PREF{logged_in_userid};   # optional second arg for this sub.
	die_nice qq`Error: no user ID passed in, and no user logged in.` unless $userid;
	foreach my $group (split(/\s*,\s*/, $groups))
	{
		return 1 if user_is_member_of_group($userid, $group);
	}
	return 0;
}


sub user_belongs_to_one_of_these_group_ids($$)
{
	my $uid = shift;
	my $idlist = shift; # list of numeric group IDs separated either by commas or "|||".
	$idlist =~ s!\|\|\|!,!g;
	my $belongs = 0;
	foreach my $gid (split(/\s*,\s*/, $idlist))
	{
		#$belongs = 1 if user_is_member_of_group($uid, get_group_name($gid));
		if(my $groupname = get_group_name($gid))
		{
			if(user_is_member_of_group($uid, $groupname))
			{
				#encdebug qq`user $uid IS member of group ` . get_group_name($gid) . qq` (list=$idlist)`;
				$belongs = 1;
			}
		}
		else
		{
			encdebug "error: gid '$gid' has a null group name ('$groupname')";
		}
	}
	return $belongs;
}


sub logged_in_user_belongs_to_one_of_these_group_ids($)
{
	return user_belongs_to_one_of_these_group_ids($PREF{logged_in_userid}, $_[0]);
}


sub user_belongs_to_a_paid_group
{
	my $uid = shift;
	my $groups = get_groups_hash($uid);
	foreach my $group (keys %$groups)
	{
		return 1 if $$groups{$group}{is_member} && $$groups{$group}{is_paidgroup};
	}
	return 0;
}


sub user_has_access
{
	my $group_id_list = shift;	# comma-separated. must specify at least one of these two lists.
	my $user_id_list = shift;	# comma-separated.
	my $uid = shift;		# optional.

	$uid ||= $PREF{logged_in_userid};   # use the logged-in UID, unless a different one was specified.

	return   ($uid && ($user_id_list =~ /(^|,)\s*$uid\s*(,|$)/))   ||   user_belongs_to_one_of_these_group_ids($uid, $group_id_list);
}


sub userbase_available
{
	return ($PREF{internal_appname} eq 'userbase'   ||   $PREF{integrate_with_userbase} =~ /yes/i   ||   $PREF{integrate_with_userbase_method_b} =~ /yes/i);
}


sub userbase_user_table_exists
{
	return db_table_exists($PREF{user_table});
}


sub get_user_id($)
{
	#printd "get_user_id('$_[0]')\n";

	my $username = shift;

	if(userbase_available()   &&   $username)
	{
		die_nice("Error: invalid username '$username'.\n") unless username_is_valid($username);
		check_username_for_uniqueness($username); # checks for sql safeness too.
		return enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username')");
	}
	else
	{
		   if($PREF{admin_is_logged_in})	{ return -3; }
		elsif($PREF{member_is_logged_in})	{ return -2; }
		else					{ return -1; } # public.
	}
}


sub get_member_ids_for_group
{
	printd "get_member_ids_for_group($_[0])\n";

	my $group = shift;
	check_groupname_for_sql_safeness($group);

	 # every account is automatically a member of these groups.
	if($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i)
	{
		my $statement = "SELECT `id` FROM `$PREF{user_table}`";
		return $PREF{dbh}->selectall_hashref($statement, 'id');
	}
	else
	{
		my $member_ids = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
		my %member_ids = map { $_ => 1 } split(/,/, $member_ids);
		return \%member_ids;
	}
}


# 20110404: APICHANGE: previously this sub accepted just a single argument,
# which was the group name.  Now it accepts an anonymous hash.
# 20121004: we now accept a 'groups' arg (comma-separated list) to support
# multiple groups; 'group' singular is still supported as well.
#
sub get_users_belonging_to_group
{
	# Example usage:
	#my $users = get_users_belonging_to_group({ groups=>'member, other' });
	#foreach my $uid (keys %$users)
	#{
	#	print qq`Name: $$users{$uid}{name}, Email: $$users{$uid}{email} <br /><br />`;
	#}

	my %users = (); return \%users unless userbase_available();

	my $optsref = shift; my %opts = %$optsref if $optsref;

	my @groups = $opts{groups} ? split(/\s*,\s*/, $opts{groups}) : ($opts{group});

	my $userids = '';
	foreach my $group (@groups)
	{
		check_groupname_for_sql_safeness($group);
		if($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i)
		{
			my $userids_hashref = enc_sql_select_multi("SELECT `id` FROM `$PREF{user_table}`");
			foreach my $j (sort { $a <=> $b } keys %$userids_hashref) { $userids .= $$userids_hashref{$j}{id} . ","; }
		}
		else
		{
			$userids .= enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')") . ',';
		}
	}
	decommaify($userids);
	# $userids may contain dupes at this point, because of the foreach() above, but the %users
	# hash below will eliminate any dupes.

	foreach my $uid (split(/,/, $userids))
	{
		die_unless_numeric($uid, 'user ID');
		next if $opts{exclude_pending} && account_is_pending($uid);
		next if $opts{exclude_admins} && is_admin_acct($uid);
		my $userdata = enc_sql_select_multi("SELECT * FROM `$PREF{user_table}` WHERE `id` = $uid");
		foreach my $field (keys %{$$userdata{1}})
		{
			$users{$uid}{$field} = $$userdata{1}{$field};
		}
	}

	return \%users;
}


sub get_user_name($)
{
	return unless userbase_available();
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `username` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
}


sub get_real_name
{
	return unless userbase_available();
	return unless $_[0];
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `name` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
}


sub get_group_name($)
{
	my $gid = shift;
	if(userbase_available())
	{
		check_gid_for_uniqueness($gid); # checks for sql safeness too.
		return enc_sql_select("SELECT `group` FROM `$PREF{group_table}` WHERE `id` = $gid");
	}
	else
	{
		# In rare situations, a user/feature might specify an allowed group (via gid) with UserBase
		# installed, but then later will run it without UserBase.  Then those gids (still in the app
		# database, e.g. the groups_allowed_to_view in cornerstore_categories) will be invalid and
		# cause an error here.  But for the 3 built-in groups we can fix that, since public/member/
		# admin are 1/2/3 in UB and -1/-2/-3 without UB.  It won't solve all problems related to
		# removing UB, but for these most common ones at least, it'll be correct.
		#
		$gid = "-$gid" unless $gid =~ /^-/;

		   if($gid == -1)	{ return $PREF{public_group_name}; }
		elsif($gid == -2)	{ return $PREF{member_group_name}; }
		elsif($gid == -3)	{ return $PREF{admin_group_name}; }
		else { die_nice("invalid group ID '$gid'.\n"); }
	}
}


sub get_email_address($)
{
	return unless userbase_available();
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	my ($username,$email) = enc_sql_select("SELECT `username`,`email` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
	$email = $username if is_valid_email_address($username) && !is_valid_email_address($email);
	return $email;
}


sub hashedpw_is_valid				{ return  $_[0] =~ /^[0-9A-Za-z]+$/					&&	length($_[0]) <= $PREF{max_hashedpw_length};	}
sub sessionid_is_valid				{ return  $_[0] =~ /^[0-9A-Za-z]+$/					&&	length($_[0]) <= $PREF{max_hashedpw_length};	}


sub username_is_valid
{
	my $space = $PREF{allow_spaces_in_usernames} =~ /yes/i ? ' ' : '';
	my $atsign = $PREF{allow_atsigns_in_usernames} =~ /yes/i ? '@' : '';
	my $dot = $PREF{allow_dots_in_usernames} =~ /yes/i ? '.' : '';
	my $dash = $PREF{allow_dashes_in_usernames} =~ /yes/i ? '-' : '';

	return ($_[0] =~ /^[0-9A-Za-z_$space$atsign$dot$dash]+$/   &&   $_[0] =~ /\w/	&&	length($_[0]) <= $PREF{max_username_length});
}

sub groupname_is_valid
{
	my $space	= ($PREF{allow_spaces_in_usernames} =~ /yes/i	|| $PREF{allow_spaces_in_groupnames} =~ /yes/i)		? ' ' : '';
	my $atsign	= ($PREF{allow_atsigns_in_usernames} =~ /yes/i	|| $PREF{allow_atsigns_in_groupnames} =~ /yes/i)	? '@' : '';
	my $dot		= ($PREF{allow_dots_in_usernames} =~ /yes/i	|| $PREF{allow_dots_in_groupnames} =~ /yes/i)		? '.' : '';
	my $dash	= ($PREF{allow_dashes_in_usernames} =~ /yes/i	|| $PREF{allow_dashes_in_groupnames} =~ /yes/i)		? '-' : '';

	return ($_[0] =~ /^[0-9A-Za-z_$space$atsign$dot$dash]+$/   &&   $_[0] =~ /\w/	&&	length($_[0]) <= $PREF{max_groupname_length});
}

sub check_hashedpw_for_sql_safeness		{ die_nice(qq`Invalid hashed password:	'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless hashedpw_is_valid($_[0]);	}
sub check_username_for_sql_safeness		{ die_nice(qq`Invalid username:		'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless username_is_valid($_[0]);	}
sub check_groupname_for_sql_safeness		{ die_nice(qq`Invalid groupname:	'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless groupname_is_valid($_[0]);	}
sub check_sessionid_for_sql_safeness		{ die_nice(qq`Invalid session ID:	'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless sessionid_is_valid($_[0]);	}
sub check_id_for_sql_safeness			{ die_nice(qq`Invalid ID:		'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless $_[0] =~ /^(\d+|-[123])$/;	}


sub get_groups_hash
{
	printd "get_groups_hash('$_[0]')\n";

	# If you pass in a uid, then the resulting hash will
	# also indicate which groups that user is a member of.
	#

	my $user_id = shift;

	my ($id, $group, $members, %groups) = ();
	if(userbase_available())
	{
		my $allgroups = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}`");
		foreach my $k (keys %$allgroups)
		{
			my $group = $$allgroups{$k}{group};

			$groups{$group}{name}			= $group;
			$groups{$group}{id}			= $$allgroups{$k}{id};
			$groups{$group}{members}		= $$allgroups{$k}{members};
			$groups{$group}{is_paidgroup}		= $$allgroups{$k}{price} > 0;
			$groups{$group}{daily_access_limit}	= $$allgroups{$k}{daily_access_limit};

			my $is_member = 0;
			if($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i)	{ $is_member = 1; }
			elsif($user_id =~ /^\d+$/)						{ $is_member = $$allgroups{$k}{members} =~ /(^|,)$user_id(,|$)/; }

			$groups{$group}{is_member}	= $is_member;
		}
	}
	else
	{
		$groups{$PREF{public_group_name}}{name}		= $PREF{public_group_name};
		$groups{$PREF{public_group_name}}{id}		= -1;
		$groups{$PREF{public_group_name}}{is_member}	= 1; # everyone's a member of the public.

		$groups{$PREF{member_group_name}}{name}		= $PREF{member_group_name};
		$groups{$PREF{member_group_name}}{id}		= -2;
		$groups{$PREF{member_group_name}}{is_member}	= 1 if $user_id =~ /^-(2|3)$/;

		$groups{$PREF{admin_group_name}}{name}		= $PREF{admin_group_name};
		$groups{$PREF{admin_group_name}}{id}		= -3;
		$groups{$PREF{admin_group_name}}{is_member}	= 1 if $user_id =~ /^-3$/;
	}

	return \%groups;
}


# Returns a colon-separated list of group names.
#
sub get_groups_this_user_belongs_to($)
{
	my $uid = shift;
	my @list = ();
	my $groups = get_groups_hash($uid);
	foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
	{
		push(@list,$group) if $$groups{$group}{is_member};
	}
	return join ":", @list;
}


sub get_email_addresses_for_all_members_of_this_users_groups
{
	my $uid = shift; die_unless_numeric($uid, "user ID");
	my $include_users_own_email_address = shift; $include_users_own_email_address = 0 unless $include_users_own_email_address eq 'include_users_own_email_address';
	my $include_builtin_public_group = shift;    $include_builtin_public_group    = 0 unless $include_builtin_public_group    eq 'include_builtin_public_group';
	my $include_builtin_member_group = shift;    $include_builtin_member_group    = 0 unless $include_builtin_member_group    eq 'include_builtin_member_group';
	my $include_builtin_admin_group = shift;     $include_builtin_admin_group     = 0 unless $include_builtin_admin_group     eq 'include_builtin_admin_group';

	my %email_addresses = ();
	my $allgroups = get_groups_hash($uid);
	foreach my $group (sort keys %$allgroups)
	{
		next if $group =~ /^$PREF{public_group_name}$/i && !$include_builtin_public_group;
		next if $group =~ /^$PREF{member_group_name}$/i && !$include_builtin_member_group;
		next if $group =~ /^$PREF{admin_group_name}$/i  && !$include_builtin_admin_group;

		if(my $this_user_belongs_to_this_group = $$allgroups{$group}{is_member})
		{
			foreach my $member_id (split(/\s*,\s*/, $$allgroups{$group}{members}))
			{
				my $email = get_email_address($member_id);
				$email_addresses{ $email } = 1 unless !$include_users_own_email_address && $email eq $PREF{logged_in_email};
			}
		}
	}
	return keys %email_addresses;   # returns an array when this sub is called in list context.
}


# This function must do a case-insensitive lookup (i.e. use LOWER() on both sides)
# so that we never create a username multiple times with different cases.
#
sub username_is_taken
{
	return 0 unless userbase_available();
	my $user = shift;
	check_username_for_sql_safeness($user);
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$user')");
}


sub email_address_is_taken
{
	my $address = shift;
	check_emailaddr_for_sql_safeness($address);
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`email`) = LOWER('$address')");
}


sub setup_admin_password()
{
	return if $PREF{admin_password_hash_01};

	if($PREF{internal_appname} eq 'userbase')
	{
		my ($db_connection_already_configured_and_working,undef) = get_db_connection();
		return if $db_connection_already_configured_and_working;
	}

	$PREF{csswrapperclass} = 'encnarrow';

	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		# Note: we can't exit via anything that uses kmsg here, because this sub gets
		# called from do_app_init before the dispatch chain that would show the kmsg.
		# (Except of course after we've set the admin pw via webconfig.)

		my $hashed_password = make_encauthpw(enc_param('encauthnewpw'));
		my $safe_to_set_pw_via_webconfig = 0;

		if($PREF{internal_appname} eq 'filechucker')
		{
			my $uploaded_file_count = count_items___raw($PREF{uploaded_files_realpath});
			my $output = "items: $uploaded_file_count";

			if($uploaded_file_count < 2)   # and we're in setup_admin_password() so admin pw is also null.
			{
				# On brand-new installations, the count will be 1: the only file in the
				# uploaded files dir will be our default /upload/files/.htaccess file.  

				$safe_to_set_pw_via_webconfig = 1;
			}
		}
		elsif($PREF{internal_appname} eq 'userbase')
		{
			if(!$PREF{database_name} && !$PREF{database_username} && !$MISC{a_userbase_account_has_logged_in_at_some_point})
			{
				# If these are null (and we're in setup_admin_password() so admin pw is also null) then it's a new installation.
				$safe_to_set_pw_via_webconfig = 1;
			}
		}
		elsif($PREF{internal_appname} eq 'mailylist')
		{
			opendir(DIR,"$PREF{backup_and_log_dir}") or die_nice "couldn't open directory $PREF{backup_and_log_dir}: $!\n";
			my @successful = grep(/\.successful\.cgi$/, readdir(DIR));
			my @notyetsent = grep(/\.notyetsent\.cgi$/, readdir(DIR));
			my @incomplete = grep(/\.incomplete\.cgi$/, readdir(DIR));
			closedir DIR or die_nice "couldn't close directory $PREF{backup_and_log_dir}: $!\n";

			if(!@notyetsent && !@incomplete && !@successful)
			{
				# If no newsletters have ever been composed nor sent (and we're in setup_admin_password() so admin pw is also null) then it's a new installation.
				$safe_to_set_pw_via_webconfig = 1;
			}
		}
		elsif($PREF{internal_appname} eq 'cornerstore')
		{
			if(!$PREF{database_name} && !$PREF{database_username})
			{
				# If these are null (and we're in setup_admin_password() so admin pw is also null) then it's a new installation.
				$safe_to_set_pw_via_webconfig = 1;
			}
		}
		elsif($PREF{internal_appname} eq 'visitorlog')
		{
			if(!$PREF{database_name} && !$PREF{database_username})
			{
				# If these are null (and we're in setup_admin_password() so admin pw is also null) then it's a new installation.
				$safe_to_set_pw_via_webconfig = 1;
			}
		}

		if($safe_to_set_pw_via_webconfig)
		{
			save_new_webconfig_pref('admin_password_hash_01', $hashed_password);
			applog(qq`admin_password_hash_01 was just set by visitor from IP=$PREF{ip}, host=$PREF{host}, UA=$ENV{HTTP_USER_AGENT}`);
			start_html_output("Password set successfully");
			print qq`<p>Your admin password has been set.&nbsp; `;
			if($PREF{internal_appname} =~ /^(userbase|visitorlog|cornerstore|livechat)$/)
			{
				print qq`<a href="$PREF{here_qsready}action=login&amp;whence=$PREF{REQ_URI_SANS_QS}_THEQS_action=dbsetup">Click here to continue</a>.</p>`;
			}
			else
			{
				print qq`<a href="$PREF{here_qsready}action=login">Click here to continue</a>.</p>`;
			}
			finish_html_output();
		}
		else
		{
			$PREF{csswrapperclass} = '';   # not narrow
			start_html_output('Here is your hashed password...');
			print	  qq`<p>The hashed version of the password you just entered is:</p><p>$hashed_password</p>`
				. qq`<p>Now open your $PREF{internal_appname}_prefs_extra.cgi file and paste this line into it (all on one line):</p>`
				. qq`<p class="pref_code">\$PREF{admin_password_hash_01} = '$hashed_password';</p>`;
			finish_html_output();
		}
	}
	else
	{
		applog(qq`showing the congrats/setup page to visitor from IP=$PREF{ip}, host=$PREF{host}, UA=$ENV{HTTP_USER_AGENT}`);
		my $details = $PREF{internal_appname} eq 'userbase' ? qq`<br /><br />Setup Step #1 of 3: Please create your bootstrap password now.&nbsp; This is an admin-level password that will only be used briefly, during setup, while we configure your database connection and create your first UserBase admin account.` : qq`Please create your administrator password now.`;
		start_html_output('Enter your new password');
		print qq`<p>Congratulations!&nbsp; $PREF{internal_appname_nice} is now installed and running properly.&nbsp; $details</p>
			<form accept-charset="UTF-8" method="post" action="$ENV{SCRIPT_NAME}?newpw" id="newpass">Your password:
			<br /><input type="password" name="encauthnewpw" id="encauthnewpw" maxlength="4" class="default text" />
			<br />Password again:
			<br /><input type="password" name="encauthnewpwver" id="encauthnewpwver" maxlength="4" class="default text" />
			<br /><br /><input type="button" value="Create Password" class="default button submit" onclick="if(gebi('encauthnewpw').value == gebi('encauthnewpwver').value) { gebi('newpass').submit(); } else { alert('Error: passwords do not match.'); }" />
			</form>
		`;
		finish_html_output();
	}

	exit;
}


sub do_pw_hash_format3
{
	my ($pw,$salt,$iterations,$returntype) = @_;
	$salt .= $PREF{site_salt};
	my $hash = sha256_hex($salt . $pw);
	for(my $i=0; $i<$iterations; $i++)
	{
		$hash = sha256_hex($salt . $hash);
	}

	# All new password hashes (format 3 or newer) must end with vNxMsAZ, where v/x/s are
	# literal, N is the format number, M is the number of hash iterations, and AZ is the
	# first and last characters of the site salt.
	#
	my ($sitesaltA, $sitesaltZ) = ($PREF{site_salt} =~ /^([0-9a-zA-Z]).+?([0-9a-zA-Z])$/);
	die_nice qq`Error: missing/invalid value for \$PREF{site_salt}: '$PREF{site_salt}'; it must be a long random string of hex characters (~50-100 chars long).` unless $PREF{site_salt} && ($sitesaltA ne "") && ($sitesaltZ ne "");
	$hash .= "v3x${iterations}s${sitesaltA}${sitesaltZ}" unless $returntype eq 'base';
	return $hash;
}


sub make_password_hash
{
	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		my $hashed_password = make_encauthpw(enc_param('encauthnewpw'));
		start_html_output('Here is your hashed password...');
		print	  qq`<p>The hashed version of the password you just entered is:</p><p>$hashed_password</p>`
			. qq`<p>Now open your $PREF{internal_appname}_prefs_extra.cgi file and paste one of the following lines into it.</p>`
			. qq`<p>To make this an admin password, paste in this line (all on one line):</p><p class="pref_code">\$PREF{admin_password_hash_01} = '$hashed_password';</p>`
			. qq`<p>Or, to make this a member password, paste in this line (all on one line):</p><p class="pref_code">\$PREF{member_password_hash_01} = '$hashed_password';</p>`
			. qq`<p>(Of course, you could also use _02, _03, etc, in the pref name, if you want to set multiple passwords.</p>`;
		finish_html_output();
	}
	else
	{
		start_html_output('Enter your new password');
		print	  qq`<form accept-charset="UTF-8" method="post" action="$ENV{SCRIPT_NAME}?newpw" id="newpass">\n`
			. qq`\n<br /><input type="password" name="encauthnewpw" id="encauthnewpw" maxlength="200" class="default text" /><div id="pw_strength"></div>`
			. qq`\n<br /><input type="submit" value="create hash" class="default button submit" />`
			. qq`\n</form>`;
		finish_html_output();
	}
}


sub create_pw_hash_ajax()
{
	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	print "newhash=" . make_encauthpw(enc_param('ptpw'));
	print qq`</data>\n`;
}


sub make_encauthpw($)
{
	# Basically the same as create_new_password_hash() except using the $PREF{site_salt} in
	# place of the random per-account salt, since this is for passwords in FC/VL/etc (and for
	# WebConfig even in UB), where there are no accounts, and thus no per-account salts.

	my $plaintext_password = shift;
	$plaintext_password = lc($plaintext_password) if $PREF{make_passwords_case_insensitive} =~ /yes/i;
	my $hashed_password = do_pw_hash_format3($plaintext_password, '', $PREF{password_hash_iterations});   # passing a null salt, which do_pw_hash_format3() will turn into just $PREF{site_salt}.
	return $hashed_password;
}


sub hash_and_check_encauthpw($)
{
	my $plaintextpw = shift;

	foreach my $hashedpw (keys %{$PREF{all_admin_password_hashes}}, keys %{$PREF{all_member_password_hashes}})
	{
		if($hashedpw =~ /^(.+)v(\d+)x(\d+)s/)
		{
			my ($hashedpw_base_fromserver,$pwformat,$iterations) = ($1, $2, $3);
			if($pwformat == 3)
			{
				# Currently, 3 is the only one.
				my $hashedpw_base_fromclient = do_pw_hash_format3($plaintextpw, '', $iterations, 'base');   # passing a null salt, which do_pw_hash_format3() will turn into just $PREF{site_salt}.
				if($hashedpw_base_fromclient eq $hashedpw_base_fromserver)
				{
					# Return just the hashbase, not the full hash, because this is going to get stored in
					# the visitor's cookie, and there's no need to expose the extra details there.
					return($hashedpw_base_fromclient, 1);
				}
			}
			else
			{
				exit_with_error qq`Error: couldn't determine password format.`;   # something went really wrong
			}
		}
		elsif(length($hashedpw) == 40)   # SHA1, still supported for backwards compatibility.
		{
			if(sha1_hex($plaintextpw) eq $hashedpw) { return($hashedpw, 1); }
		}
		elsif(length($hashedpw) == 32)   # MD5, still supported for backwards compatibility.
		{
			if(md5_hex($plaintextpw) eq $hashedpw) { return($hashedpw, 1); }
		}
		else
		{
			exit_with_error qq`Error: couldn't determine password type.`;   # something went really wrong
		}
	}

	return (undef, 0);
}


sub user_is_allowed_to
{
	# TODO: these separate per-app branches can probably be partially or totally reconciled.

	if($PREF{internal_appname} eq 'userbase')
	{
		my $userid_performing_action = scalar(@_) == 1 ? $PREF{logged_in_userid} : shift; # if only 1 arg was passed, it's the action, implying we should automatically use the logged_in_userid.
		my $action = shift;
		my $user_affected_by_action = shift;
		my $userid_affected_by_action = get_user_id($user_affected_by_action);

		if($action eq 'edit_user_info')
		{
			return 1 if (logged_in_user_is_subgroup_manager()   &&   $userid_affected_by_action   &&   logged_in_subgroup_manager_owns_this_user($userid_affected_by_action));
		}

		foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"}))
		{
			return 0 if user_is_member_of_group($userid_performing_action, $group);
		}

		foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"}))
		{
			if($group =~ /^self$/i)
			{
				return 0 if ($PREF{member_is_logged_in}   &&   $userid_performing_action == $userid_affected_by_action);
			}
			else
			{
				return 0 if user_is_member_of_group($userid_performing_action, $group);
			}
		}

		foreach my $group (split(/\s*,\s*/, $PREF{"groups_allowed_to_$action"}))
		{
			if($group =~ /^self$/i)
			{
				return 1 if ($PREF{member_is_logged_in}   &&   $userid_performing_action == $userid_affected_by_action);
			}
			else
			{
				return 1 if user_is_member_of_group($userid_performing_action, $group);
			}
		}

		return 0;
	}
	else
	{
		my $action = shift;
		foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"}))
		{
			return 0 if user_is_member_of_group($PREF{logged_in_userid}, $group);
		}
		foreach my $group (split(/\s*,\s*/, $PREF{"groups_allowed_to_$action"}))
		{
			return 1 if user_is_member_of_group($PREF{logged_in_userid}, $group);
		}
		return 0;
	}
}


sub logged_in_user_is_part_of_a_subgroup()
{
	return 0 unless $PREF{member_is_logged_in};
	return $PREF{subgroup_manager_username} if exists $PREF{subgroup_manager_username}; # if this sub has already been called once, no need to re-do it.
	$PREF{subgroup_manager_username} = user_is_part_of_a_subgroup($PREF{logged_in_userid});
	$PREF{subgroup_manager_userid} = get_user_id($PREF{subgroup_manager_username}) if $PREF{subgroup_manager_username};
	$PREF{subgroup_manager_email} = get_email_address($PREF{subgroup_manager_userid}) if $PREF{subgroup_manager_username};
	return $PREF{subgroup_manager_username};
}


sub user_is_part_of_a_subgroup($)
{
	#foreach my $group (enc_sql_select("SELECT "))
	#{
	#	if($group =~ /.+$PREF{subgroup_groupname_suffix}$/i)
	#	{
	#		return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group') AND `members` REGEXP '(^|,)$PREF{logged_in_userid}(,|\$)'");
	#	}
	#}

	my $uid = shift;
	return '' unless userbase_available();

	my $subgroup_groupname_suffix = $PREF{subgroup_groupname_suffix};
	sql_untaint($subgroup_groupname_suffix);
	exit_with_error("not SQL safe: \$subgroup_groupname_suffix ('$subgroup_groupname_suffix').") if not_sqlsafe($subgroup_groupname_suffix);

	die_unless_numeric($uid, '$uid');

	#return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `group` REGEXP '.+$subgroup_groupname_suffix\$' AND `members` REGEXP '(^|,)$uid(,|\$)'");
	#
	# 20111112: changing this to return the username of the SGM, rather than just
	# a zero or a number greater than zero, which doesn't change the true/false
	# value of the result, but makes it more useful:
	#
	my $subgroup = enc_sql_select("SELECT `group` FROM `$PREF{group_table}` WHERE `group` REGEXP '.+$subgroup_groupname_suffix\$' AND `members` REGEXP '(^|,)$uid(,|\$)'");
	my $subgroup_manager_username = ($subgroup =~ m!(.+)$subgroup_groupname_suffix$!)[0];
	return $subgroup_manager_username;
}


sub logged_in_user_is_subgroup_manager
{
	foreach my $group (split(/\s*,\s*/, $PREF{groups_that_can_manage_subgroup_users}))
	{
		return 1 if user_is_member_of_group($PREF{logged_in_userid}, $group);
	}
	return 0;
}


sub logged_in_subgroup_manager_owns_this_user($)
{
	my $userid_to_check = shift;
	return user_is_member_of_group($userid_to_check, "$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}");
}


sub user_is_subgroup_manager
{
	my $username = shift;
	my $userid = get_user_id($username);
	foreach my $group (split(/\s*,\s*/, $PREF{groups_that_can_manage_subgroup_users}))
	{
		return 1 if user_is_member_of_group($userid, $group, 1);
	}
	return 0;
}


sub this_subgroup_manager_owns_this_user($$)
{
	my $subgroup_manager_userid = shift;
	my $userid_to_check = shift;
	my $subgroup_manager_username = get_user_name($subgroup_manager_userid);
	return user_is_subgroup_manager($subgroup_manager_username) && user_is_member_of_group($userid_to_check, "${subgroup_manager_username}$PREF{subgroup_groupname_suffix}");
}


sub exit_with_access_denied
{
	exit_with_needprivs();
}


sub is_builtin_group
{
	return $_[0] =~ /^($PREF{admin_group_name}|$PREF{member_group_name}|$PREF{public_group_name}|$PREF{expired_group_name})$/i;
}


sub is_paid_group
{
	my $groupname = shift;
	my $gid = get_group_id($groupname);
	return enc_sql_select("SELECT `price` FROM `$PREF{group_table}` WHERE `id` = $gid") > 0;
}


##############################################################################
### Dispatch-UB: #############################################################
##############################################################################


do_app_init();

   if($qs eq 'ublogout')						{ do_logout();					}
elsif($qs eq 'ublogoutall')						{ do_logout('all');				}

# Note: this must happen before most other checks in the dispatch chain, to prevent stuff that doesn't belong in the mini or justlink modes from showing up there.
elsif($qs =~ /(?:^|&)format=justlink(?:&|$)/)				{ print_login_logout_link_and_exit();		}
elsif($qs =~ /(?:^|&)format=loginstatus(?:&|$)/)			{ print_login_status_and_exit();		}
elsif($qs =~ /(?:^|&)format=mini(?:&|$)/)				{ $PREF{member_is_logged_in} ? print_main_menu() : $qs =~ /action=validate/ ? do_ub_login() : prompt_for_login(); }

# Note: this must happen before most other checks in the dispatch chain, because of things like action=serverinfo which are valid for multiple
# apps including UB.  F.e. if FC redirects to UB to get auth for serverinfo, we want to display the login page, not our own serverinfo page.
# TODO: might need to tweak this though, for the case where a member *is* logged in but doesn't have *enough* privs for the requested page.
elsif($qs =~ /(?:^|&)needprivs=true(?:&|$)/)				{ $PREF{member_is_logged_in} ? print_main_menu() : prompt_for_login(); }

elsif($qs =~ /(?:^|&)$PREF{twochar_app_id}kmsg=(\w+)(?:&|$)/)		{ exit_with_kmsg($1);				}
elsif($qs =~ /(?:^|&)$PREF{twochar_app_id}smsg=(\w+)(?:&|$)/)
{
	exit_with_error($TEXT{"smsg_$1"}) if $TEXT{"smsg_$1"}; # for text strings that are entirely static, name them $TEXT{smsg_foo}.
}

elsif($qs =~ /ajax_do_humantest&encht1=(.*?)&encht2=(.*?)(?:&|$)/)
{
	my $passed_test = do_human_test($1,$2);
	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<progress>\n<data>`;
	print $passed_test ? 'passed=true' : 'passed=false';
	print qq`</data>\n</progress>\n`;
}

elsif($qs =~ /createrandomadmin/ && $PREF{allow_random_admin_account_creation} =~ /yes/i) { create_random_admin_account_and_exit();	}

elsif($qs =~ /(?:^|&)action=loggedout(?:&whence=(.*))?(?:&|$)/)		{ $PREF{member_is_logged_in} ? enc_redirect($PREF{here}) : show_loggedout_page($1); } # note that the whence regex is .* not .*? because the value will likely contain ampersands that we want to keep.
elsif($qs =~ /(?:^|&)action=showusers(?:&|$)/)				{ showusers();					}
elsif($qs =~ /(?:^|&)action=showuserstest(?:&|$)/)			{ showusers_new();				}
elsif($qs =~ /(?:^|&)action=bulkuser(?:&|$)/)				{ manage_bulk_user_actions();			}
elsif($qs =~ /(?:^|&)action=userinfo&id=(\d+)(?:&|$)/)			{ show_user_info($1);				}
elsif($qs =~ /(?:^|&)action=(signup|newaccount)(?:&|$)/)		{ print_user_form('user_signup');		}
elsif($qs =~ /(?:^|&)action=adduser(?:&|$)/)				{ print_user_form('added_by_admin');		}
elsif($qs =~ /(?:^|&)action=edituser(?:&|$)/)				{ print_user_form('edit');			}
elsif($qs =~ /(?:^|&)action=commitadduser(?:&|$)/)			{ process_new_account();			}
elsif($qs =~ /(?:^|&)action=commitedituser(?:&|$)/)			{ edit_user_account();				}
elsif($qs =~ /(?:^|&)action=verify&u=(\d+)&t=(\w+)(?:&|$)/)		{ do_email_verification($1,$2);			}
elsif($qs =~ /(?:^|&)action=resendvrfemail(?:&|$)/)			{ resend_verification_email();			}
elsif($qs =~ /(?:^|&)action=approve_or_del&uid=(\d+)(?:&|$)/)		{ approve_or_delete_pending_account($1);	}
elsif($qs =~ /(?:^|&)action=approve_pending_acct&uid=(\d+)(?:&|$)/)	{ approve_or_delete_pending_account_stage2($1,'approve');	}
elsif($qs =~ /(?:^|&)action=delete_pending_acct&uid=(\d+)(?:&|$)/)	{ approve_or_delete_pending_account_stage2($1,'delete');	}
elsif($qs =~ /(?:^|&)action=showlogins(?:&|$)/)				{ show_logins();				}
elsif($qs =~ /(?:^|&)action=showfailedlogins(?:&|$)/)			{ show_failed_logins();				}
elsif($qs =~ /(?:^|&)action=showpwlog(?:&|$)/)				{ show_password_activity();			}
elsif($qs =~ /(?:^|&)action=infoupdates(?:&|$)/)			{ show_userinfo_updates();			}
elsif($qs =~ /(?:^|&)action=changeimage(?:&|$)/)			{ change_profile_image();			}
elsif($qs =~ /(?:^|&)action=viewuser(?:&|$)/)				{ show_user_profile();				}
elsif($qs =~ /(?:^|&)action=memberdirectory(?:&|$)/)			{ show_member_directory();			}
elsif($qs =~ /(?:^|&)action=ubsentmail(?:&|$)/)				{ view_sent_mail();				}

elsif($qs =~ /(?:^|&)action=commitdeleteuser&id=(.+?)(?:&|$)/)		{ delete_user($1,0);				}
elsif($qs =~ /action=ajaxdeleteusers&uids=([\d-]+)(?:&|$)/)
{
	my ($num_deleted, $num_failed, $msg, $deleted_uids) = delete_users_ajax($1);
	print_xml_headers();
	print qq`<?xml version="1.0" encoding="UTF-8"?>\n<data>`;
	print "acct_deletion_result=num_deleted=${num_deleted}:::::num_failed=${num_failed}:::::deleted_uids=${deleted_uids}:::::msg=${msg}";
	print qq`</data>\n\n`;
}

# new group-management subs:
elsif($qs =~ /(?:^|&)action=groups(?:&|$)/)				{ show_groups_table();				}
elsif($qs =~ /(?:^|&)action=addallusers&gid=(\d+)(?:&|$)/)		{ add_all_users_to_group($1);			}
elsif($qs =~ /(?:^|&)action=remallusers&gid=(\d+)(?:&|$)/)		{ remove_all_users_from_group($1);		}
elsif($qs =~ /(?:^|&)action=grouplog(?:&|$)/)				{ show_group_log();				}

elsif($qs =~ /(?:^|&)action=validate(?:&|$)/)				{ do_ub_login();				}
elsif($qs =~ /(?:^|&)action=chklogin(?:&|$)/)				{ check_login();				}
#elsif($qs =~ /(?:^|&)action=chpw(?:&|$)/)				{ chpw();					}
#elsif($qs =~ /(?:^|&)action=chpw2(?:&|$)/)				{ chpw2();					}

# new custom fields manager:
elsif($qs =~ /(?:^|&)action=customfields(?:&|$)/)			{ show_custom_fields_manager();			}
elsif($qs =~ /(?:^|&)action=fieldsections(?:&|$)/)			{ show_field_sections_manager();		}

elsif($qs =~ /(?:^|&)action=csvimport(?:&|$)/)				{ import_users_from_CSV_file();			}
elsif($qs =~ /(?:^|&)action=csvexport(?:&|$)/)				{ export_users_to_CSV_file();			}

elsif(get_qs_var('action') eq 'showprefs')				{ show_prefs();					}
elsif(get_qs_var('action') eq 'serverinfo')				{ show_server_info();				}

elsif($qs =~ /(?:^|&)action=pwreset1(?:&|$)/)				{ print_pwreset_page();				}
elsif($qs =~ /(?:^|&)action=pwreset2(?:&|$)/)				{ send_pwreset_email();				}
elsif($qs =~ /(?:^|&)action=pwreset3(?:&|$)/)				{ process_pwreset();				}

elsif($qs =~ /(?:^|&)action=test(?:&|$)/)				{ test_function();				}

elsif($qs =~ /(?:^|&)rslt=\d+(?:&|$)/)					{ show_results_page();				}
elsif($qs =~ /(?:^|&)phase=([es].+?)(?:&|$)/)				{ show_message($1);				}

# new web-based paid accounts:
elsif($qs =~ /(?:^|&)action=joinpaidgroup(?:&|$)/)			{ join_paid_group();				}
elsif($qs =~ /(?:^|&)action=joinpaidgroupsubs(?:&|$)/)			{ join_paid_group_for_subusers();		}
elsif($qs =~ /(?:^|&)action=ajaxjoinfreepaidgroup(?:&|$)/)		{ ajax_join_free_paid_group();			}
elsif($qs =~ /(?:^|&)action=confirmgrouppayment(?:&|$)/)		{ print_paid_group_payment_confirmation_page();	}
elsif($qs =~ /(?:^|&)action=viewpayments(?:&|$)/)			{ view_payments();				}
elsif($qs =~ /(?:^|&)action=payreport(?:&|$)/)				{ view_payment_summary();			}
elsif($qs =~ /(?:^|&)action=promos(?:&|$)/)				{ manage_promos();				}

elsif($qs =~ /(?:^|&)action=editmainmenu(?:&|$)/)			{ edit_main_menu();				}
elsif($qs =~ /(?:^|&)action=groupmenu(?:&|$)/)				{ print_group_menu();				}
elsif($qs =~ /(?:^|&)action=createadminmenu(?:&|$)/)
{
	# Added 201507, mostly for rare cases where the menu somehow got screwed up...
	exit_with_needprivs() unless $PREF{admin_is_logged_in};
	create_default_links_in_admin_mainmenu();
	output_and_exit({ msg=>'Done!' });
}

# NOTE! The dirlock line MUST come before the basiclock line here, because of the shared URL var name (ppge):
elsif($qs =~ /(?:^|&)pdir=(\d+)&ppge=(.*)(?:&|$)/)			{ display_dirlock_protected_page($1,$2);	}   # DirLock (or FileChucker) should be used instead.
elsif($qs =~ /(?:^|&)(?:protectedpage|ppge)=(.+)(?:&|$)/)		{ display_basiclock_protected_page($1);		}   # BasicLock is not recommended.
elsif(get_qs_var('action') eq 'managepagelock')				{ manage_pagelock_pages();			}
elsif(get_qs_var('action') eq 'pagelock')				{ pagelock_page();				}
elsif(get_qs_var('action') eq 'unpagelock')				{ unpagelock_page();				}
elsif(get_qs_var('action') eq 'dirlock')				{ manage_dirlock_dirs();			}
elsif(get_qs_var('action') eq 'dirlock_lock')				{ dirlock_page();				}
elsif(get_qs_var('action') eq 'dirlock_unlock')				{ undirlock_page();				}

elsif(get_qs_var('action') eq 'calendar')				{ show_event_calendar();			}
elsif(get_qs_var('action') eq 'calendarlog')				{ show_event_calendar_reminderlog();		}

elsif($qs =~ /(?:^|&)action=imagemodules(?:&|$)/)			{ check_image_modules();			}
elsif(get_qs_var('action') eq 'perlmodules')				{ show_installed_perl_modules(); }
elsif(get_qs_var('action') eq 'adminalerts')				{ show_admin_alerts();				}
elsif($qs =~ /(?:^|&)action=(un)?dismissadminalert&aid=(\w+)/)		{ dismiss_admin_alert($1,$2);			}

elsif($qs =~ /do_email_test/)						{ do_email_test();				}

elsif($qs =~ /^webconfig$/ || $qs =~ /action=webconfig/)		{ do_webconfig();				}
elsif(get_qs_var('action') eq 'savewebconfig')				{ save_webconfig_pref();			}   # unused?
elsif(get_qs_var('action') eq 'savewebconfigprefajax')			{ save_webconfig_pref_ajax();			}
elsif(get_qs_var('action') eq 'downloadwebconfig')			{ download_webconfig_file();			}
elsif(get_qs_var('action') eq 'create_pw_hash_ajax')			{ create_pw_hash_ajax();			}
elsif(get_qs_var('action') eq 'send_test_email_ajax')			{ send_test_email_ajax();			}
elsif(get_qs_var('action') eq 'savewebconfigprefajax')			{ save_webconfig_pref_ajax();			}
elsif(get_qs_var('action') eq 'testdbconnajax')				{ test_database_connection_ajax();		}
elsif(get_qs_var('action') eq 'ubdbsetup')				{ setup_database_prefs();			}
elsif($qs =~ /(?:^|&)action=rawfile&file=(\w+)/)			{ show_raw_file($1);				}

elsif($qs =~ /(?:^|&)action=showipndata(?:&|$)/)			{ show_ipn_data();				}
elsif(!$qs && $ENV{REQUEST_METHOD} =~ /post/i)				{ do_paypal_ipn();				}

else
{
	if($PREF{admin_is_logged_in}   &&   $PREF{always_redirect_admins_to})
	{
		$PREF{always_redirect_admins_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
		enc_redirect($PREF{always_redirect_admins_to});
	}
	elsif($PREF{member_is_logged_in}   &&   !$PREF{admin_is_logged_in}   &&   $PREF{always_redirect_members_to}) # need the !admin because admins are members too.
	{
		$PREF{always_redirect_members_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
		enc_redirect($PREF{always_redirect_members_to});
	}
	else
	{
		if($PREF{member_is_logged_in} && $qs !~ /forceloginform=true/)
		{
			print_main_menu();
		}
		else
		{
			prompt_for_login();
		}
	}
}
